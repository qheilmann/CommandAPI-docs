<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js rust">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>CommandAPI Documentation v9.6.0</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fontawesome/css/fontawesome.css">
        <link rel="stylesheet" href="fontawesome/css/brands.css">
        <link rel="stylesheet" href="fontawesome/css/solid.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="style.css">

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">Introduction</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Server Owner Usage</li><li class="chapter-item expanded "><a href="installation.html">Installation for server owners</a></li><li class="chapter-item expanded "><a href="config.html">Configuration for server owners</a></li><li class="chapter-item expanded "><a href="conversionforowners.html">Command conversion</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="conversionforownerssingle.html">Single command conversion</a></li><li class="chapter-item expanded "><a href="conversionforownerssingleargs.html">Single command conversion (with arguments)</a></li><li class="chapter-item expanded "><a href="conversionentityselectors.html">Entity selectors</a></li></ol></li><li class="chapter-item expanded "><a href="skippingproxysenders.html">Skipping proxy senders</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">CommandAPI Setup</li><li class="chapter-item expanded "><a href="setup_dev.html">Setting up your development environment</a></li><li class="chapter-item expanded "><a href="setup_shading.html">Shading the CommandAPI in your plugins</a></li><li class="chapter-item expanded "><a href="setup_annotations.html">Using the annotation system</a></li><li class="chapter-item expanded affix "><li class="part-title">Creating Commands</li><li class="chapter-item expanded "><a href="commandregistration.html">Command registration</a></li><li class="chapter-item expanded "><a href="commandunregistration.html">Command unregistration</a></li><li class="chapter-item expanded "><a href="commandexecutors.html">Command executors</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="normalexecutors.html">Normal command executors</a></li><li class="chapter-item expanded "><a href="proxysender.html">Proxied commandsenders</a></li><li class="chapter-item expanded "><a href="native.html">Native commandsenders</a></li><li class="chapter-item expanded "><a href="resultingcommandexecutors.html">Resulting command executors</a></li><li class="chapter-item expanded "><a href="commandfailures.html">Handling command failures</a></li></ol></li><li class="chapter-item expanded "><a href="arguments.html">Command arguments</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="commandarguments.html">CommandArguments</a></li><li class="chapter-item expanded "><a href="optional_arguments.html">Optional arguments</a></li><li class="chapter-item expanded "><a href="listed.html">Listed arguments</a></li><li class="chapter-item expanded "><a href="argumentsuggestions.html">Argument suggestions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="suggestionsinfo.html">The SuggestionsInfo record</a></li><li class="chapter-item "><a href="stringargumentsuggestions.html">String argument suggestions</a></li><li class="chapter-item "><a href="safeargumentsuggestions.html">Safely typed argument suggestions</a></li><li class="chapter-item "><a href="tooltips.html">Argument suggestions with tooltips</a></li><li class="chapter-item "><a href="asyncsuggestions.html">Asynchronous suggestions</a></li></ol></li><li class="chapter-item expanded "><a href="argumenttypes.html">Argument types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="argument_primitives.html">Primitive arguments</a></li><li class="chapter-item "><a href="argument_range.html">Ranged arguments</a></li><li class="chapter-item "><a href="argument_strings.html">String arguments</a></li><li class="chapter-item "><a href="category_positional_arguments.html">Positional arguments</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="argument_locations.html">Location arguments</a></li><li class="chapter-item "><a href="argument_rotation.html">Rotation arguments</a></li><li class="chapter-item "><a href="argument_axis.html">AxisArguments</a></li></ol></li><li class="chapter-item "><a href="argument_chats.html">Chat arguments</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="argument_chat_spigot.html">Spigot chat arguments</a></li><li class="chapter-item "><a href="argument_chat_adventure.html">Adventure chat arguments</a></li><li class="chapter-item "><a href="chatpreview.html">Chat preview</a></li></ol></li><li class="chapter-item "><a href="argument_entities.html">Entity & player arguments</a></li><li class="chapter-item "><a href="category_scoreboard_arguments.html">Scoreboard arguments</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="argument_scoreboards.html">Scoreboard arguments</a></li><li class="chapter-item "><a href="argument_objectives.html">Objective arguments</a></li><li class="chapter-item "><a href="argument_team.html">Team arguments</a></li></ol></li><li class="chapter-item "><a href="category_miscellaneous_arguments.html">Miscellaneous arguments</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="argument_angle.html">Angle arguments</a></li><li class="chapter-item "><a href="advancementargument.html">Advancement arguments</a></li><li class="chapter-item "><a href="argument_biome.html">Biome arguments</a></li><li class="chapter-item "><a href="argument_blockstate.html">BlockState arguments</a></li><li class="chapter-item "><a href="argument_enchantment.html">Enchantment arguments</a></li><li class="chapter-item "><a href="argument_itemstack.html">Itemstack arguments</a></li><li class="chapter-item "><a href="argument_loottable.html">LootTable argument</a></li><li class="chapter-item "><a href="argument_mathoperation.html">MathOperation arguments</a></li><li class="chapter-item "><a href="argument_namespacedkey.html">NamespacedKey arguments</a></li><li class="chapter-item "><a href="argument_particles.html">Particle arguments</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="argument_particle_old.html">Particle data (before 1.20.5)</a></li><li class="chapter-item "><a href="argument_particle_new.html">Particle data (1.20.5+)</a></li></ol></li><li class="chapter-item "><a href="argument_potion.html">Potion effect arguments</a></li><li class="chapter-item "><a href="argument_recipe.html">Recipe arguments</a></li><li class="chapter-item "><a href="argument_sound.html">Sound arguments</a></li><li class="chapter-item "><a href="argument_time.html">Time arguments</a></li><li class="chapter-item "><a href="argument_uuid.html">UUID arguments</a></li><li class="chapter-item "><a href="argument_world.html">World arguments</a></li></ol></li><li class="chapter-item "><a href="predicateargs.html">Predicate arguments</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="argument_blockpredicate.html">Block predicate arguments</a></li><li class="chapter-item "><a href="argument_itemstackpredicate.html">ItemStack predicate arguments</a></li></ol></li><li class="chapter-item "><a href="argument_nbt.html">NBT arguments</a></li><li class="chapter-item "><a href="category_literal_arguments.html">Literal arguments</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="argument_literal.html">Literal arguments</a></li><li class="chapter-item "><a href="argument_multiliteral.html">Multi literal arguments</a></li></ol></li><li class="chapter-item "><a href="argument_list.html">List arguments</a></li><li class="chapter-item "><a href="argument_map.html">Map arguments</a></li><li class="chapter-item "><a href="argument_command.html">Command arguments</a></li><li class="chapter-item "><a href="argument_custom.html">Custom arguments</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="functions.html">Functions & Tags</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="functionsetup.html">Setting up functions & tags</a></li><li class="chapter-item expanded "><a href="simplefunctionwrapper.html">The SimpleFunctionWrapper class</a></li><li class="chapter-item expanded "><a href="functionwrapper.html">The FunctionWrapper class</a></li><li class="chapter-item expanded "><a href="argument_function.html">Function arguments</a></li></ol></li><li class="chapter-item expanded "><a href="permissions.html">Permissions</a></li><li class="chapter-item expanded "><a href="requirements.html">Requirements</a></li><li class="chapter-item expanded "><a href="aliases.html">Aliases</a></li><li class="chapter-item expanded "><a href="help.html">Help</a></li><li class="chapter-item expanded "><a href="subcommands.html">Subcommands</a></li><li class="chapter-item expanded "><a href="commandtrees.html">Command trees</a></li><li class="chapter-item expanded affix "><li class="part-title">Annotation-based Commands</li><li class="chapter-item expanded "><a href="annotationsintro.html">Annotation-based commands</a></li><li class="chapter-item expanded "><a href="annotations.html">Annotations</a></li><li class="chapter-item expanded "><a href="registeringannotations.html">Registering annotation-based commands</a></li><li class="chapter-item expanded affix "><li class="part-title">Kotlin-based Commands</li><li class="chapter-item expanded "><a href="kotlinintro.html">Kotlin-based commands</a></li><li class="chapter-item expanded "><a href="kotlindsl.html">Using the DSL</a></li><li class="chapter-item expanded "><a href="delegated_properties.html">Delegated properties</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Velocity</li><li class="chapter-item expanded "><a href="velocity_intro.html">Velocity</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">CommandAPI Utilities</li><li class="chapter-item expanded "><a href="conversion.html">Command conversion</a></li><li class="chapter-item expanded "><a href="reloading.html">Plugin reloading</a></li><li class="chapter-item expanded affix "><li class="part-title">Internal CommandAPI</li><li class="chapter-item expanded "><a href="internal.html">Internal CommandAPI</a></li><li class="chapter-item expanded "><a href="brigadier.html">Brigadier + CommandAPI</a></li><li class="chapter-item expanded "><a href="brigadiersuggestions.html">Brigadier Suggestions</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">Java Tips</li><li class="chapter-item expanded "><a href="predicatetips.html">Predicate tips</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><li class="part-title">CommandAPI Contribution</li><li class="chapter-item expanded "><a href="contributionintro.html">Introduction</a></li><li class="chapter-item expanded "><a href="projectstructure.html">Project Structure</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="upgrading.html">Upgrading guide</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item expanded "><a href="upgrading_old.html">Upgrading guide (pre-9.0.0)</a></li></ol></li><li class="chapter-item expanded "><a href="faq.html">FAQ</a></li><li class="chapter-item expanded affix "><a href="incompatibleversions.html">Incompatible version information</a></li><li class="chapter-item expanded affix "><a href="troubleshooting.html">Troubleshooting</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="afterword.html">Afterword</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fas fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fas fa-palette"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="skepter">Skepter Likes Purple</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fas fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">CommandAPI Documentation v9.6.0</h1>

                    <div class="right-buttons">
                        <a href="https://www.jorel.dev/CommandAPI/" title="Back to main CommandAPI page" aria-label="Back to main CommandAPI page">
                            <i id="home-button" class="fas fa-home"></i>
                        </a>
                        <a href="https://ko-fi.com/jorelali" title="Donate (ko-fi)" aria-label="Donate (ko-fi)">
                            <i id="donate-button" class="fas fa-donate"></i>
                        </a>
                        <a href="https://discord.com/invite/G4SzSxZ" title="Discord" aria-label="Discord">
                            <i id="discord-button" class="fab fa-discord"></i>
                        </a>
                        <a href="https://github.com/JorelAli/CommandAPI" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fab fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!-- Page table of contents -->
                        <div class="sidetoc"><nav class="pagetoc"></nav></div>
                        
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to the documentation for the CommandAPI. The CommandAPI lets you create vanilla Minecraft commands which utilize the new command features which were implemented in Minecraft 1.13, including but not limited to:</p>
<ul>
<li>Having commands compatible with the vanilla <code>/execute</code> command</li>
<li>Having commands which can be run using Minecraft functions</li>
<li>Having better auto-completion and suggestions</li>
<li>Having command type checks before execution (e.g. ensuring a number is within a certain range)</li>
</ul>
<hr />
<h2 id="how-the-commandapi-works"><a class="header" href="#how-the-commandapi-works">How the CommandAPI works</a></h2>
<blockquote>
<p><strong>Developer's Note:</strong></p>
<p>This is a pretty important section, I would recommend reading before implementing the CommandAPI in your own projects. This section tells you about setup which is not stated anywhere else in the documentation. Think of it as the &quot;knowledge you should know before using this API&quot;.</p>
</blockquote>
<p>The CommandAPI does not follow the &quot;standard&quot; method of registering commands. In other words, commands which are registered with the CommandAPI will be registered as pure vanilla Minecraft commands as opposed to Bukkit or Spigot commands. This means that the following implications exist:</p>
<ul>
<li><strong>Commands should not be declared in the <code>plugin.yml</code> file.</strong></li>
<li>Commands are automatically registered under the <code>minecraft</code> namespace. For example, if you register a command <code>/hello</code>, you can also run it using <code>/minecraft:hello</code>. However, you can change this default <code>minecraft</code> namespace. More about this <a href="./commandregistration.html#registering-the-command">on the command registration page</a>.</li>
<li>Commands are not &quot;linked&quot; to a certain plugin. In other words, you cannot look up which commands are registered by which plugin.</li>
</ul>
<hr />
<h2 id="how-this-documentation-works"><a class="header" href="#how-this-documentation-works">How this documentation works</a></h2>
<p>This documentation is split into the major sections that build up the CommandAPI. It's been designed in such a way that it should be easy to find exactly what you want to help you get started with the CommandAPI, and how to make effective use of it. Each step of the way, the documentation will include examples which showcase how to use the CommandAPI.</p>
<p>You can use the side bar on the left to access the various sections of the documentation and can change the theme to your liking using the palette icon <i class="fas fa-palette"></i> in the top left corner.</p>
<p>Using the search icon <i class="fas fa-search"></i> in the top left corner, you can search for anything in this entire documentation. For example, typing &quot;Example&quot; will show a list of examples which are included throughout the documentation.</p>
<hr />
<h2 id="documentation-changelog"><a class="header" href="#documentation-changelog">Documentation changelog</a></h2>
<p>Here's the list of changes to the documentation between each update. You can view the current documentation version at the top of this page.</p>
<h3 id="documentation-changes-940-rightarrow-941"><a class="header" href="#documentation-changes-940-rightarrow-941">Documentation changes 9.4.0 \(\rightarrow\) 9.4.1</a></h3>
<ul>
<li>Updates <a href="./config.html">Configuration for server owners</a> page with new <code>skip-initial-datapack-reload</code> option.</li>
</ul>
<h3 id="documentation-changes-930-rightarrow-940"><a class="header" href="#documentation-changes-930-rightarrow-940">Documentation changes 9.3.0 \(\rightarrow\) 9.4.0</a></h3>
<ul>
<li>Updates <a href="./setup_shading.html">Shading the CommandAPI in your plugins</a> page with spigot-mapped and mojang-mapped dependencies</li>
<li>Adds <a href="./velocity_intro.html">Velocity</a> page to outline how to setup the CommandAPI for Velocity</li>
<li>Updates <a href="./commandarguments.html">CommandArguments</a> to document new additions for safe arguments</li>
<li>Updates <a href="./argument_potion.html">Potion effect arguments</a> to include examples for the newly added <code>NamespacedKey</code> variant for the <code>PotionEffectArgument</code></li>
<li>Updates <a href="./arguments.html">Arguments</a> to list the newly added <code>PotionEffectArgument.NamespacedKey</code> argument</li>
<li>Updates <a href="./argument_particles.html">Particles</a> page to include both <a href="./argument_particle_old.html">old particle information</a> and <a href="./argument_particle_new.html">new particle information</a></li>
</ul>
<h3 id="documentation-changes-920-rightarrow-930"><a class="header" href="#documentation-changes-920-rightarrow-930">Documentation changes 9.2.0 \(\rightarrow\) 9.3.0</a></h3>
<ul>
<li>Updates <a href="./incompatibleversions.html">Incompatible version information</a> page and <code>FunctionArgument</code> pages that functions made with the <code>FunctionArgument</code> will always return 1 when running on 1.20.3 and 1.20.4.</li>
<li>Updates <a href="./kotlindsl.html">Kotlin DSL</a> page to mention every possible executor method.</li>
</ul>
<h3 id="documentation-changes-910-rightarrow-920"><a class="header" href="#documentation-changes-910-rightarrow-920">Documentation changes 9.1.0 \(\rightarrow\) 9.2.0</a></h3>
<ul>
<li>Updates <a href="./argument_locations.html">Location arguments</a> page to mention the new <code>centerPosition</code> argument to center the position of integer values for location arguments.</li>
<li>Added <a href="./delegated_properties.html">Delegated properties</a> page to mention the added support of delegations.</li>
</ul>
<h3 id="documentation-changes-903-rightarrow-910"><a class="header" href="#documentation-changes-903-rightarrow-910">Documentation changes 9.0.3 \(\rightarrow\) 9.1.0</a></h3>
<ul>
<li>Updates <a href="./argument_multiliteral.html">Multi literal arguments</a> page to mention new <code>MultiLiteralArgument</code> constructor.</li>
<li>Adds <a href="./commandarguments.html">CommandArguments</a> page to explain the <code>CommandArguments</code> class introduced in 9.0.0</li>
<li>Adds <a href="./argument_chat_adventure.html">Adventure chat color argument</a> to the adventure chat arguments page.</li>
<li>Adds new <a href="./commandunregistration.html">Command unregistration</a> page.</li>
</ul>
<h3 id="documentation-changes-902-rightarrow-903"><a class="header" href="#documentation-changes-902-rightarrow-903">Documentation changes 9.0.2 \(\rightarrow\) 9.0.3</a></h3>
<ul>
<li>Updates <a href="./argument_map.html">Map arguments</a> page with new syntax</li>
</ul>
<h3 id="documentation-changes-901-rightarrow-902"><a class="header" href="#documentation-changes-901-rightarrow-902">Documentation changes 9.0.1 \(\rightarrow\) 9.0.2</a></h3>
<ul>
<li>Updates <a href="./argument_multiliteral.html">Multi literal arguments</a> page to add the node name information</li>
<li>Updates <a href="./help.html">Help</a> page so it contains <code>withUsage()</code> information</li>
</ul>
<h3 id="documentation-changes-900-rightarrow-901"><a class="header" href="#documentation-changes-900-rightarrow-901">Documentation changes 9.0.0 \(\rightarrow\) 9.0.1</a></h3>
<ul>
<li>Updates <a href="./optional_arguments.html">Optional arguments</a> page to update the method list for avoiding <code>null</code> values</li>
<li>Updates <a href="./normalexecutors.html">Normal command executors</a> page to now mention the existence of the <code>ExecutionInfo</code></li>
</ul>
<h3 id="documentation-changes-880-rightarrow-900"><a class="header" href="#documentation-changes-880-rightarrow-900">Documentation changes 8.8.0 \(\rightarrow\) 9.0.0</a></h3>
<blockquote>
<p><strong>Developer's Note:</strong></p>
<p>9.0.0 is a giant update that is incompatible with 8.8.x and prior versions. A lot of the documentation's code examples and explanations have been changed for the various changes made in this version. Please read the <a href="./upgrading.html">Upgrading guide</a> for information on how to upgrade to 9.0.0.</p>
</blockquote>
<ul>
<li>Adds the new <a href="./optional_arguments.html">Optional arguments</a> section</li>
<li>Adds Kotlin DSL code examples to all code examples</li>
</ul>
<h3 id="documentation-changes-870-rightarrow-880"><a class="header" href="#documentation-changes-870-rightarrow-880">Documentation changes 8.7.0 \(\rightarrow\) 8.8.0</a></h3>
<ul>
<li>Changed the version number from 8.7.0 to 8.8.0. That's it.</li>
</ul>
<h3 id="documentation-changes-860-rightarrow-870"><a class="header" href="#documentation-changes-860-rightarrow-870">Documentation changes 8.6.0 \(\rightarrow\) 8.7.0</a></h3>
<blockquote>
<p><strong>Developer's Note:</strong></p>
<p><code>SoundArgument</code>s written for 8.6.0 are incompatible with this update! Other significant changes to <code>ScoreHolderArgument</code> and <code>EntitySelectorArgument</code> were made in this update. I highly recommend reading the <a href="./upgrading.html">Upgrading guide</a> section which covers the changes in more detail and how to update your plugin for this version.</p>
</blockquote>
<ul>
<li>Updated <a href="./argument_biome.html">Biome arguments</a> to allow for <code>NamespacedKey</code> objects</li>
<li>Updated <a href="./argument_sound.html">Sound arguments</a> with the new <code>NamespacedKey</code> constructor</li>
<li>Updated <a href="./argument_scoreboards.html">Scoreboard arguments</a> with the new <code>Single</code> and <code>Multiple</code> constructors</li>
<li>Updated <a href="./argument_entities.html">Entity &amp; player arguments</a> to include the new <code>OneEntity</code>, <code>ManyEntities</code>, <code>OnePlayer</code> and <code>ManyPlayers</code> constructors</li>
</ul>
<h3 id="documentation-changes-851-rightarrow-860"><a class="header" href="#documentation-changes-851-rightarrow-860">Documentation changes 8.5.1 \(\rightarrow\) 8.6.0</a></h3>
<ul>
<li>Greatly improved the format and documentation for <a href="./config.html">Configuration for server owners</a></li>
<li>Adds a Kotlin tab to all Java code blocks which displays the equivalent code, but in Kotlin</li>
<li>Adds the new <a href="./argument_command.html">Command arguments</a> section</li>
<li>Adds the new <a href="./argument_world.html">World arguments</a> section</li>
<li>Mentions the new <code>LiteralArgument.of()</code> and <code>LiteralArgument.literal()</code> methods in <a href="./argument_literal.html">Literal arguments</a></li>
<li>Adds a really cool new example to the <a href="./brigadiersuggestions.html">Brigadier Suggestions</a> page</li>
<li>Updated various sections (a summary of this can be found in the <a href="./upgrading.html">Upgrading guide</a>):
<ul>
<li>Update <a href="./argument_list.html">List arguments</a> to include the new <code>buildGreedy()</code> and <code>buildText()</code> methods</li>
<li>Update <a href="./commandfailures.html">Handling command failures</a> with new methods</li>
<li>Update <a href="./tooltips.html">Argument suggestions with tooltips</a> with new tooltip methods for formatting text</li>
<li>Update <a href="./argument_sound.html">Sound arguments</a> with support for namespaced keys</li>
</ul>
</li>
<li>Adds documentation for <a href="./kotlinintro.html">Kotlin-based commands</a> using the Kotlin DSL</li>
<li>Update the <a href="./afterword.html">Afterword</a>, giving special credits to some very special contributors!</li>
</ul>
<h3 id="documentation-changes-850-rightarrow-851"><a class="header" href="#documentation-changes-850-rightarrow-851">Documentation changes 8.5.0 \(\rightarrow\) 8.5.1</a></h3>
<ul>
<li>Update <a href="./brigadier.html">Brigadier + CommandAPI</a> with function parameter changes. See <a href="./upgrading.html">Upgrading</a> for more info.</li>
</ul>
<h3 id="documentation-changes-840-rightarrow-850"><a class="header" href="#documentation-changes-840-rightarrow-850">Documentation changes 8.4.0 \(\rightarrow\) 8.5.0</a></h3>
<ul>
<li>Adds <a href="./chatpreview.html">Chat preview</a> section</li>
<li>Adds Kotlin-DSL <code>build.gradle.kts</code> instructions for using the CommandAPI</li>
<li>Adds <code>CommandAPI.onDisable()</code> method to <a href="./setup_shading.html#disabling">Shading the CommandAPI in your plugins</a></li>
</ul>
<h3 id="documentation-changes-830-rightarrow-840"><a class="header" href="#documentation-changes-830-rightarrow-840">Documentation changes 8.3.0 \(\rightarrow\) 8.4.0</a></h3>
<ul>
<li>Updated <a href="./setup_shading.html#shading-with-maven">Shading with Maven</a> with updated <code>maven-shade-plugin</code> version</li>
<li>Adds <a href="./argument_namespacedkey.html">NamespacedKey arguments</a> section</li>
<li>Update <a href="./arguments.html#argument-casting">Argument Casting</a> section with new arguments and types</li>
<li>Update <a href="./argument_nbt.html">NBT arguments</a> page with new NBT arguments information</li>
<li>Update <a href="./argument_custom.html">Custom arguments</a> page with new custom arguments information</li>
<li>Adds <a href="./internal.html#getting-a-list-of-registered-commands">Getting a list of registered commands</a> section to the Internal CommandAPI page</li>
<li>Update <a href="./upgrading.html">Upgrading guide</a> for 8.4.0 changes</li>
</ul>
<h3 id="documentation-changes-820-rightarrow-821"><a class="header" href="#documentation-changes-820-rightarrow-821">Documentation changes 8.2.0 \(\rightarrow\) 8.2.1</a></h3>
<ul>
<li>Adds <code>withSubcommands</code> method to <a href="./subcommands.html">Subcommands</a> section.</li>
</ul>
<h3 id="documentation-changes-800-rightarrow-820"><a class="header" href="#documentation-changes-800-rightarrow-820">Documentation changes 8.0.0 \(\rightarrow\) 8.2.0</a></h3>
<ul>
<li>Adds <a href="./argument_list.html">List arguments</a> section.</li>
<li>Fix bug with <a href="./normalexecutors.html#multiple-command-executors-with-the-same-implementation">Multiple command executors with the same implementation</a> example.</li>
</ul>
<h3 id="documentation-changes-700-rightarrow-800"><a class="header" href="#documentation-changes-700-rightarrow-800">Documentation changes 7.0.0 \(\rightarrow\) 8.0.0</a></h3>
<ul>
<li>Updated particle arguments in the <a href="./argument_particles.html">Particle arguments</a> section.</li>
<li>Update the <a href="./upgrading.html">Upgrading guide</a> for the new changes in 8.0.0.</li>
</ul>
<h3 id="documentation-changes-654-rightarrow-700"><a class="header" href="#documentation-changes-654-rightarrow-700">Documentation changes 6.5.4 \(\rightarrow\) 7.0.0</a></h3>
<ul>
<li>Changed the repo that the CommandAPI is served from JitPack to Maven Central.</li>
<li>Remove direct link to <code>CommandAPI.jar</code> file from <a href="./installation.html">Installation for server owners</a>, in favor of pointing to the latest release page (to allow version numbers to appear in the file name).</li>
<li>Rewrite the <a href="./argumentsuggestions.html">Argument suggestions</a> section to cover the new argument suggestions API.</li>
<li>Update the <a href="./upgrading.html">Upgrading guide</a> for the new changes in 7.0.0.</li>
<li>Update repository information in the <a href="./setup_shading.html">Shading the CommandAPI in your plugins</a> page.</li>
<li>Update the <a href="./brigadier.html">Brigadier + CommandAPI</a> page with updated methods.</li>
<li>Adds an example of using Brgiader's <code>SuggestionsBuilder</code> in the <a href="./brigadiersuggestions.html">Brigadier Suggestions</a> section.</li>
<li>Updated the colors of links, example blocks and warning blocks to meet accessibility contrast guidelines better.</li>
<li>Adds <a href="./commandtrees.html">Command trees</a> section.</li>
<li>Update <a href="./commandfailures.html">Handling command failures</a> to fit new <code>throw</code> requirement for command failures.</li>
<li>Updated <a href="./normalexecutors.html#multiple-command-executors-with-the-same-implementation">Normal command executors</a> with the new multiple command executors with the same implementation feature.</li>
</ul>
<h3 id="documentation-changes-640-rightarrow-654"><a class="header" href="#documentation-changes-640-rightarrow-654">Documentation changes 6.4.0 \(\rightarrow\) 6.5.4</a></h3>
<ul>
<li>Update the Maven and Gradle pages to say to use CommandAPI version 6.5.4 because this kept confusing everyone.</li>
</ul>
<h3 id="documentation-changes-631-rightarrow-640"><a class="header" href="#documentation-changes-631-rightarrow-640">Documentation changes 6.3.1 \(\rightarrow\) 6.4.0</a></h3>
<ul>
<li>Adds a section <a href="./help.html">Help</a> for the new help feature.</li>
<li>Update <a href="./annotations.html">Annotations</a> section to include new <code>@Help</code> annotation.</li>
</ul>
<h3 id="documentation-changes-630-rightarrow-631"><a class="header" href="#documentation-changes-630-rightarrow-631">Documentation changes 6.3.0 \(\rightarrow\) 6.3.1</a></h3>
<ul>
<li>Adds Java 16 error to <a href="./troubleshooting.html">Troubleshooting</a>.</li>
<li>Update <a href="faq.html">FAQ</a>.</li>
<li>Adds some useful tools to <a href="./conversionforowners.html">Command conversion</a> to get plugin info and check <code>config.yml</code> validity.</li>
<li>Adds <a href="./reloading.html">Plugin reloading</a> page which describes how to add minimal support for <code>/reload</code>.</li>
</ul>
<h3 id="documentation-changes-620-rightarrow-630"><a class="header" href="#documentation-changes-620-rightarrow-630">Documentation changes 6.2.0 \(\rightarrow\) 6.3.0</a></h3>
<ul>
<li>Update <a href="./argument_custom.html">Custom arguments</a> page with new custom argument constructor information</li>
<li>Adds upgrade info to the <a href="./upgrading.html#from-version-620-to-630">Upgrading guide</a> to help upgrade any existing custom arguments which you may have.</li>
</ul>
<h3 id="documentation-changes-600-rightarrow-620"><a class="header" href="#documentation-changes-600-rightarrow-620">Documentation changes 6.0.0 \(\rightarrow\) 6.2.0</a></h3>
<ul>
<li>Update <a href="./config.html">Configuration for server owners</a> page with new config options <code>missing-executor-implementation</code> and <code>use-latest-nms-version</code></li>
<li>Update instructions for shading the CommandAPI with maven in <a href="./setup_shading.html#shading-with-maven">Shading the CommandAPI in your plugins</a> to support Java 16.</li>
<li>Mention that commands registered with the CommandAPI appear in the <code>minecraft:</code> namespace (see above under &quot;How the CommandAPI works&quot;)</li>
</ul>
<h3 id="documentation-changes-512-rightarrow-600"><a class="header" href="#documentation-changes-512-rightarrow-600">Documentation changes 5.12 \(\rightarrow\) 6.0.0</a></h3>
<ul>
<li>Adds entry for <a href="./upgrading.html#from-version-5x-to-600">Upgrading guide</a> to help update from 5.12 to 6.0.0.</li>
<li>Adds new <code>silent-logs</code> config entry to <a href="./config.html">Configuration for server owners</a></li>
<li>Update syntax for <code>onLoad(CommandAPIConfig)</code> for <a href="./setup_shading.html">Shading the CommandAPI in your plugins</a></li>
<li>Update <a href="./argumentsuggestions.html">Argument suggestions</a> including new <code>replaceSuggestions</code> method</li>
<li>Adds documentation for <a href="./argument_entities.html#offlineplayer-argument">OfflinePlayerArgument</a></li>
<li>Adds a new section <strong>CommandAPI Contribution</strong> which gives a bit of insight into the project structure of the CommandAPI (Still in progress, not complete yet)</li>
<li>Fix old documentation typos</li>
<li>Fix spacing issues in some existing code blocks</li>
<li>Adds syntax highlighting for Minecraft commands in code blocks</li>
<li>Fix old code examples which didn't work anymore</li>
</ul>
<h3 id="documentation-changes-511-rightarrow-512"><a class="header" href="#documentation-changes-511-rightarrow-512">Documentation changes 5.11 \(\rightarrow\) 5.12</a></h3>
<blockquote>
<p><strong>Developer's Note</strong></p>
<p>The Maven/Gradle repository URL has changed! See <a href="./setup_dev.html">5. Setting up your development environment</a> for more information. For older versions of the CommandAPI (versions 5.11 and below), please consult the older documentation which can be found on the homepage <a href="https://commandapi.jorel.dev/">here</a>.</p>
</blockquote>
<ul>
<li>Change the repository URL for the CommandAPI in <a href="./setup_dev.html">5. Setting up your development environment</a></li>
<li>Update the <a href="./afterword.html">Afterword</a></li>
</ul>
<h3 id="documentation-changes-510-rightarrow-511"><a class="header" href="#documentation-changes-510-rightarrow-511">Documentation changes 5.10 \(\rightarrow\) 5.11</a></h3>
<ul>
<li>Adds a section <a href="./conversionforownerssingle.html#arbitrary-command-conversion">Arbitrary command conversion</a> on how to convert arbitrary commands</li>
<li>Adds a section <a href="./conversionentityselectors.html">3.3. Entity selectors</a> describing how to convert entity selector commands with the CommandAPI's command conversion system</li>
<li>Updated the <a href="./conversionforownerssingleargs.html#list-of-all-supported-argument-types">list of all suppoprted argument types</a> for command conversion</li>
</ul>
<h3 id="documentation-changes-56-rightarrow-510"><a class="header" href="#documentation-changes-56-rightarrow-510">Documentation changes 5.6 \(\rightarrow\) 5.10</a></h3>
<ul>
<li>Splits chat argument sections into two: <a href="./argument_chat_spigot.html">11.5.1. Spigot chat arguments</a> and <a href="./argument_chat_adventure.html">11.5.2. Adventure chat arguments</a></li>
<li>Adds a <a href="./faq.html">FAQ page</a></li>
<li>Adds a warning about shading in <a href="./setup_shading.html">6. Shading the CommandAPI in your plugins</a></li>
</ul>
<h3 id="documentation-changes-53-rightarrow-56"><a class="header" href="#documentation-changes-53-rightarrow-56">Documentation changes 5.3 \(\rightarrow\) 5.6</a></h3>
<ul>
<li>Adds a section <a href="./skippingproxysenders.html">4. Skipping proxy senders</a> which describes how to use the <code>skip-sender-proxy</code> configuration option.</li>
</ul>
<h3 id="documentation-changes-52-rightarrow-53"><a class="header" href="#documentation-changes-52-rightarrow-53">Documentation changes 5.2 \(\rightarrow\) 5.3</a></h3>
<ul>
<li>Adds a section <a href="./setup_annotations.html">6. Using the annotation system</a> on setting up your development environment to use the annotation system</li>
<li>Adds a whole massive section on using annotations (<a href="./annotationsintro.html">16. Annotation-based commands</a>, <a href="./annotations.html">17. Annotations</a>, <a href="./registeringannotations.html">18. Registering annotation-based commands</a>)</li>
<li>Adds a section on argument suggestion deferral in section <a href="./argumentsuggestions.html#argument-suggestion-deferral">9.1. Argument suggestions</a></li>
<li>Improve warning for <code>LiteralArgument</code> - instead of it being &quot;obsolete&quot; compared to the <code>MultiLiteralArgument</code>, it is now &quot;more complex&quot; than <code>MultiLiteralArgument</code>s</li>
<li>Fix issue in the section for custom arguments which should have been updated but wasn't</li>
</ul>
<h3 id="documentation-changes-51-rightarrow-52"><a class="header" href="#documentation-changes-51-rightarrow-52">Documentation changes 5.1 \(\rightarrow\) 5.2</a></h3>
<ul>
<li>Adds brief documentation for the CommandAPI's <code>reloadDatapacks</code> method in <a href="./internal.html#reloading-datapacks">16. Internal CommandAPI</a></li>
</ul>
<h3 id="documentation-changes-50-rightarrow-51"><a class="header" href="#documentation-changes-50-rightarrow-51">Documentation changes 5.0 \(\rightarrow\) 5.1</a></h3>
<ul>
<li>Adds a section <a href="./simplefunctionwrapper.html">10.2. The SimpleFunctionWrapper class</a> which outlines the new <code>SimpleFunctionWrapper</code> class</li>
<li>Updates the documentation for <a href="./functionwrapper.html">10.3. The FunctionWrapper class</a></li>
<li>Update the name of the package from <code>dev.jorel.commandapi.CommandAPIHandler.Brigadier</code> to <code>dev.jorel.commandapi.Brigadier</code> in section <a href="./brigadier.html#brigadier-support-functions">17. Brigadier + CommandAPI</a></li>
<li>Update the documentation for <a href="./permissions.html">11. Permissions</a> stating that you can use <code>withPermission(String)</code> instead of <code>withPermission(CommandPermission)</code></li>
</ul>
<h3 id="documentation-changes-43-rightarrow-50"><a class="header" href="#documentation-changes-43-rightarrow-50">Documentation changes 4.3 \(\rightarrow\) 5.0</a></h3>
<blockquote>
<p><strong>Developer's Note:</strong></p>
<p>Lots and lots and lots of changes occurred in version 5.0! I highly recommend reading the <a href="./upgrading.html">Upgrading guide</a> section which covers the changes in more detail and how to update your plugin for this version.</p>
</blockquote>
<p>Every page has been rewritten in this update and checked for errors. In general, this is the list of new additions:</p>
<ul>
<li>New section <a href="./conversionforowners.html">3. Command conversion</a> dedicated to command conversion via the <code>config.yml</code></li>
<li>New section <a href="./listed.html">8.4. Listed arguments</a></li>
<li>New section <a href="./argument_angle.html">9.8.1. Angle arguments</a></li>
<li>New section <a href="./subcommands.html">14. Subcommands</a></li>
<li>New section <a href="./internal.html">16. Internal CommandAPI</a> now lists all arguments and their respective Minecraft argument IDs</li>
<li>Mentions listed arguments in section <a href="./argument_literal.html">9.11.1. Literal arguments</a></li>
<li>Section <a href="./conversion.html">15. Command conversion</a> has been rewritten</li>
<li>Executes native is now present in the command registration page</li>
<li>Section <a href="./tooltips.html">8.3. Argument suggestions with tooltips</a> now mentions the <code>IStringTooltip</code> class</li>
</ul>
<h3 id="documentation-changes-42-rightarrow-43"><a class="header" href="#documentation-changes-42-rightarrow-43">Documentation changes 4.2 \(\rightarrow\) 4.3</a></h3>
<ul>
<li>Improve the documentation for <a href="./config.html">2. Configuration for server owners</a> by using simple YAML lists (using the <code>-</code> symbol) and update the command conversion syntax for all commands using the <code>~</code> syntax</li>
<li>Adds the command sender priority to <a href="./normalexecutors.html#multiple-command-executor-implementations">6.1. Normal command executors</a></li>
<li>Adds new method and example for converting specific commands internally in <a href="./conversion.html#only-specific-commands">13. Command conversion</a></li>
<li>Adds two sneaky little buttons in the main title toolbar at the top of the page</li>
</ul>
<h3 id="documentation-changes-41-rightarrow-42"><a class="header" href="#documentation-changes-41-rightarrow-42">Documentation changes 4.1 \(\rightarrow\) 4.2</a></h3>
<ul>
<li>Adds a warning about using redirected commands for suggestions that depend on previous arguments in <a href="./argumentsuggestions.html#suggestions-depending-on-previous-arguments">7.1. Argument suggestions</a></li>
<li>Adds a new section <a href="./native.html">6.3. Native commandsenders</a></li>
<li>Update documentation for <a href="normalexecutors.html#restricting-who-can-run-your-command">6.1. Normal command executors</a> to include the <code>.executesNative()</code> method for native command senders</li>
</ul>
<h3 id="documentation-changes-40-rightarrow-41"><a class="header" href="#documentation-changes-40-rightarrow-41">Documentation changes 4.0 \(\rightarrow\) 4.1</a></h3>
<ul>
<li>Adds a new section <a href="./tooltips.html">7.3. Argument suggestions with tooltips</a></li>
<li>Adds documentation for the <code>MultiLiteralArgument</code> in section <a href="./argument_multiliteral.html">8.11.2. Multi literal arguments</a></li>
<li>Adds a new section <a href="./setup_shading.html">4. Shading the CommandAPI into your plugins</a></li>
<li>Update documentation for <a href="./brigadier.html">14. Brigadier + CommandAPI</a> with new (overloaded) function <code>argBuildOf</code></li>
<li>Update <a href="./afterword.html">Afterword</a></li>
</ul>
<h3 id="documentation-changes-34-rightarrow-40"><a class="header" href="#documentation-changes-34-rightarrow-40">Documentation changes 3.4 \(\rightarrow\) 4.0</a></h3>
<ul>
<li>Update the maven and gradle documentation to state that it is <code>provided</code> and <code>compileOnly</code></li>
<li>The project has been renamed from the &quot;1.13 Command API&quot; to simply the &quot;CommandAPI&quot;. This has changed a few things, such as various links. See the section <a href="./upgrading.html">Upgrading guide</a> to view the relevant changes with regards to maven.</li>
<li>Updated <a href="./setup_dev.html">3. Setting up your development environment</a> to include new Maven repository links</li>
<li>Fixed stronkage with Java versions - there's now no random warning boxes about incompatibility with Java 12!</li>
<li>Arguments now include pictures that showcase how they work!</li>
<li>Reorganised the sections - arguments is now split up into two sections: <a href="./arguments.html">6. Arguments (in general)</a> and <a href="./argumenttypes.html">7. Argument types</a></li>
<li>Adds documentation for <a href="./safeargumentsuggestions.html">6.2. Safe argument suggestions</a></li>
<li>Adds documentation for <a href="./argument_blockstate.html">7.8.3. BlockState arguments</a></li>
<li>Adds documentation for new arguments:
<ul>
<li><code>UUIDArgument</code>: <a href="./argument_uuid.html">7.8.14. UUID arguments</a></li>
<li><code>BlockPredicateArgument</code>: <a href="./argument_blockpredicate.html">7.9.1. Block predicate arguments</a></li>
<li><code>ItemStackPredicateArgument</code>: <a href="./argument_itemstackpredicate.html">7.9.2. ItemStack predicate arguments</a></li>
</ul>
</li>
<li>Adds page <a href="./incompatibleversions.html">Incompatible version information</a> outlining what parts of the CommandAPI are incompatible with what versions of Minecraft</li>
<li>Adds <code>getCommands()</code> documentation to the <a href="./functionwrapper.html#getcommands">8.2. The FunctionWrapper class</a> page</li>
<li>Adds page <a href="./brigadier.html">13. Brigadier + CommandAPI</a> which shows how the CommandAPI can be used with Brigadier side-by-side</li>
<li>Adds page <a href="./requirements.html">10. Requirements</a> for the requirements feature to help restrict commands</li>
<li>Adds page <a href="./predicatetips.html">14. Predicate tips</a> with information on how to reduce the amount of repeated code when using requirements</li>
<li>Update <a href="./afterword.html">Afterword</a></li>
</ul>
<h3 id="documentation-changes-33-rightarrow-34"><a class="header" href="#documentation-changes-33-rightarrow-34">Documentation changes 3.3 \(\rightarrow\) 3.4</a></h3>
<ul>
<li>Moves configuration for server owners to a new section <a href="./config.html">2. Configuration for server owners</a>. This has the side-effect of also re-numbering all of the sections on the left. Sorry!</li>
<li>Adds server owner documentation for the CommandAPI's config command conversion system in section <a href="./config.html#command-conversion">2. Configuration for server owners</a></li>
<li>Update the conversion page <a href="./conversion.html">10. Command conversion</a> so it should be much easier to follow and understand</li>
<li>Changed the list of Java versions that the CommandAPI is compatible with in the <a href="./troubleshooting.html#commandapi-errors-when-reloading-datapacks">Troubleshooting</a> section</li>
</ul>
<h3 id="documentation-changes-31-rightarrow-33"><a class="header" href="#documentation-changes-31-rightarrow-33">Documentation changes 3.1 \(\rightarrow\) 3.3</a></h3>
<ul>
<li>Adds information on how functions are loaded in 1.16+ in section <a href="./functions.html#functions-in-116">6. Functions &amp; Tags</a></li>
<li>Added function error messages to section <a href="./troubleshooting.html#server-errors-when-loading-datapacks-in-116">Troubleshooting</a></li>
</ul>
<h3 id="documentation-changes-30-rightarrow-31"><a class="header" href="#documentation-changes-30-rightarrow-31">Documentation changes 3.0 \(\rightarrow\) 3.1</a></h3>
<ul>
<li>Adds new section <a href="./argumentsuggestions.html">5.1 Argument suggestions</a> to cover how to override suggestions - Having it all in section <em>5. Arguments</em> was a bit too content-heavy</li>
<li>Adds documentation for the new <code>.overrideSuggestions()</code> method in section <a href="./argumentsuggestions.html#suggestions-depending-on-previous-arguments">5.1 Argument suggestions</a></li>
<li>Simplified the description of the documentation updates</li>
<li>Changed the artifact ID for the dependency of the CommandAPI. Instead of being <code>commandapi</code>, it is now <code>commandapi-core</code>. You can view the changes in section <a href="./setup_dev.html">2 Setting up your development environment</a></li>
<li>Changed the repository information for gradle in section <a href="./setup_dev.html">2 Setting up your development environment</a>. You now have to include the NBTAPI repository because gradle can't automatically detect this for some reason. Kinda stupid tbh.</li>
<li>Adds a section on using multiple or optional arguments in section <a href="./arguments.html#optionaldifferent-arguments">5 Arguments</a></li>
</ul>
<h3 id="documentation-changes-21-rightarrow-30"><a class="header" href="#documentation-changes-21-rightarrow-30">Documentation changes 2.1 \(\rightarrow\) 3.0</a></h3>
<blockquote>
<p><strong>Developer's Note:</strong></p>
<p>Lots of changes occurred in version 3.0. I highly recommend reading the <a href="./upgrading.html">Upgrading guide</a> section which covers the changes in more detail and how to update your plugin for this version.</p>
</blockquote>
<ul>
<li>Sections on the left have been tidied up and should be more &quot;approachable&quot;</li>
<li>Installation section (<a href="./installation.html">1. Installation for server owners</a>) now includes information about additional dependencies</li>
<li>Dependency section (<a href="./setup_dev.html">2. Setting up your development environment</a>) updated to use the new dependency Group ID</li>
<li>Command registration section (<a href="./commandregistration.html">3. Command registration</a>) updated to reflect new API changes</li>
<li>Command execution section (<a href="./commandexecutors.html">4. Command Executors</a>) updated to reflect new API changes</li>
<li>Arguments section (<a href="./arguments.html">5. Arguments</a>) completely rewritten to reflect new API changes. Adds more detailed examples for each argument</li>
<li>Function arguments section (<a href="./argument_function.html">6.3 Function Arguments</a>) updated to reflect new API changes</li>
<li>Permissions section (<a href="./permissions.html">7. Permissions</a>) updated to reflect new API changes</li>
<li>Aliases section (<a href="./aliases.html">8. Aliases</a>) updated to reflect new API changes</li>
<li>Command conversion section (<a href="./conversion.html">9. Command conversion</a>) rewrite example to be more detailed</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>Installing the CommandAPI is easy! Just download the latest <code>CommandAPI-XXX.jar</code> file using the button below and place it in your server's <code>plugins/</code> folder!</p>
<br>
<p><a href="https://github.com/JorelAli/CommandAPI/releases/latest" style="
background-color:#EB7035;
border-radius:3px;
color:#ffffff;
display:block;
line-height:44px;
text-align:center;
width:40%;
margin-top: -30px;
margin-bottom: 30px;
margin-left:auto;
margin-right: auto;">Download latest CommandAPI plugin</a></p>
<hr />
<h2 id="additional-dependencies"><a class="header" href="#additional-dependencies">Additional dependencies</a></h2>
<ul>
<li>If you use NBT data, you'll also need the <a href="https://www.spigotmc.org/resources/nbt-api.7939/">NBT API</a>. (You can find out from your developers if you need this or not)</li>
<li>If you are using raw JSON chat data, you'll need to be running <a href="https://www.spigotmc.org/wiki/about-spigot/">Spigot</a> or a Paper-based server such as <a href="https://papermc.io/">Paper</a> or <a href="https://purpurmc.org/">Purpur</a>. (Again, you can find out from your developers if you need this or not)</li>
</ul>
<hr />
<h2 id="running-the-commandapi-on-old-versions-of-minecraft"><a class="header" href="#running-the-commandapi-on-old-versions-of-minecraft">Running the CommandAPI on old versions of Minecraft</a></h2>
<p>The CommandAPI is written and compiled using Java 16, and is only compatible with Minecraft servers that are compatible with Java 16 or higher. Attempting to use the CommandAPI on an old version of Minecraft (1.13 to 1.16.5) will throw an error (containing &quot;org.bukkit.plugin.InvalidPluginException&quot;):</p>
<pre><code class="language-log">[11:14:40 ERROR]: Could not load 'plugins\CommandAPI-8.7.3.jar' in folder 'plugins'
org.bukkit.plugin.InvalidPluginException: java.lang.UnsupportedClassVersionError: dev/jorel/commandapi/CommandAPIMain has been compiled by a more recent version of the Java Runtime (class file version 60.0), this version of the Java Runtime only recognizes class file versions up to 52.0
        at org.bukkit.plugin.java.JavaPluginLoader.loadPlugin(JavaPluginLoader.java:138) ~[patched_1.13.2.jar:git-Paper-657]
        at org.bukkit.plugin.SimplePluginManager.loadPlugin(SimplePluginManager.java:334) ~[patched_1.13.2.jar:git-Paper-657]
        at org.bukkit.plugin.SimplePluginManager.loadPlugins(SimplePluginManager.java:255) ~[patched_1.13.2.jar:git-Paper-657]
        at org.bukkit.craftbukkit.v1_13_R2.CraftServer.loadPlugins(CraftServer.java:331) ~[patched_1.13.2.jar:git-Paper-657]
        at net.minecraft.server.v1_13_R2.DedicatedServer.init(DedicatedServer.java:235) ~[patched_1.13.2.jar:git-Paper-657]
        at net.minecraft.server.v1_13_R2.MinecraftServer.run(MinecraftServer.java:787) ~[patched_1.13.2.jar:git-Paper-657]
        at java.lang.Thread.run(Thread.java:745) [?:1.8.0_42]
Caused by: java.lang.UnsupportedClassVersionError: dev/jorel/commandapi/CommandAPIMain has been compiled by a more recent version of the Java Runtime (class file version 60.0), this version of the Java Runtime only recognizes class file versions up to 52.0
        at java.lang.ClassLoader.defineClass1(Native Method) ~[?:1.8.0_42]
        at java.lang.ClassLoader.defineClass(ClassLoader.java:760) ~[?:1.8.0_42]
        at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142) ~[?:1.8.0_42]
        at org.bukkit.plugin.java.PluginClassLoader.findClass(PluginClassLoader.java:136) ~[patched_1.13.2.jar:git-Paper-657]
        at org.bukkit.plugin.java.PluginClassLoader.findClass(PluginClassLoader.java:86) ~[patched_1.13.2.jar:git-Paper-657]
        at java.lang.ClassLoader.loadClass(ClassLoader.java:424) ~[?:1.8.0_42]
        at java.lang.ClassLoader.loadClass(ClassLoader.java:357) ~[?:1.8.0_42]
        at java.lang.Class.forName0(Native Method) ~[?:1.8.0_42]
        at java.lang.Class.forName(Class.java:348) ~[?:1.8.0_42]
        at org.bukkit.plugin.java.PluginClassLoader.&lt;init&gt;(PluginClassLoader.java:64) ~[patched_1.13.2.jar:git-Paper-657]
        at org.bukkit.plugin.java.JavaPluginLoader.loadPlugin(JavaPluginLoader.java:134) ~[patched_1.13.2.jar:git-Paper-657]
        ... 6 more
</code></pre>
<p>This can be mitigated by running a <a href="https://papermc.io/">Paper</a> Minecraft server with the following command flag during startup:</p>
<pre><code class="language-sh">-DPaper.IgnoreJavaVersion=true
</code></pre>
<div class="example">
<h3 id="example---running-the-commandapi-using-java-17-and-minecraft-1132"><a class="header" href="#example---running-the-commandapi-using-java-17-and-minecraft-1132">Example - Running the CommandAPI using Java 17 and Minecraft 1.13.2</a></h3>
<p>For example, to use the CommandAPI with Java 17 and Minecraft 1.13.2:</p>
<ul>
<li>
<p>Download a Paper server from the <a href="https://papermc.io/downloads/all">Paper downloads page</a> for Minecraft 1.13.2</p>
</li>
<li>
<p>Run the following command in a terminal to start your Minecraft server:</p>
<pre><code class="language-sh">java -DPaper.IgnoreJavaVersion=true -jar paper-1.13.2-657.jar
</code></pre>
</li>
</ul>
</div>
<p>Performing this will successfully load the CommandAPI, although various errors will appear in the console during startup. These errors (that start with &quot;Fatal error trying to convert CommandAPI&quot;) can be ignored:</p>
<pre><code class="language-log">[11:17:49 ERROR]: Fatal error trying to convert CommandAPI v8.7.3:dev/jorel/commandapi/CommandAPIMain.class
java.lang.IllegalArgumentException: Unsupported class file major version 60
        at org.objectweb.asm.ClassReader.&lt;init&gt;(ClassReader.java:195) ~[patched_1.13.2.jar:git-Paper-657]
        at org.objectweb.asm.ClassReader.&lt;init&gt;(ClassReader.java:176) ~[patched_1.13.2.jar:git-Paper-657]
        at org.objectweb.asm.ClassReader.&lt;init&gt;(ClassReader.java:162) ~[patched_1.13.2.jar:git-Paper-657]
        at org.bukkit.craftbukkit.v1_13_R2.util.Commodore.convert(Commodore.java:170) ~[patched_1.13.2.jar:git-Paper-657]
        at org.bukkit.craftbukkit.v1_13_R2.util.CraftMagicNumbers.processClass(CraftMagicNumbers.java:238) ~[patched_1.13.2.jar:git-Paper-657]
        at org.bukkit.plugin.java.PluginClassLoader.findClass(PluginClassLoader.java:113) ~[patched_1.13.2.jar:git-Paper-657]
        at org.bukkit.plugin.java.PluginClassLoader.findClass(PluginClassLoader.java:86) ~[patched_1.13.2.jar:git-Paper-657]
        at java.lang.ClassLoader.loadClass(ClassLoader.java:587) ~[?:?]
        at java.lang.ClassLoader.loadClass(ClassLoader.java:520) ~[?:?]
        at java.lang.Class.forName0(Native Method) ~[?:?]
        at java.lang.Class.forName(Class.java:467) ~[?:?]
        at org.bukkit.plugin.java.PluginClassLoader.&lt;init&gt;(PluginClassLoader.java:64) ~[patched_1.13.2.jar:git-Paper-657]
        at org.bukkit.plugin.java.JavaPluginLoader.loadPlugin(JavaPluginLoader.java:134) ~[patched_1.13.2.jar:git-Paper-657]
        at org.bukkit.plugin.SimplePluginManager.loadPlugin(SimplePluginManager.java:334) ~[patched_1.13.2.jar:git-Paper-657]
        at org.bukkit.plugin.SimplePluginManager.loadPlugins(SimplePluginManager.java:255) ~[patched_1.13.2.jar:git-Paper-657]
        at org.bukkit.craftbukkit.v1_13_R2.CraftServer.loadPlugins(CraftServer.java:331) ~[patched_1.13.2.jar:git-Paper-657]
        at net.minecraft.server.v1_13_R2.DedicatedServer.init(DedicatedServer.java:235) ~[patched_1.13.2.jar:git-Paper-657]
        at net.minecraft.server.v1_13_R2.MinecraftServer.run(MinecraftServer.java:787) ~[patched_1.13.2.jar:git-Paper-657]
        at java.lang.Thread.run(Thread.java:833) [?:?]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration-for-server-owners"><a class="header" href="#configuration-for-server-owners">Configuration for server owners</a></h1>
<p>The CommandAPI has a few configuration options to change how it functions. These options can be set in the <code>plugins/CommandAPI/config.yml</code> file, which is generated automatically when the CommandAPI runs for the first time.</p>
<h2 id="default-configyml-file"><a class="header" href="#default-configyml-file">Default <code>config.yml</code> file</a></h2>
<p>The default <code>config.yml</code> is shown below:</p>
<details>
  <summary><b>config.yml</b></summary>
<pre><code class="language-yaml"># Verbose outputs (default: false)
# If &quot;true&quot;, outputs command registration and unregistration logs in the console
verbose-outputs: false

# Silent logs (default: false)
# If &quot;true&quot;, turns off all logging from the CommandAPI, except for errors.
silent-logs: false

# Messages
# Controls messages that the CommandAPI displays to players
messages:

    # Missing executor implementation (default: &quot;This command has no implementations for %s&quot;)
    # The message to display to senders when a command has no executor. Available
    # parameters are:
    #   %s - the executor class (lowercase)
    #   %S - the executor class (normal case)
    missing-executor-implementation: This command has no implementations for %s

# Create dispatcher JSON (default: false)
# If &quot;true&quot;, the CommandAPI creates a command_registration.json file showing the
# mapping of registered commands. This is designed to be used by developers -
# setting this to &quot;false&quot; will improve command registration performance.
create-dispatcher-json: false

# Use latest version (default: false)
# If &quot;true&quot;, the CommandAPI will use the latest available NMS implementation
# when the CommandAPI is used. This avoids all checks to see if the latest NMS
# implementation is actually compatible with the current Minecraft version.
use-latest-nms-version: false

# Be lenient with version checks when loading for new minor Minecraft versions (default: false)
# If &quot;true&quot;, the CommandAPI loads NMS implementations for potentially unsupported Minecraft versions.
# For example, this setting may allow updating from 1.21.1 to 1.21.2 as only the minor version is changing
# but will not allow an update from 1.21.2 to 1.22.
# Keep in mind that implementations may vary and actually updating the CommandAPI might be necessary.
be-lenient-for-minor-versions: false

# Hook into Paper's ServerResourcesReloadedEvent (default: true)
# If &quot;true&quot;, and the CommandAPI detects it is running on a Paper server, it will
# hook into Paper's ServerResourcesReloadedEvent to detect when /minecraft:reload is run.
# This allows the CommandAPI to automatically call its custom datapack-reloading
# function which allows CommandAPI commands to be used in datapacks.
# If you set this to false, CommandAPI commands may not work inside datapacks after
# reloading datapacks.
hook-paper-reload: true

# Skips the initial datapack reload when the server loads (default: false)
# If &quot;true&quot;, the CommandAPI will not reload datapacks when the server has finished
# loading. Datapacks will still be reloaded if performed manually when &quot;hook-paper-reload&quot;
# is set to &quot;true&quot; and /minecraft:reload is run.
skip-initial-datapack-reload: false

# Plugins to convert (default: [])
# Controls the list of plugins to process for command conversion.
plugins-to-convert: []

# Other commands to convert (default: [])
# A list of other commands to convert. This should be used for commands which
# are not declared in a plugin.yml file.
other-commands-to-convert: []

# Skip sender proxy (default: [])
# Determines whether the proxy sender should be skipped when converting a
# command. If you are having issues with plugin command conversion, add the
# plugin to this list.
skip-sender-proxy: []
</code></pre>
</details>
<h2 id="configuration-settings"><a class="header" href="#configuration-settings">Configuration settings</a></h2>
<hr />
<h3 id="verbose-outputs"><a class="header" href="#verbose-outputs"><code>verbose-outputs</code></a></h3>
<p>If <code>true</code>, outputs command registration and unregistration logs in the console. This is primarily used for developers to identify issues with command registration.</p>
<p><strong>Default value</strong></p>
<pre><code class="language-yml">verbose-outputs: false
</code></pre>
<p><strong>Example value</strong></p>
<pre><code class="language-yml">verbose-outputs: true
</code></pre>
<hr />
<h3 id="silent-logs"><a class="header" href="#silent-logs"><code>silent-logs</code></a></h3>
<p>If <code>true</code>, turns off all logging from the CommandAPI, except for errors.</p>
<p><strong>Default value</strong></p>
<pre><code class="language-yml">silent-logs: false
</code></pre>
<p><strong>Example value</strong></p>
<pre><code class="language-yml">silent-logs: true
</code></pre>
<hr />
<h3 id="messages"><a class="header" href="#messages"><code>messages</code></a></h3>
<p>Controls messages that the CommandAPI displays to players. Available messages:</p>
<ul>
<li><code>missing-executor-implementation</code> - the message to display to senders when a command has no executor. This message supports format parameters:
<ul>
<li><code>%s</code> - the executor class (lowercase). For example &quot;craftplayer&quot;</li>
<li><code>%S</code> - the executor class (normal case). For example &quot;CraftPlayer&quot;</li>
</ul>
</li>
</ul>
<p><strong>Default value</strong></p>
<pre><code class="language-yml">messages:
  missing-executor-implementation: &quot;This command has no implementations for %s&quot;
</code></pre>
<hr />
<h3 id="create-dispatcher-json"><a class="header" href="#create-dispatcher-json"><code>create-dispatcher-json</code></a></h3>
<p>Controls whether the CommandAPI should generate a <code>command_registration.json</code> file showing the mapping of registered commands.</p>
<p>This is primarily designed to be used by developers. Setting this to <code>false</code> will slightly improve command registration performance.</p>
<p>The <code>command_registration.json</code> JSON representation of commands is in the same format as Minecraft's <a href="https://wiki.vg/Data_Generators#Commands_report"><em>Data Generators</em> Commands report</a>. The format is Brigadier's command graph - more information about the JSON format can be found <a href="https://wiki.vg/Command_Data">here</a>.</p>
<p><strong>Default value</strong></p>
<pre><code class="language-yml">create-dispatcher-json: false
</code></pre>
<p><strong>Example value</strong></p>
<pre><code class="language-yml">create-dispatcher-json: true
</code></pre>
<hr />
<h3 id="use-latest-nms-version"><a class="header" href="#use-latest-nms-version"><code>use-latest-nms-version</code></a></h3>
<p>Controls whether the CommandAPI should use the latest NMS implementation for command registration and execution.</p>
<p>This setting can be used to run the CommandAPI on Minecraft versions higher than it can support. For example, if the CommandAPI supports Minecraft 1.18 and Minecraft 1.18.1 comes out, you can use this to enable support for 1.18.1 before an official CommandAPI release comes out that supports 1.18.1.</p>
<div class="warning">
<p>This feature is very experimental and should only be used if you know what you are doing. In almost every case, it is better to wait for an official CommandAPI release that supports the latest version of Minecraft. Using <code>use-latest-nms-version</code> is <em>not</em> guaranteed to work and can cause unexpected side-effects!</p>
</div>
<p><strong>Default value</strong></p>
<pre><code class="language-yml">use-latest-nms-version: false
</code></pre>
<p><strong>Example value</strong></p>
<pre><code class="language-yml">use-latest-nms-version: true
</code></pre>
<hr />
<h3 id="be-lenient-for-minor-versions"><a class="header" href="#be-lenient-for-minor-versions"><code>be-lenient-for-minor-versions</code></a></h3>
<p>Controls whether the CommandAPI should be more lenient when updating to a new Minecraft version.</p>
<p>Similar to the <a href="config.html#use-latest-nms-version"><code>use-latest-nms-version</code></a> setting, this can allow the CommandAPI to run on a version higher than it officially supports. As an example, this setting can allow updating to 1.21.2 from 1.21.1 but doesn't allow updating to 1.22 from 1.21.2.</p>
<div class="warning">
<p>Take the warning from the <a href="config.html#use-latest-nms-version"><code>use-latest-nms-version</code></a> and apply it here too. This is <em>not</em> guaranteed to work either and also may cause unexpected side-effects.</p>
</div>
<p><strong>Default value</strong></p>
<pre><code class="language-yml">be-lenient-for-minor-versions: false
</code></pre>
<p><strong>Example value</strong></p>
<pre><code class="language-yml">be-lenient-for-minor-versions: true
</code></pre>
<hr />
<h3 id="hook-paper-reload"><a class="header" href="#hook-paper-reload"><code>hook-paper-reload</code></a></h3>
<p>Controls whether the CommandAPI hooks into the Paper-exclusive <code>ServerResourcesReloadedEvent</code> when available.</p>
<p>When the CommandAPI detects it is running on a Paper-based server, its default behavior will be to hook into the <code>ServerResourcesReloadedEvent</code>, which triggers when <code>/minecraft:reload</code> is run. During this event, the CommandAPI runs a custom datapack reloading sequence that helps commands registered with the CommandAPI work within datapacks. See <a href="./internal.html#reloading-datapacks">Reloading datapacks</a> for more information on this process.</p>
<p>By default, this value is set to <code>true</code> and the CommandAPI will hook into the <code>ServerResourcesReloadedEvent</code>. If you want, you can set this to <code>false</code>, and the CommandAPI will not hook into this event.</p>
<p><strong>Default value</strong></p>
<pre><code class="language-yml">hook-paper-reload: true
</code></pre>
<p><strong>Example value</strong></p>
<pre><code class="language-yml">hook-paper-reload: false
</code></pre>
<hr />
<h3 id="skip-initial-datapack-reload"><a class="header" href="#skip-initial-datapack-reload"><code>skip-initial-datapack-reload</code></a></h3>
<p>Controls whether the CommandAPI should perform its initial datapack reload when the server has finished loading.</p>
<p>The CommandAPI automatically reloads all datapacks in a similar fashion to <code>/minecraft:reload</code> in order to propagate CommandAPI commands into datapack functions and tags. This operation may cause a slight delay to server startup and is not necessary if you are not using datapacks or functions that use CommandAPI commands. This operation can be skipped by setting this value to <code>true</code>.</p>
<p>Note that datapacks will still be reloaded if performed manually when <code>hook-paper-reload</code> is set to <code>true</code> and you run <code>/minecraft:reload</code>.</p>
<p><strong>Default value</strong></p>
<pre><code class="language-yml">skip-initial-datapack-reload: false
</code></pre>
<p><strong>Example value</strong></p>
<pre><code class="language-yml">skip-initial-datapack-reload: true
</code></pre>
<hr />
<h3 id="plugins-to-convert"><a class="header" href="#plugins-to-convert"><code>plugins-to-convert</code></a></h3>
<p>Controls the list of plugins to process for command conversion. See <a href="./conversionforowners.html">Command conversion</a> for more information.</p>
<p><strong>Default value</strong></p>
<pre><code class="language-yml">plugins-to-convert: []
</code></pre>
<p><strong>Example values</strong></p>
<pre><code class="language-yml">plugins-to-convert:
  - Essentials: ~
</code></pre>
<pre><code class="language-yml">plugins-to-convert:
  - Essentials:
    - speed
    - hat
  - MyPlugin:
    - mycommand
  - MyOtherPlugin: ~
</code></pre>
<pre><code class="language-yml">plugins-to-convert:
  - Essentials:
    - speed &lt;speed&gt;[0..10]
    - speed &lt;target&gt;[minecraft:game_profile]
    - speed (walk|fly) &lt;speed&gt;[0..10]
    - speed (walk|fly) &lt;speed&gt;[0..10] &lt;target&gt;[minecraft:game_profile]
</code></pre>
<hr />
<h3 id="skip-sender-proxy"><a class="header" href="#skip-sender-proxy"><code>skip-sender-proxy</code></a></h3>
<p>Determines whether the proxy sender should be skipped when converting a command. See <a href="./skippingproxysenders.html">Skipping proxy senders</a> for more information.</p>
<p><strong>Default value</strong></p>
<pre><code class="language-yml">skip-sender-proxy: []
</code></pre>
<p><strong>Example value</strong></p>
<pre><code class="language-yml">skip-sender-proxy:
  - SkinsRestorer
  - MyPlugin
</code></pre>
<hr />
<h3 id="other-commands-to-convert"><a class="header" href="#other-commands-to-convert"><code>other-commands-to-convert</code></a></h3>
<p>A list of other commands to convert. This should be used for commands which are not declared in a <code>plugin.yml</code> file. See <a href="./conversionforownerssingle.html#arbitrary-command-conversion">Arbitrary command conversion</a> for more information.</p>
<p><strong>Default value</strong></p>
<pre><code class="language-yml">other-commands-to-convert: []
</code></pre>
<p><strong>Example value</strong></p>
<pre><code class="language-yml">other-commands-to-convert:
  - /set
  - mycommand
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-conversion-for-server-owners"><a class="header" href="#command-conversion-for-server-owners">Command Conversion (for server owners)</a></h1>
<p>The CommandAPI has the ability to convert plugin commands into &quot;Vanilla compatible&quot; commands automatically on startup. This allows you to use <code>/execute</code> and Minecraft functions/tags for plugins that do not use the CommandAPI. For example, if you want to use the <code>/hat</code> command from the plugin <code>Essentials</code> in an <code>/execute</code> command or from a command block, you can use the CommandAPI's command conversion setting to do so.</p>
<p>The CommandAPI has 3 different conversion methods, each one more specific and powerful than the others. These are the following:</p>
<ul>
<li>
<p><a href="conversionforowners.html#converting-all-plugin-commands"><strong>Entire plugin conversion</strong></a></p>
<p>Converts all commands from a plugin into Vanilla compatible commands</p>
</li>
<li>
<p><a href="./conversionforownerssingle.html"><strong>Single command conversion</strong></a></p>
<p>Converts a single command into a Vanilla compatible command</p>
</li>
<li>
<p><a href="./conversionforownerssingleargs.html"><strong>Single command conversion with custom arguments</strong></a></p>
<p>Converts a single command from a plugin into a Vanilla compatible command, whilst also declaring what the arguments to the command are</p>
</li>
</ul>
<hr />
<h2 id="extract-plugin-info"><a class="header" href="#extract-plugin-info">Extract plugin info</a></h2>
<p>Drag a plugin here to view a list of available commands which can be registered for the CommandAPI.</p>
<style>
    .drop_zone_parent {
        padding: 20px;
    }

    .drop_zone {
        border: 2px solid;
        border-radius: 20px;
        padding: 20px;
        border-style: dashed;
        height: 50px;
        display: flex;
        justify-content: center;
        align-items: center;
    }

    #drop_zone_output {
        margin-top: 20px;
    }

    .drop_zone_text {
        margin-left: 20px;
    }
</style>
<div class="drop_zone_parent">
    <div class="drop_zone" ondrop="pluginDropHandler(event);" ondragover="pluginDragHandler(event);">
    <!-- From https://tablericons.com/. Governed by the MIT license. -->
    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-upload" width="32" height="32" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M4 17v2a2 2 0 0 0 2 2h12a2 2 0 0 0 2 -2v-2" />
  <polyline points="7 9 12 4 17 9" />
  <line x1="12" y1="4" x2="12" y2="16" />
</svg><span ><h3 class="drop_zone_text" id="plugin_upload_text" >Drag and drop a plugin .jar file here</h3></span>
    </div>
</div>
<div id="plugin_upload_output"></div>
<hr />
<h2 id="yaml-configuration-rules"><a class="header" href="#yaml-configuration-rules">YAML configuration rules</a></h2>
<p>To configure command conversion, the CommandAPI reads this information from the <code>config.yml</code> file. This file has a bit of a weird structure, so to put it simply, these are the following rules:</p>
<ul>
<li><strong><code>config.yml</code> cannot have tab characters</strong> - The <code>config.yml</code> file <em>must</em> only consist of spaces!</li>
<li>Indentation is important and should be <em>two spaces</em></li>
</ul>
<p>If you're uncertain if your configuration is valid (or you're getting weird errors in the console), you can check if your configuration is valid by dropping your <code>config.yml</code> file below:</p>
<div class="drop_zone_parent">
    <div class="drop_zone" ondrop="configDropHandler(event);" ondragover="configDragHandler(event);">
    <!-- From https://tablericons.com/. Governed by the MIT license. -->
    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-upload" width="32" height="32" viewBox="0 0 24 24" stroke-width="1.5" stroke="#000000" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M4 17v2a2 2 0 0 0 2 2h12a2 2 0 0 0 2 -2v-2" />
  <polyline points="7 9 12 4 17 9" />
  <line x1="12" y1="4" x2="12" y2="16" />
</svg><span ><h3 class="drop_zone_text" id="config_upload_text" >Drag and drop your config.yml here</h3></span>
    </div>
</div>
<div id="config_upload_output"></div>
<hr />
<h3 id="converting-all-plugin-commands"><a class="header" href="#converting-all-plugin-commands">Converting all plugin commands</a></h3>
<p>To convert all of the commands that a plugin has, add the name of the plugin, followed by a <code>~</code> character to the list of plugins to convert in the <code>config.yml</code> file.</p>
<div class="example">
<h3 id="example---converting-all-commands-from-essentialsx"><a class="header" href="#example---converting-all-commands-from-essentialsx">Example - Converting all commands from EssentialsX</a></h3>
<p>For example, if you wanted to convert all commands that <a href="https://www.spigotmc.org/resources/essentialsx.9089/">EssentialsX</a> has, you can use the following <code>config.yml</code>:</p>
<pre><code class="language-yaml">verbose-outputs: true
create-dispatcher-json: false
plugins-to-convert: 
  - Essentials: ~
</code></pre>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="single-command-conversion"><a class="header" href="#single-command-conversion">Single command conversion</a></h1>
<p>Often, you don't want to convert <em>every single command</em> that a plugin declares, and instead you only want to convert a few commands that a plugin has.</p>
<p>The CommandAPI has two ways of doing this:</p>
<ul>
<li>Plugin command conversion: This converts a command which is declared in a plugin's <code>plugin.yml</code> file</li>
<li>Arbitrary command conversion: This converts a command which is not declared in a plugin's <code>plugin.yml</code> file</li>
</ul>
<hr />
<h2 id="plugin-command-conversion"><a class="header" href="#plugin-command-conversion">Plugin command conversion</a></h2>
<p>To convert a single command, you need to first populate the <code>config.yml</code> with the name of the plugin and commands to be converted. To illustrate this, we'll use an example:</p>
<div class="example">
<h3 id="example---converting-plugin-commands"><a class="header" href="#example---converting-plugin-commands">Example - Converting plugin commands</a></h3>
<p>Say we're using <a href="https://www.spigotmc.org/resources/essentialsx.9089/">EssentialsX</a> on our server and we want to be able to use <code>/afk</code> and <code>/hat</code> in command blocks. This would allow us to use (for example) the following commands in command blocks:</p>
<pre><code class="language-mccmd">/execute as @p run afk
/execute as @p run hat
</code></pre>
<p>To do this, we need to add <code>Essentials</code> to our <code>config.yml</code> file, and include the commands <code>afk</code> and <code>hat</code> as the commands to be converted from the Essentials plugin. This would then make our <code>config.yml</code> file look like this:</p>
<pre><code class="language-yaml">verbose-outputs: true
create-dispatcher-json: false
plugins-to-convert: 
  - Essentials: 
    - hat
    - afk
</code></pre>
<blockquote>
<p><strong>Developer's Note:</strong></p>
<p>Note that the commands <code>hat</code> and <code>afk</code> are used, as opposed to an alias such as <code>head</code>. The CommandAPI is only able to convert plugin commands that are declared in a plugin's <code>plugin.yml</code> file. For example, if we take a look at the EssentialsX <code>plugin.yml</code> file, we can see the commands <code>afk</code> and <code>hat</code> have been declared and thus, are the commands which must be used in the CommandAPI's <code>config.yml</code> file:</p>
<pre><code class="language-yaml">name: Essentials
main: com.earth2me.essentials.Essentials
version: 2.18.0.0
website: http://tiny.cc/EssentialsCommands
description: Provides an essential, core set of commands for Bukkit.
softdepend: [Vault, LuckPerms]
authors: [Zenexer, ementalo, Aelux, Brettflan, KimKandor, snowleo, ceulemans, Xeology, KHobbits, md_5, Iaccidentally, drtshock, vemacs, SupaHam, md678685]
api-version: &quot;1.13&quot;
commands:
  afk:
    description: Marks you as away-from-keyboard.
    usage: /&lt;command&gt; [player/message...]
    aliases: [eafk,away,eaway]

# (other config options omitted)

  hat:
    description: Get some cool new headgear.
    usage: /&lt;command&gt; [remove]
    aliases: [ehat,head,ehead]

# (other config options omitted)
</code></pre>
</blockquote>
</div>
<hr />
<h2 id="arbitrary-command-conversion"><a class="header" href="#arbitrary-command-conversion">Arbitrary command conversion</a></h2>
<p>Some commands which are registered by plugins are not present in the plugin's <code>plugin.yml</code> file. Due to this, the CommandAPI cannot link a command to its respective plugin for command conversion. In order to deal with this, the CommandAPI can link arbitrary commands via the <code>other-commands-to-convert</code> option in the CommandAPI's <code>config.yml</code> file.</p>
<p>This can be used for any of the following (and more):</p>
<ul>
<li>Commands created using <a href="https://github.com/SkriptLang/Skript">Skript</a></li>
<li>Commands created using <a href="https://dev.bukkit.org/projects/mycommand">MyCommand</a></li>
<li>Commands which are not registered in a <code>plugin.yml</code>, such as <a href="https://dev.bukkit.org/projects/worldedit">WorldEdit</a> commands</li>
</ul>
<p>To add commands to be converted, simply add them under the <code>other-command-to-convert</code> section in the CommandAPI's <code>config.yml</code>.</p>
<div class="example">
<h3 id="example---converting-arbitrary-commands"><a class="header" href="#example---converting-arbitrary-commands">Example - Converting arbitrary commands</a></h3>
<p>In this example, we want to convert the <code>//set</code> command from WorldEdit, as well as a custom command <code>/mycommand</code>. Note that since WorldEdit's <code>//set</code> command has two forward slashes, we ignore the first one (because that is the symbol used to start commands), but must make sure that we include the second one as that is part of WorldEdit's command syntax. This is the following <code>config.yml</code> that you would need:</p>
<pre><code class="language-yml">verbose-outputs: false
create-dispatcher-json: false
plugins-to-convert: []
skip-sender-proxy: []
other-commands-to-convert:
  - /set
  - mycommand
</code></pre>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="single-command-conversion-with-arguments"><a class="header" href="#single-command-conversion-with-arguments">Single command conversion (with arguments)</a></h1>
<p>For even finer control when converting a single command, you can provide the list of arguments that are required to run the command! This lets you use the command UI in converted commands as you see fit. Before we explain how to do this in detail, let's first take a look at an example of this in action.</p>
<div class="example">
<h3 id="example---converting-essentialsxs-speed-command"><a class="header" href="#example---converting-essentialsxs-speed-command">Example - Converting EssentialsX's /speed command</a></h3>
<p>EssentialsX includes a command <code>/speed</code> which lets you change the current speed that a player can move at. The command format is the following:</p>
<pre><code class="language-mccmd">/speed &lt;speed&gt;
/speed &lt;speed&gt; &lt;target&gt;
/speed &lt;walk/fly&gt; &lt;speed&gt;
/speed &lt;walk/fly&gt; &lt;speed&gt; &lt;target&gt;
</code></pre>
<p>Which means you can run any of the following commands:</p>
<pre><code class="language-mccmd">/speed 5
/speed 2 Notch
/speed fly 6
/speed walk 3 Notch
</code></pre>
<p>By looking at this, we can see that:</p>
<ul>
<li><code>&lt;speed&gt;</code> is a number. By using the command, we can determine that the range of values is between 0 and 10 (inclusive).</li>
<li><code>&lt;target&gt;</code> is a player</li>
<li><code>&lt;walk/fly&gt;</code> don't change - these are &quot;fixed&quot; values.</li>
</ul>
<p>We can represent this using the following <code>config.yml</code> file:</p>
<pre><code class="language-yaml">verbose-outputs: false
create-dispatcher-json: false
plugins-to-convert:
  - Essentials:
    - speed &lt;speed&gt;[0..10]
    - speed &lt;target&gt;[minecraft:game_profile]
    - speed (walk|fly) &lt;speed&gt;[0..10]
    - speed (walk|fly) &lt;speed&gt;[0..10] &lt;target&gt;[minecraft:game_profile]
</code></pre>
<p>Using this, we can display options, such as &quot;fly&quot; and &quot;walk&quot;, as well as optional targets (&quot;Skepter&quot;):</p>
<p><img src="./images/speedoptions.png" alt="A command &quot;/execute run speed&quot; with argument suggestions for entity selectors, as well as &quot;fly&quot; and &quot;walk&quot;" /></p>
<p>Additionally, we can apply limits to the numbers that can be provided. For example, here we limit the number to a value between 0 to 10. If a value is outside of that range, and error is shown to the user:</p>
<p><img src="./images/speedlimit.png" alt="A command &quot;/execute run speed walk 15&quot; with an error displaying &quot;Long must not be more than 10, found 15 at position 24: ...peed walk &lt;--[HERE]" /></p>
</div>
<hr />
<h2 id="command-argument-syntax"><a class="header" href="#command-argument-syntax">Command argument syntax</a></h2>
<p>The argument syntax is a little tricky to get the hang of at the beginning, but it should be fairly straight forward. There are two main types of arguments that you can have:</p>
<h3 id="literal-arguments"><a class="header" href="#literal-arguments">Literal arguments</a></h3>
<p>Literal arguments are arguments with &quot;fixed&quot; values, such as <code>walk</code> or <code>fly</code> from our example above. To declare a literal value, place brackets around the value. For example:</p>
<pre><code class="language-mccmd">(walk)
</code></pre>
<p>To have multiple different literals, place a pipe symbol <code>|</code> between each entry within the brackets. For example:</p>
<pre><code class="language-mccmd">(walk|fly)
</code></pre>
<h3 id="named-arguments"><a class="header" href="#named-arguments">Named arguments</a></h3>
<p>Named arguments must have a name, declared in angled brackets <code>&lt;name&gt;</code>, followed by the type of the argument in square brackets <code>[type]</code>. In the example above, we had a named argument <code>&lt;target&gt;</code>, with the argument type as a player: <code>[minecraft:game_profile]</code>.</p>
<p>The name in the argument can be whatever you want, but it is recommended to keep it as a lowercase value consisting only of letters.</p>
<p><strong>The following argument types are highly recommended</strong> and are very likely to be compatible with every plugin command that you may want to convert:</p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>api:entity</code></td><td>An single entity (e.g. <code>@e[limit=1]</code>)</td></tr>
<tr><td><code>api:entities</code></td><td>Many entities (e.g. <code>@e</code>)</td></tr>
<tr><td><code>api:player</code></td><td>A single player (e.g. <code>Notch</code> or <code>@r</code>)</td></tr>
<tr><td><code>api:players</code></td><td>Many players (e.g. <code>@a</code>)</td></tr>
<tr><td><code>api:greedy_string</code></td><td>An unlimited amount of text. This can only be used as the last entry of a list of arguments</td></tr>
<tr><td><code>brigadier:bool</code></td><td>A Boolean value <code>true</code> or <code>false</code></td></tr>
<tr><td><code>brigadier:double</code></td><td>A decimal number</td></tr>
<tr><td><code>brigadier:float</code></td><td>A decimal number</td></tr>
<tr><td><code>brigadier:integer</code></td><td>A whole number</td></tr>
<tr><td><code>brigadier:long</code></td><td>A whole number</td></tr>
<tr><td><code>brigadier:string</code></td><td>A single word</td></tr>
<tr><td><code>minecraft:block_pos</code></td><td>A location of x, y and z coordinates (whole numbers)</td></tr>
</tbody></table>
</div>
<p>In the example above, we used the a &quot;range type&quot; in the form <code>[0..10]</code>. This is a special argument type that will conform to <code>brigader:long</code> or <code>brigader:double</code> and apply a limit to the values that can be entered.</p>
<div class="example">
<h3 id="example---declaringrange-type-arguments"><a class="header" href="#example---declaringrange-type-arguments">Example - Declaring&quot;range type&quot; arguments</a></h3>
<p>To declare the range \(10 \le x \le 50\) (a value must be between 10 and 50 (inclusive)):</p>
<pre><code class="language-mccmd">&lt;name&gt;[10..50]
</code></pre>
<p>To declare the range \(10 \le x\) (a value must be bigger than or equal to 10):</p>
<pre><code class="language-mccmd">&lt;name&gt;[10..]
</code></pre>
<p>To declare the range \(x \le 50\) (a value must be less than or equal to 50):</p>
<pre><code class="language-mccmd">&lt;name&gt;[..50]
</code></pre>
<p>To declare the range \(0 \le x \le 1\), where \(x\) is a decimal value:</p>
<pre><code class="language-mccmd">&lt;name&gt;[0.0..1.0]
</code></pre>
<p>To declare a value \(x\) that can take any range of values and is a decimal number:</p>
<pre><code class="language-mccmd">&lt;name&gt;[brigadier:double]
</code></pre>
</div>
<hr />
<h2 id="list-of-all-supported-argument-types"><a class="header" href="#list-of-all-supported-argument-types">List of all supported argument types</a></h2>
<p>The list of types are based on <a href="https://minecraft.wiki/w/Argument_types">the list of argument types from the Minecraft Wiki</a>, with a few changes. The complete list that the CommandAPI supports is as follows:</p>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>api:advancement</code></td><td>An advancement</td></tr>
<tr><td><code>api:biome</code></td><td>A biome</td></tr>
<tr><td><code>api:entity</code></td><td>An single entity (e.g. <code>@e[limit=1]</code>)</td></tr>
<tr><td><code>api:entities</code></td><td>Many entities (e.g. <code>@e</code>)</td></tr>
<tr><td><code>api:greedy_string</code></td><td>An unlimited amount of text. This can only be used as the last entry of a list of arguments</td></tr>
<tr><td><code>api:loot_table</code></td><td>A loot table</td></tr>
<tr><td><code>api:player</code></td><td>A single player (e.g. <code>Notch</code> or <code>@r</code>)</td></tr>
<tr><td><code>api:players</code></td><td>Many players (e.g. <code>@a</code>)</td></tr>
<tr><td><code>api:recipe</code></td><td>A recipe</td></tr>
<tr><td><code>api:sound</code></td><td>A sound effect</td></tr>
<tr><td><code>api:text</code></td><td>Text encased in quotes: <code>&quot;text with spaces&quot;</code></td></tr>
<tr><td><code>brigadier:bool</code></td><td>A Boolean value <code>true</code> or <code>false</code></td></tr>
<tr><td><code>brigadier:double</code></td><td>A decimal number</td></tr>
<tr><td><code>brigadier:float</code></td><td>A decimal number</td></tr>
<tr><td><code>brigadier:integer</code></td><td>A whole number</td></tr>
<tr><td><code>brigadier:long</code></td><td>A whole number</td></tr>
<tr><td><code>brigadier:string</code></td><td>A single word</td></tr>
<tr><td><code>minecraft:angle</code></td><td>A yaw angle in degrees (from -180.0 to 179.9)</td></tr>
<tr><td><code>minecraft:block_pos</code></td><td>A location of x, y and z coordinates (whole numbers)</td></tr>
<tr><td><code>minecraft:block_predicate</code></td><td>A block predicate</td></tr>
<tr><td><code>minecraft:block_state</code></td><td>A block type (e.g. <code>stone</code>)</td></tr>
<tr><td><code>minecraft:color</code></td><td>A chat color (e.g. <code>red</code>, <code>green</code>)</td></tr>
<tr><td><code>minecraft:column_pos</code></td><td>A location of x and z coordinates (whole numbers)</td></tr>
<tr><td><code>minecraft:component</code></td><td>Raw JSON text</td></tr>
<tr><td><code>minecraft:dimension</code></td><td>A dimension/world, (e.g. <code>minecraft:overworld</code>)</td></tr>
<tr><td><code>minecraft:entity</code></td><td>An entity (e.g. <code>Notch</code>)</td></tr>
<tr><td><code>minecraft:entity_summon</code></td><td>An entity type (e.g. <code>cow</code>, <code>wither</code>)</td></tr>
<tr><td><code>minecraft:float_range</code></td><td>A range of decimal numbers</td></tr>
<tr><td><code>minecraft:function</code></td><td>A datapack function</td></tr>
<tr><td><code>minecraft:game_profile</code></td><td>A player (e.g. <code>Notch</code>)</td></tr>
<tr><td><code>minecraft:int_range</code></td><td>A range of whole numbers</td></tr>
<tr><td><code>minecraft:item_enchantment</code></td><td>An enchantment (e.g. <code>unbreaking</code>)</td></tr>
<tr><td><code>minecraft:item_predicate</code></td><td>An item predicate</td></tr>
<tr><td><code>minecraft:item_stack</code></td><td>An item (e.g. <code>stick</code>)</td></tr>
<tr><td><code>minecraft:message</code></td><td>A plain text message which can have target selectors (e.g. <code>Hello @p</code>). This can only be used as the last entry of a list of arguments</td></tr>
<tr><td><code>minecraft:mob_effect</code></td><td>A potion effect (e.g. <code>speed</code>, <code>jump_boost</code>)</td></tr>
<tr><td><code>minecraft:nbt_compound_tag</code></td><td>Raw compound NBT in SNBT format</td></tr>
<tr><td><code>minecraft:objective</code></td><td>An objective name (e.g. <code>temperature</code>)</td></tr>
<tr><td><code>minecraft:objective_criteria</code></td><td>An objective criteria (e.g. <code>deaths</code>)</td></tr>
<tr><td><code>minecraft:operation</code></td><td>An operation symbol (e.g. <code>+=</code>, <code>*=</code>)</td></tr>
<tr><td><code>minecraft:particle</code></td><td>A particle (e.g. <code>crit</code>, <code>flame</code>)</td></tr>
<tr><td><code>minecraft:rotation</code></td><td>A rotation of yaw and pitch values (e.g. <code>~ ~</code>)</td></tr>
<tr><td><code>minecraft:score_holder</code></td><td>A score holder (e.g. <code>Notch</code>)</td></tr>
<tr><td><code>minecraft:scoreboard_slot</code></td><td>A scoreboard slot (e.g. <code>sidebar</code>)</td></tr>
<tr><td><code>minecraft:swizzle</code></td><td>A collection of axes (e.g. <code>xyz</code>, <code>xz</code>)</td></tr>
<tr><td><code>minecraft:team</code></td><td>A team name (e.g. <code>hunters</code>)</td></tr>
<tr><td><code>minecraft:time</code></td><td>A duration of time (e.g. <code>2d</code>)</td></tr>
<tr><td><code>minecraft:uuid</code></td><td>A UUID (e.g. <code>dd12be42-52a9-4a91-a8a1-11c01849e498</code>)</td></tr>
<tr><td><code>minecraft:vec2</code></td><td>A location of x and z coordinates (decimal numbers)</td></tr>
<tr><td><code>minecraft:vec3</code></td><td>A location of x, y and z coordinates (decimal numbers)</td></tr>
</tbody></table>
</div><!-- api:environment exists, but is deprecated and shouldn't be used anymore! -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="entity-selectors"><a class="header" href="#entity-selectors">Entity selectors</a></h1>
<p><a href="https://minecraft.wiki/w/Target_selectors">Entity selectors</a> (also known as target selectors) allows you to select certain entities or players which fit a certain criteria when writing a command. Typically, these are of the form <code>@p</code>, <code>@r</code>, <code>@a</code>, <code>@e</code> or <code>@s</code>. By default, when converting a command without arguments, the CommandAPI will not handle these entity selectors. In order to get entity selectors to cooperate with plugins, they must be declared in the relevant <code>config.yml</code> section.</p>
<div class="example">
<h3 id="example---converting-essentialsxs-ext-command"><a class="header" href="#example---converting-essentialsxs-ext-command">Example - Converting EssentialsX's /ext command</a></h3>
<p>EssentialsX includes a command <code>/ext</code> which lets you extinguish a player that is currently on fire. The command format is the following:</p>
<pre><code class="language-mccmd">/ext
/ext &lt;player&gt;
</code></pre>
<p>In order to convert this command, we could use the following <code>config.yml</code> file:</p>
<pre><code class="language-yml">verbose-outputs: false
create-dispatcher-json: false
plugins-to-convert:
  - Essentials:
    - ext
</code></pre>
<p>Using the above <code>config.yml</code> file will support the following commands:</p>
<pre><code class="language-mccmd">/ext
/ext Notch
</code></pre>
<p>However, the above <code>config.yml</code> <strong>will not</strong> support the following commands:</p>
<pre><code class="language-mccmd">/ext @a[distance=10]
/ext @p
</code></pre>
<p>In order to handle this, we have to use the conversion with arguments (as described in the <a href="./conversionforownerssingleargs.html">previous section</a>). For this <code>ext</code> command, we want to only use this command on <em>one or more players</em>, therefore we want to use the <code>api:players</code> argument which is compatible with one or more players:</p>
<pre><code class="language-yml">verbose-outputs: false
create-dispatcher-json: false
plugins-to-convert:
  - Essentials:
    - ext &lt;player&gt;[api:players]
    - ext
</code></pre>
</div>
<p>Note that we declare <code>ext &lt;player&gt;[api:players]</code> <em>before</em> we declare <code>ext</code>. This is because more precise commands MUST be declared before lesser precise commands.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="skipping-proxy-senders"><a class="header" href="#skipping-proxy-senders">Skipping proxy senders</a></h1>
<p>When the CommandAPI converts a command, it does some tweaks to the thing running the command (such as the player or console) to improve compatibility with plugins (mostly permissions). This doesn't <em>always</em> work, and can sometimes produce an error which looks like this:</p>
<pre><code class="language-java">[20:44:01 ERROR]: java.lang.IllegalArgumentException: object is not an instance of declaring class
[20:44:01 ERROR]:  at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
[20:44:01 ERROR]:  at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)
[20:44:01 ERROR]:  at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)
[20:44:01 ERROR]:  at java.lang.reflect.Method.invoke(Unknown Source)
[20:44:01 ERROR]:  at dev.jorel.commandapi.Converter.lambda$mergeProxySender$3(Converter.java:151)
[20:44:01 ERROR]:  at com.sun.proxy.$Proxy33.getInventory(Unknown Source)
</code></pre>
<p>To fix this, add the plugin which the command is registered from to the list of plugins under <code>skip-sender-proxy</code>.</p>
<div class="example">
<h3 id="example---improving-compatibility-with-the-skinsrestorer-plugin"><a class="header" href="#example---improving-compatibility-with-the-skinsrestorer-plugin">Example - Improving compatibility with the SkinsRestorer plugin</a></h3>
<p><a href="https://www.spigotmc.org/resources/skinsrestorer.2124/">SkinsRestorer</a> (not associated or sponsored by the CommandAPI in any way) is a plugin that lets you change the skin for a player. This suffers from the above issue and is not compatible with the CommandAPI's conversion compatibility tweaks. To do this, we'll add <code>SkinsRestorer</code> to the list of plugins which should be skipped:</p>
<pre><code class="language-yaml">verbose-outputs: true
create-dispatcher-json: false
plugins-to-convert: 
  - SkinsRestorer: ~
skip-sender-proxy:
  - SkinsRestorer
</code></pre>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-your-development-environment"><a class="header" href="#setting-up-your-development-environment">Setting up your development environment</a></h1>
<p>To use the CommandAPI in your plugins, there are a few methods of adding it to your development environment. First things first, if you're using the CommandAPI plugin, you need to add the CommandAPI as a dependent in your <code>plugin.yml</code> or <code>paper-plugin.yml</code>:</p>
<div class="multi-pre">
<pre><code class="language-yaml  plugin.yml_(Bukkit/Spigot/Paper)">name: MyPlugin
main: some.package.name.Main
version: 1.0
depend: [CommandAPI]
</code></pre>
<pre><code class="language-yaml  paper-plugin.yml_(Paper)">name: MyPlugin
main: some.package.name.Main
version: 1.0
dependencies:
  server:
    CommandAPI:
      load: BEFORE
      required: true
      join-classpath: true
</code></pre>
</div>
<hr />
<h2 id="using-maven-recommended"><a class="header" href="#using-maven-recommended">Using Maven (recommended)</a></h2>
<blockquote>
<p><strong>Developer's Note:</strong></p>
<p>If you've never used maven before, I highly recommend it! It makes it easier to keep your code updated with the latest dependency updates. For information on how to set up a plugin using maven, you can read <a href="https://bukkit.gamepedia.com/Plugin_Tutorial">Bukkit's plugin tutorial</a>.</p>
</blockquote>
<ul>
<li>
<p>Add the dependency to your <code>pom.xml</code>:</p>
<pre><code class="language-xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;dev.jorel&lt;/groupId&gt;
        &lt;artifactId&gt;commandapi-bukkit-core&lt;/artifactId&gt;
        &lt;version&gt;9.6.0&lt;/version&gt;
        &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
</li>
</ul>
<h2 id="using-gradle-recommended"><a class="header" href="#using-gradle-recommended">Using Gradle (recommended)</a></h2>
<ul>
<li>
<p>Add the repositories to your <code>build.gradle</code> file (the second repository is required because the CommandAPI depends on the NBT-API):</p>
<pre><code class="language-gradle">repositories {
    mavenCentral()
    maven { url = &quot;https://repo.codemc.org/repository/maven-public/&quot; }
}
</code></pre>
</li>
<li>
<p>Add the dependency to your list of dependencies in your <code>build.gradle</code> file:</p>
<pre><code class="language-gradle">dependencies {
    compileOnly &quot;dev.jorel:commandapi-bukkit-core:9.6.0&quot;
}
</code></pre>
</li>
</ul>
<h2 id="manually-using-the-jar"><a class="header" href="#manually-using-the-jar">Manually using the .jar</a></h2>
<ul>
<li>
<p>Download the latest CommandAPI.jar from the download page <a href="https://github.com/JorelAli/CommandAPI/releases/latest">here</a></p>
</li>
<li>
<p>Add the CommandAPI.jar file to your project/environment's build path:</p>
<ul>
<li>
<p>Adding the external .jar file in Eclipse:</p>
<p><img src="images/eclipse.jpg" alt="An image of some context menu entries in Eclipse after right clicking a project. Displays the highlighted options &quot;Build Path&quot;, followed by &quot;Add External Archives...&quot;" /></p>
</li>
<li>
<p>Adding the external .jar file in IntelliJ:</p>
<ul>
<li>
<p>In your project, first click <code>File</code> -&gt; <code>Project Structure</code> -&gt; <code>Libraries</code></p>
</li>
<li>
<p>Next, click the little <code>+</code> at the top:</p>
<p><img src="images/intellij.png" alt="An image in IntelliJ showing the plus icon to add an external .jar." /></p>
</li>
<li>
<p>After you clicked that, you need to select <code>Java</code>. A little pop-up will appear where you can choose the location of your external .jar file.</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shading-the-commandapi-in-your-plugins"><a class="header" href="#shading-the-commandapi-in-your-plugins">Shading the CommandAPI in your plugins</a></h1>
<p>&quot;Shading&quot; is the process of including the CommandAPI inside your plugin, rather than requiring the CommandAPI as an external plugin. In other words, if you shade the CommandAPI into your plugin, you don't need to include the <code>CommandAPI.jar</code> in your server's plugins folder.</p>
<hr />
<h2 id="shading-vs-commandapi-plugin"><a class="header" href="#shading-vs-commandapi-plugin">Shading vs CommandAPI plugin</a></h2>
<p>The CommandAPI plugin has a few slight differences with the shaded CommandAPI jar file. The CommandAPI plugin has the following extra features that are not present in the shaded version:</p>
<ul>
<li>Command conversion via a <code>config.yml</code> file</li>
</ul>
<hr />
<h2 id="shading-requirements"><a class="header" href="#shading-requirements">Shading requirements</a></h2>
<p>For the CommandAPI to function as normal, you <strong>must</strong> call the CommandAPI's initializers in the <code>onLoad()</code> and <code>onEnable()</code> methods of your plugin:</p>
<pre><code class="language-java">CommandAPI.onLoad(CommandAPIConfig config);
CommandAPI.onEnable();
</code></pre>
<p>If you want to handle reloading, the CommandAPI has minimal support for it with the <code>onDisable()</code> method, which can go in your plugin. This is optional and is not required if you don't plan on reloading the server.</p>
<h3 id="loading"><a class="header" href="#loading">Loading</a></h3>
<p>The <code>onLoad(CommandAPIConfig)</code> method initializes the CommandAPI's loading sequence. This must be called <em>before</em> you start to access the CommandAPI and must be placed in your plugin's <code>onLoad()</code> method. The argument <code>CommandAPIConfig</code> is used to configure how the CommandAPI works. The <code>CommandAPIConfig</code> class has the following parameters which let you set how the CommandAPI works similar to the <code>config.yml</code>, which is described <a href="./config.html">here</a>.</p>
<pre><code class="language-java">public class CommandAPIConfig {
    CommandAPIConfig verboseOutput(boolean value); // Enables verbose logging
    CommandAPIConfig silentLogs(boolean value);    // Disables ALL logging (except errors)
    CommandAPIConfig useLatestNMSVersion(boolean value); // Whether the latest NMS implementation should be used or not
    CommandAPIConfig beLenientForMinorVersions(boolean value); // Whether the CommandAPI should be more lenient with minor Minecraft versions
    CommandAPIConfig missingExecutorImplementationMessage(String value); // Set message to display when executor implementation is missing
    CommandAPIConfig dispatcherFile(File file); // If not null, the CommandAPI will create a JSON file with Brigadier's command tree
    CommandAPIConfig setNamespace(String namespace); // The namespace to use when the CommandAPI registers a command
    CommandAPIConfig usePluginNamespace(); // Whether the CommandAPI should use the name of the plugin passed into the CommandAPIConfig implementation as the default namespace for commands

    &lt;T&gt; CommandAPIConfig initializeNBTAPI(Class&lt;T&gt; nbtContainerClass, Function&lt;Object, T&gt; nbtContainerConstructor); // Initializes hooks with an NBT API. See NBT arguments documentation page for more info
}
</code></pre>
<p>The <code>CommandAPIConfig</code> class follows a typical builder pattern (without you having to run <code>.build()</code> at the end), which lets you easily construct configuration instances.</p>
<p>However, the <code>CommandAPIConfig</code> class is abstract and cannot be used to configure the CommandAPI directly. Instead, you must use a subclass of <code>CommandAPIConfig</code> that corresponds to the platform you are developing for. For example, when developing for Bukkit, you should use the <code>CommandAPIBukkitConfig</code> class.</p>
<!-- TODO: Add tabs and explanations for other platforms -->
<pre><code class="language-java">public class CommandAPIBukkitConfig extends CommandAPIConfig {
    CommandAPIBukkitConfig(JavaPlugin plugin);

    CommandAPIBukkitConfig shouldHookPaperReload(boolean hooked); // Whether the CommandAPI should hook into the Paper-exclusive ServerResourcesReloadedEvent
    CommandAPIBukkitConfig skipReloadDatapacks(boolean skip) // Whether the CommandAPI should reload datapacks on server load
}
</code></pre>
<p>In order to create a <code>CommandAPIBukkitConfig</code> object, you must give it a reference to your <code>JavaPlugin</code> instance. The CommandAPI always uses this to registers events, so it is required when loading the CommandAPI on Bukkit. There are also Bukkit-specific features, such as the <code>hook-paper-reload</code> configuration option, which may be configured using a <code>CommandAPIBukkitConfig</code> instance.</p>
<p>For example, to load the CommandAPI on Bukkit with all logging disabled, you can use the following:</p>
<div class="multi-pre">
<pre><code class="language-java Java">CommandAPI.onLoad(new CommandAPIBukkitConfig(plugin).silentLogs(true));
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPI.onLoad(CommandAPIBukkitConfig(plugin).silentLogs(true))
</code></pre>
</div>
<h3 id="enabling--disabling"><a class="header" href="#enabling--disabling">Enabling &amp; Disabling</a></h3>
<p>The <code>onEnable()</code> method initializes the CommandAPI's enabling sequence. Similar to the <code>onLoad(CommandAPIConfig)</code> method, this must be placed in your plugin's <code>onEnable()</code> method. This isn't as strict as the <code>onLoad(CommandAPIConfig)</code> method, and can be placed anywhere in your <code>onEnable()</code> method.</p>
<p>The <code>onDisable()</code> method disables the CommandAPI gracefully. This should be placed in your plugin's <code>onDisable()</code> method. This doesn't unregister commands, so commands may persist during reloads - this can be mitigated using the <code>CommandAPI.unregister()</code> method.</p>
<div class="example">
<h3 id="example---setting-up-the-commandapi-in-your-plugin"><a class="header" href="#example---setting-up-the-commandapi-in-your-plugin">Example - Setting up the CommandAPI in your plugin</a></h3>
<div class="multi-pre">
<pre><code class="language-java Java">public class MyPlugin extends JavaPlugin {

    @Override
    public void onLoad() {
        CommandAPI.onLoad(new CommandAPIBukkitConfig(this).verboseOutput(true)); // Load with verbose output
        
        new CommandAPICommand(&quot;ping&quot;)
            .executes((sender, args) -&gt; {
                sender.sendMessage(&quot;pong!&quot;);
            })
            .register();
    }
    
    @Override
    public void onEnable() {
        CommandAPI.onEnable();
        
        // Register commands, listeners etc.
    }
    
    @Override
    public void onDisable() {
        CommandAPI.onDisable();
    }

}
</code></pre>
<pre><code class="language-kotlin Kotlin">class MyPlugin : JavaPlugin() {

    override fun onLoad() {
        CommandAPI.onLoad(CommandAPIBukkitConfig(this).verboseOutput(true)) // Load with verbose output

        CommandAPICommand(&quot;ping&quot;)
            .executes(CommandExecutor { sender, _ -&gt;
                sender.sendMessage(&quot;pong!&quot;)
            })
            .register()
    }

    override fun onEnable() {
        CommandAPI.onEnable()

        // Register commands, listeners etc.
    }

    override fun onDisable() {
        CommandAPI.onDisable()
    }

}
</code></pre>
</div>
</div>
<hr />
<h2 id="a-note-about-relocating"><a class="header" href="#a-note-about-relocating">A note about relocating</a></h2>
<p>By default, the CommandAPI is written in the <code>dev.jorel.commandapi</code> package. It is <strong>highly recommended</strong> to &quot;relocate&quot; the shaded copy of the CommandAPI to your own package instead to prevent package clashes with other projects that shade the CommandAPI:</p>
<p>\begin{align}
&amp;\qquad\texttt{dev.jorel.commandapi} \rightarrow \texttt{my.custom.package.commandapi} \\
\end{align}</p>
<hr />
<h2 id="shading-with-maven"><a class="header" href="#shading-with-maven">Shading with Maven</a></h2>
<p>To shade the CommandAPI into a maven project, you'll need to use the <code>commandapi-bukkit-shade</code> dependency, which is optimized for shading and doesn't include plugin-specific files <em>(such as <code>plugin.yml</code>)</em>. Here you have a choice between the Spigot-mapped version and the Mojang-mapped version. <strong>You do not need to use <code>commandapi-bukkit-core</code> if you are shading</strong>:</p>
<p>Add the CommandAPI shade dependency:</p>
<div class="multi-pre">
<pre><code class="language-xml Spigot_Mappings">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;dev.jorel&lt;/groupId&gt;
        &lt;artifactId&gt;commandapi-bukkit-shade&lt;/artifactId&gt;
        &lt;version&gt;9.6.0&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<pre><code class="language-xml Mojang_Mappings">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;dev.jorel&lt;/groupId&gt;
        &lt;artifactId&gt;commandapi-bukkit-shade-mojang-mapped&lt;/artifactId&gt;
        &lt;version&gt;9.6.0&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
</div>
<p>You can shade the CommandAPI easily by adding the <code>maven-shade-plugin</code> to your build sequence:</p>
<pre><code class="language-xml">&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt;
            &lt;version&gt;3.6.0&lt;/version&gt;
            &lt;executions&gt;
                &lt;execution&gt;
                    &lt;id&gt;shade&lt;/id&gt;
                    &lt;phase&gt;package&lt;/phase&gt;
                    &lt;goals&gt;
                        &lt;goal&gt;shade&lt;/goal&gt;
                    &lt;/goals&gt;
                &lt;/execution&gt;
            &lt;/executions&gt;
            &lt;configuration&gt;
                &lt;minimizeJar&gt;true&lt;/minimizeJar&gt;
                &lt;relocations&gt;
                    &lt;relocation&gt;
                        &lt;pattern&gt;dev.jorel.commandapi&lt;/pattern&gt;
                        &lt;!-- TODO: Change this to my own package name --&gt;
                        &lt;shadedPattern&gt;my.custom.package.commandapi&lt;/shadedPattern&gt;
                    &lt;/relocation&gt;
                &lt;/relocations&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
<p>As we're shading the CommandAPI into your plugin, you <strong>don't</strong> need to add <code>depend: [CommandAPI]</code> to your <code>plugin.yml</code> file.</p>
<hr />
<h2 id="shading-with-gradle"><a class="header" href="#shading-with-gradle">Shading with Gradle</a></h2>
<p>To shade the CommandAPI into a Gradle project, we'll use the <a href="https://gradleup.com/shadow/">GradleUp Shadow Plugin</a>. Add this to your list of plugins:</p>
<div class="multi-pre">
<pre><code class="language-groovy build.gradle">plugins {
    id 'java'
    id 'com.gradleup.shadow' version '8.3.3'
}
</code></pre>
<pre><code class="language-kotlin build.gradle.kts">plugins {
    java
    id(&quot;com.gradleup.shadow&quot;) version &quot;8.3.3&quot;
}
</code></pre>
</div>
<p>Add our repositories:</p>
<div class="multi-pre">
<pre><code class="language-groovy build.gradle">repositories {
    mavenCentral()

    // If you want to shade the NBT API as well
    maven { url = &quot;https://repo.codemc.org/repository/maven-public/&quot; }
}
</code></pre>
<pre><code class="language-kotlin build.gradle.kts">repositories {
    mavenCentral()

    // If you want to shade the NBT API as well
    maven(url = &quot;https://repo.codemc.org/repository/maven-public/&quot;)
}
</code></pre>
</div>
<p>Next, we declare our dependencies:</p>
<div class="multi-pre">
<pre><code class="language-groovy build.gradle_(Spigot_Mappings)">dependencies {
    implementation &quot;dev.jorel:commandapi-bukkit-shade:9.6.0&quot;
}
</code></pre>
<pre><code class="language-groovy build.gradle_(Mojang_Mappings)">dependencies {
    implementation &quot;dev.jorel:commandapi-bukkit-shade-mojang-mapped:9.6.0&quot;
}
</code></pre>
<pre><code class="language-kotlin build.gradle.kts_(Spigot_Mappings)">dependencies {
    implementation(&quot;dev.jorel:commandapi-bukkit-shade:9.6.0&quot;)
}
</code></pre>
<pre><code class="language-kotlin build.gradle.kts_(Mojang_Mappings)">dependencies {
    implementation(&quot;dev.jorel:commandapi-bukkit-shade-mojang-mapped:9.6.0&quot;)
}
</code></pre>
</div>
<p>Then you just need to relocate the CommandAPI to your desired location in the <code>shadowJar</code> task configuration:</p>
<div class="multi-pre">
<pre><code class="language-groovy build.gradle">shadowJar {
    // TODO: Change this to my own package name
    relocate(&quot;dev.jorel.commandapi&quot;, &quot;my.custom.package.commandapi&quot;)
}
</code></pre>
<pre><code class="language-kotlin build.gradle.kts">tasks.withType&lt;ShadowJar&gt; {
    // TODO: Change this to my own package name
    relocate(&quot;dev.jorel.commandapi&quot;, &quot;my.custom.package.commandapi&quot;)
}
</code></pre>
</div>
<p>Finally, we can build the shaded jar using the following command:</p>
<pre><code class="language-bash">gradlew build shadowJar
</code></pre>
<p>As we're shading the CommandAPI into your plugin, we <strong>don't</strong> need to add <code>depend: [CommandAPI]</code> to your <code>plugin.yml</code> file.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-the-annotation-system"><a class="header" href="#using-the-annotation-system">Using the annotation system</a></h1>
<p>The annotation system is a separate part of the CommandAPI, and as a result it needs to be included as an additional dependency to your project.</p>
<p>The annotation system effectively needs to be added twice: Once for compilation and again to invoke the annotation processor itself.</p>
<hr />
<h2 id="using-maven"><a class="header" href="#using-maven">Using Maven</a></h2>
<ul>
<li>
<p>Add the annotation dependency to your <code>pom.xml</code>:</p>
<pre><code class="language-xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;dev.jorel&lt;/groupId&gt;
        &lt;artifactId&gt;commandapi-annotations&lt;/artifactId&gt;
        &lt;version&gt;9.6.0&lt;/version&gt;
        &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
</li>
<li>
<p>Add the annotation processor as an annotation process to the compile task in the <code>pom.xml</code>:</p>
<pre><code class="language-xml">&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;
            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
            &lt;version&gt;3.8.1&lt;/version&gt;
            &lt;configuration&gt;
                &lt;annotationProcessorPaths&gt;
                    &lt;path&gt;
                        &lt;groupId&gt;dev.jorel&lt;/groupId&gt;
                        &lt;artifactId&gt;commandapi-annotations&lt;/artifactId&gt;
                        &lt;version&gt;9.6.0&lt;/version&gt;
                    &lt;/path&gt;
                &lt;/annotationProcessorPaths&gt;
            &lt;/configuration&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
</li>
</ul>
<hr />
<h2 id="using-gradle"><a class="header" href="#using-gradle">Using Gradle</a></h2>
<ul>
<li>
<p>If you haven't already done so, add the maven central repository to your <code>build.gradle</code> file:</p>
<div class="multi-pre">
<pre><code class="language-groovy build.gradle">repositories {
    mavenCentral()
    maven { url = &quot;https://repo.codemc.org/repository/maven-public/&quot; }
}
</code></pre>
<pre><code class="language-kotlin build.gradle.kts">repositories {
    mavenCentral()
    maven(url = &quot;https://repo.codemc.org/repository/maven-public/&quot;)
}
</code></pre>
</div>
</li>
<li>
<p>Add the dependency and annotation processor to your list of dependencies in your <code>build.gradle</code> file:</p>
<div class="multi-pre">
<pre><code class="language-groovy build.gradle">dependencies {
    compileOnly &quot;dev.jorel:commandapi-annotations:9.6.0&quot;
    annotationProcessor &quot;dev.jorel:commandapi-annotations:9.6.0&quot;
}
</code></pre>
<pre><code class="language-kotlin build.gradle.kts">dependencies {
    compileOnly(&quot;dev.jorel:commandapi-annotations:9.6.0&quot;)
    annotationProcessor(&quot;dev.jorel:commandapi-annotations:9.6.0&quot;)
}
</code></pre>
</div>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-registration"><a class="header" href="#command-registration">Command registration</a></h1>
<p>To register commands with the CommandAPI, we use the <code>CommandAPICommand</code> class. It follows a simple builder pattern to improve readability.</p>
<p>I think the easiest way to explain it is with an example:</p>
<div class="multi-pre">
<pre><code class="language-java Java">// Create our command
new CommandAPICommand(&quot;broadcastmsg&quot;)
    .withArguments(new GreedyStringArgument(&quot;message&quot;)) // The arguments
    .withAliases(&quot;broadcast&quot;, &quot;broadcastmessage&quot;)       // Command aliases
    .withPermission(CommandPermission.OP)               // Required permissions
    .executes((sender, args) -&gt; {
        String message = (String) args.get(&quot;message&quot;);
        Bukkit.getServer().broadcastMessage(message);
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">// Create our command
CommandAPICommand(&quot;broadcastmsg&quot;)
    .withArguments(GreedyStringArgument(&quot;message&quot;)) // The arguments
    .withAliases(&quot;broadcast&quot;, &quot;broadcastmessage&quot;)   // Command aliases
    .withPermission(CommandPermission.OP)           // Required permissions
    .executes(CommandExecutor { sender, args -&gt;
        val message = args[&quot;message&quot;] as String
        Bukkit.getServer().broadcastMessage(message)
    })
    .register()
</code></pre>
</div>
<ul>
<li>
<p>First, we create a new <code>CommandAPICommand</code>, with the name of the command that the sender must enter to run it.</p>
</li>
<li>
<p>Then, we create an argument to add to the command using <code>withArguments</code>. This is described in more detail in <a href="./arguments.html">the section on arguments</a>.</p>
</li>
<li>
<p>In this example, we add an alias, &quot;broadcast&quot;, to the command. This allows the sender to use either <code>/broadcastmsg &lt;message&gt;</code> or <code>/broadcast &lt;message&gt;</code>.</p>
</li>
<li>
<p>By using <code>withPermission</code>, we require the sender to be an OP in order to run the command.</p>
</li>
<li>
<p>We control what the command does using <code>executes</code> (this is described in more detail in <a href="./commandexecutors.html">the section on command executors</a>).</p>
</li>
<li>
<p>Finally, we register the command to the CommandAPI using <code>register</code>.</p>
</li>
</ul>
<p>That's it! This simple snippet of code fully registers the command to the server. You don't need to supply a plugin instance, you don't have to create a custom class and you don't have to mess with the <code>plugin.yml</code> file.</p>
<p>Throughout this documentation, we will use the various different methods for command registration to give you an idea of when and where certain methods are more suitable than others.</p>
<hr />
<h2 id="commandapicommand-methods"><a class="header" href="#commandapicommand-methods"><code>CommandAPICommand</code> methods</a></h2>
<p>The <code>CommandAPICommand</code> has various methods, which are outlined below:</p>
<h4 id="setting-the-command-name"><a class="header" href="#setting-the-command-name">Setting the command name</a></h4>
<pre><code class="language-java">new CommandAPICommand(String commandName)
</code></pre>
<p>This constructor creates a new instance of the <code>CommandAPICommand</code> object. This constructor requires the <em>name</em> of the command.</p>
<h4 id="setting-command-properties"><a class="header" href="#setting-command-properties">Setting command properties</a></h4>
<pre><code class="language-java">CommandAPICommand withArguments(List&lt;Argument&gt; arguments)
CommandAPICommand withArguments(Argument... arguments)
</code></pre>
<p>The <code>withArguments</code> method is used to add arguments to your command. The <code>arguments</code> parameter is appended to the the list of arguments for the command.</p>
<pre><code class="language-java">CommandAPICommand withPermission(CommandPermission)
CommandAPICommand withPermission(String)
</code></pre>
<p>The <code>withPermission</code> method is used to assign a permission that is required to execute the command. (See <a href="permissions.html">the section on permissions</a> for more info).</p>
<pre><code class="language-java">CommandAPICommand withRequirements(sender -&gt; {})
</code></pre>
<p>The <code>withRequirements</code> method is used to assign additional constraints required to execute the command, similar to permissions. (See <a href="./requirements.html">the section on requirements</a> for more info).</p>
<pre><code class="language-java">CommandAPICommand withAliases(String... args)
</code></pre>
<p>The <code>withAliases</code> method is used to declare a list of aliases that can be used to run this command via. (See <a href="./aliases.html">the section on aliases</a> for more info).</p>
<pre><code class="language-java">CommandAPICommand withHelp(String shortDescription, fullDescription)
CommandAPICommand withHelp(HelpTopic helpTopic)
CommandAPICommand withShortDescription(String shortDescription)
CommandAPICommand withFullDescription(String fullDescription)
</code></pre>
<p>The <code>withHelp</code> method, along with its specific <code>withShortDescription</code> and <code>withFullDescription</code> methods are used to declare the help topic for this command which is displayed in the <code>/help</code> command. (See <a href="./help.html">the section on help</a> for more info).</p>
<pre><code class="language-java">CommandAPICommand withSubcommand(CommandAPICommand subcommand)
</code></pre>
<p>The <code>withSubcommand</code> method is used to declare a subcommand that leads on from the current command. (See <a href="./subcommands.html">the section on subcommands</a> for more info).</p>
<h4 id="setting-the-commands-executor"><a class="header" href="#setting-the-commands-executor">Setting the command's executor</a></h4>
<pre><code class="language-java">CommandAPICommand executes((sender, args) -&gt; {})
CommandAPICommand executes(info -&gt; {})
</code></pre>
<p>Executes a command using the <code>CommandSender</code> object.</p>
<pre><code class="language-java">CommandAPICommand executesPlayer((player, args) -&gt; {})
CommandAPICommand executesPlayer(info -&gt; {})
</code></pre>
<p>Executes a command only if the command sender is a <code>Player</code>.</p>
<pre><code class="language-java">CommandAPICommand executesEntity((entity, args) -&gt; {})
CommandAPICommand executesEntity(info -&gt; {})
</code></pre>
<p>Executes a command only if the command sender is an <code>Entity</code>.</p>
<pre><code class="language-java">CommandAPICommand executesCommandBlock((cmdblock, args) -&gt; {})
CommandAPICommand executesCommandBlock(info -&gt; {})
</code></pre>
<p>Executes a command only if the command sender is a <code>BlockCommandSender</code>.</p>
<pre><code class="language-java">CommandAPICommand executesConsole((console, args) -&gt; {})
CommandAPICommand executesConsole(info -&gt; {})
</code></pre>
<p>Executes a command only if the command sender is a <code>ConsoleCommandSender</code>.</p>
<pre><code class="language-java">CommandAPICommand executesProxy((proxy, args) -&gt; {})
CommandAPICommand executesProxy(info -&gt; {})
</code></pre>
<p>Executes a command only if the command sender is a <code>ProxiedCommandSender</code>.</p>
<pre><code class="language-java">CommandAPICommand executesNative((proxy, args) -&gt; {})
CommandAPICommand executesNative(info -&gt; {})
</code></pre>
<p>Executes a command regardless of what the command sender is, using the <code>NativeProxyCommandSender</code>.  Read more about native proxied command senders <a href="./native.html">here</a>.</p>
<blockquote>
<p><strong>Developer's Note:</strong></p>
<p>Sometimes, the Java compiler throws an error saying that a method is ambiguous for the type CommandAPICommand. This is due to a limitation in Java's type inference system and is not a fault of the CommandAPI. If we take the following code, used to spawn a pig:</p>
<pre><code class="language-java">new CommandAPICommand(&quot;spawnpigs&quot;)
     .executesPlayer((player, args) -&gt; {
           for(int i = 0; i &lt; 10; i++) {
               player.getWorld().spawnEntity(player.getLocation(), (EntityType) args.get(0));
           }
     })
     .register();
</code></pre>
<p>The Java type inference system cannot determine what the type of the lambda <code>(player, args) -&gt; ()</code> is, therefore it produces the following compilation error:</p>
<pre><code class="language-txt">The method executesPlayer(PlayerCommandExecutor) is ambiguous for the type CommandAPICommand
</code></pre>
<p>This can easily be resolved by declaring the specific type of the command sender and the arguments. For example:</p>
<pre><code class="language-java">new CommandAPICommand(&quot;spawnpigs&quot;)
     .executesPlayer((Player player, CommandArguments args) -&gt; {
           for(int i = 0; i &lt; 10; i++) {
               player.getWorld().spawnEntity(player.getLocation(), (EntityType) args.get(0));
           }
     })
     .register();
</code></pre>
</blockquote>
<h4 id="registering-the-command"><a class="header" href="#registering-the-command">Registering the command</a></h4>
<pre><code class="language-java">void register()
</code></pre>
<p>Registers the command with the default <code>minecraft</code> namespace. If you are <a href="./setup_shading.html">shading</a> you can set the default namespace using <code>CommandAPIConfig#setNamespace(String)</code> or <code>CommandAPIBukkitConfig#usePluginNamespace()</code>.</p>
<pre><code class="language-java">void register(String namespace)
</code></pre>
<p>Registers the command with a custom provided namespace.</p>
<pre><code class="language-java">void register(JavaPlugin plugin)
</code></pre>
<p>Registers the command with the provided plugin's name.</p>
<hr />
<h2 id="command-loading-order"><a class="header" href="#command-loading-order">Command loading order</a></h2>
<p>It is recommended to register commands in either the <code>onLoad()</code> or <code>onEnable()</code> method. With the CommandAPI, depending on whether you use <code>onLoad()</code> or <code>onEnable()</code> to load your commands depends on whether your plugin is used with Minecraft's functions:</p>
<div class="table-wrapper"><table><thead><tr><th>When to load</th><th>What to do</th></tr></thead><tbody>
<tr><td><code>onLoad()</code> method</td><td>Register commands to be used in Minecraft functions (<a href="functions.html">see the Function section for more info</a>)</td></tr>
<tr><td><code>onEnable()</code> method</td><td>Register regular commands</td></tr>
</tbody></table>
</div>
<p>The CommandAPI does support registering commands outside of these methods while the server is running. Commands registered after the server is done loading <em>should</em> work the same as commands registered in <code>onEnable</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-unregistration"><a class="header" href="#command-unregistration">Command unregistration</a></h1>
<p>The CommandAPI allows you to remove commands completely from Minecraft's command list. This includes Vanilla commands, Bukkit commands, and plugin commands.</p>
<p>There are three methods you might use when unregistering commands:</p>
<pre><code class="language-java">CommandAPI.unregister(String commandName);
CommandAPI.unregister(String commandName, boolean unregisterNamespaces);
CommandAPIBukkit.unregister(String commandName, boolean unregisterNamespaces, boolean unregisterBukkit);
</code></pre>
<p>To understand when and how to use these methods, you need to know a little about how Bukkit loads and sets up commands. This is basically the order of events when a Bukkit server starts:</p>
<ol>
<li>Vanilla commands are placed in the Vanilla CommandDispatcher</li>
<li>Bukkit commands are placed in the Bukkit CommandMap
<ul>
<li>Given the <code>bukkit</code> namespace (E.g. <code>bukkit:version</code>)</li>
</ul>
</li>
<li>Plugins are loaded
<ul>
<li><code>onLoad</code> is called</li>
</ul>
</li>
<li>Plugins are enabled
<ul>
<li>Plugin commands are read from the <a href="https://www.spigotmc.org/wiki/plugin-yml/#commands"><code>plugin.yml</code> file</a> and placed in the Bukkit CommandMap</li>
<li>Given the plugin's name as their namespace (E.g. <code>luckperms:lp</code>)</li>
<li><code>onEnable</code> is called</li>
<li>Repeat for each plugin</li>
</ul>
</li>
<li>Bukkit's help command is registered</li>
<li>Vanilla commands are added to the Bukkit CommandMap
<ul>
<li>Given the <code>minecraft</code> namespace (E.g. <code>minecraft:gamemode</code>)</li>
</ul>
</li>
<li>The server is done loading</li>
</ol>
<p>Unregistering a command only works if it happens after the command is created. Bukkit's command system is special and has two locations where commands can exist -- either the Vanilla CommandDispatcher or the Bukkit CommandMap -- so you also need to know where your command is registered. With that in mind, here is what each of the <code>unregister</code> methods do:</p>
<pre><code class="language-java">CommandAPI.unregister(String commandName);
</code></pre>
<p>Unregisters a command from the Vanilla CommandDispatcher.</p>
<pre><code class="language-java">CommandAPI.unregister(String commandName, boolean unregisterNamespaces);
</code></pre>
<p>Unregisters a command from the Vanilla CommandDispatcher. If <code>unregisterNamespaces</code> is <code>true</code>, then any namespaced version of the command is also unregistered.</p>
<pre><code class="language-java">CommandAPIBukkit.unregister(String commandName, boolean unregisterNamespaces, boolean unregisterBukkit);
</code></pre>
<p>Unregisters a command from Bukkit. As before, if <code>unregisterNamespaces</code> is <code>true</code>, then any namespaced version of the command is also unregistered. If <code>unregisterBukkit</code> is <code>true</code>, then only Bukkit commands in the Bukkit CommandMap are unregistered. If <code>unregisterBukkit</code> is <code>false</code>, only commands from the Vanilla CommandDispatcher are unregistered.</p>
<p>To give a better idea of how and when to use these methods, the rest of this page documents how to unregister different types of commands.</p>
<h2 id="unregistering-a-bukkit-command---version"><a class="header" href="#unregistering-a-bukkit-command---version">Unregistering a Bukkit command - <code>/version</code></a></h2>
<p><code>/version</code> is a command provided by Bukkit. Looking at the sequence of events above, that means it is created during step 2, before plugins are loaded in step 3. Consequently, the command will exist when our plugin's <code>onLoad</code> method is called, so we'll unregister it there. The same code will work in <code>onEnable</code> too, since step 4 is also after step 2.</p>
<p>Since this command exists in the Bukkit CommandMap, we'll need to use <code>CommandAPIBukkit#unregister</code> with <code>unregisterBukkit</code> set to <code>true</code>. We'll also remove the namespaced version -- <code>/bukkit:version</code> -- so <code>unregisterNamespaces</code> will be <code>true</code>. All together, the code looks like this:</p>
<div class="multi-pre">
<pre><code class="language-java Java">@Override
public void onLoad() {
    CommandAPIBukkit.unregister(&quot;version&quot;, true, true);
}
</code></pre>
<pre><code class="language-kotlin Kotlin">override fun onLoad() {
    CommandAPIBukkit.unregister(&quot;version&quot;, false, true)
}
</code></pre>
</div>
<p>With this plugin, executing <code>/version</code> or <code>/bukkit:version</code> will give the unknown command message. Note that aliases like <code>/ver</code> and its namespaced version <code>/bukkit:ver</code> will still work. To remove aliases as well, you need to unregister each as its own command. For, <code>/ver</code>, that would mean calling <code>CommandAPIBukkit.unregister(&quot;ver&quot;, true, true)</code>.</p>
<h2 id="unregistering-a-vanilla-command---gamemode"><a class="header" href="#unregistering-a-vanilla-command---gamemode">Unregistering a Vanilla command - <code>/gamemode</code></a></h2>
<p><code>/gamemode</code> is a command provided by Vanilla Minecraft. Like the <a href="commandunregistration.html#unregistering-a-bukkit-command---version">previous example</a>, Vanilla commands are created in step 1, before plugins are loaded in step 3. For variety, we'll unregister the command in our plugin's <code>onEnable</code> -- step 4 -- but the same code would also work in <code>onLoad</code>.</p>
<p>Since this command exists in the Vanilla CommandDispatcher, we can use <code>CommandAPI#unregister</code>. That works the same as <code>CommandAPIBukkit#unregister</code> with <code>unregisterBukkit</code> set to <code>false</code>. We don't care about the namespace, so <code>unregisterNamespaces</code> will be <code>false</code>. That means we can use the simplest method, <code>CommandAPI.unregister(String commandName)</code>, since it sets <code>unregisterNamespaces</code> to <code>false</code> by default. All together, the code looks like this:</p>
<div class="multi-pre">
<pre><code class="language-java Java">@Override
public void onEnable() {
    CommandAPI.unregister(&quot;gamemode&quot;);
}
</code></pre>
<pre><code class="language-kotlin Kotlin">override fun onEnable() {
    CommandAPI.unregister(&quot;gamemode&quot;)
}
</code></pre>
</div>
<p>With this code, executing <code>/gamemode</code> will give the unknown command exception as expected. However, even though <code>unregisterNamespaces</code> was <code>false</code>, <code>/minecraft:gamemode</code> can also not be run. This happens because Vanilla commands are given their namespace in step 6, after our plugin has removed <code>/gamemode</code>.</p>
<p>When the server starts, <code>/gamemode</code> is created in step 2 inside the Vanilla CommandDispatcher. In step 4, our plugin is enabled and we remove the <code>/gamemode</code> command from that CommandDispatcher. After all the plugins enable, step 6 moves all commands in the Vanilla CommandDispatcher to the Bukkit CommandMap and gives them the <code>minecraft</code> namespace. Since <code>/gamemode</code> doesn't exist at this point, step 6 cannot create the <code>/minecraft:gamemode</code> command. So, even though <code>unregisterNamespaces</code> was <code>false</code>, <code>/minecraft:gamemode</code> doesn't exist anyway.</p>
<div class="example">
<h3 id="example---replacing-minecrafts-gamemode-command"><a class="header" href="#example---replacing-minecrafts-gamemode-command">Example - Replacing Minecraft's <code>/gamemode</code> command</a></h3>
<p>To replace a command, first unregister the original command, then register a new implementation for that command.</p>
<div class="multi-pre">
<pre><code class="language-java Java">@Override
public void onEnable() {
    CommandAPI.unregister(&quot;gamemode&quot;);

    // Register our new /gamemode, with survival, creative, adventure and spectator
    new CommandAPICommand(&quot;gamemode&quot;)
        .withArguments(new MultiLiteralArgument(&quot;gamemodes&quot;, &quot;survival&quot;, &quot;creative&quot;, &quot;adventure&quot;, &quot;spectator&quot;))
        .executes((sender, args) -&gt; {
            // Implementation of our /gamemode command
        })
        .register();
}
</code></pre>
<pre><code class="language-kotlin Kotlin">override fun onEnable() {
    CommandAPI.unregister(&quot;gamemode&quot;);

    // Register our new /gamemode, with survival, creative, adventure and spectator
    CommandAPICommand(&quot;gamemode&quot;)
        .withArguments(MultiLiteralArgument(&quot;gamemodes&quot;, &quot;survival&quot;, &quot;creative&quot;, &quot;adventure&quot;, &quot;spectator&quot;))
        .executes(CommandExecutor { sender, args -&gt;
            // Implementation of our /gamemode command
        })
        .register()
}
</code></pre>
</div>
<p>Now, when <code>/gamemode</code> is executed, it will use the new implementation defined using the CommandAPI.</p>
</div>
<h2 id="unregistering-a-plugin-command---luckpermsluckperms"><a class="header" href="#unregistering-a-plugin-command---luckpermsluckperms">Unregistering a Plugin command - <code>/luckperms:luckperms</code></a></h2>
<p>The <code>/luckperms</code> command is provided by the Bukkit <a href="https://luckperms.net/">LuckPerms</a> plugin. Plugin commands are created during step 4, immediately before calling the <code>onEnable</code> method of the respective plugin. In this case, unregistering the command in our own plugin's <code>onLoad</code> would not work, since the command wouldn't exist yet. We also have to make sure that our <code>onEnable</code> method is called after LuckPerm's. The best way to make sure that happens is to add LuckPerms as a <code>depend</code> or <code>softdepend</code> in our plugin's plugin.yml. You can read more about the different between <code>depend</code> and <code>softdepend</code> in <a href="https://www.spigotmc.org/wiki/plugin-yml/#optional-attributes">Spigot's documentation</a>, but that will look something like this:</p>
<pre><code class="language-yaml">name: MyPlugin
main: some.package.name.Main
version: 1.0
depend:
  - LuckPerms
</code></pre>
<p>Since plugin commands are stored in the Bukkit CommandMap, we need to use <code>CommandAPIBukkit#unregister</code> with <code>unregisterBukkit</code> set to <code>true</code>. For demonstration’s sake, we only want to unregister the namespaced version -- <code>/luckperms:luckperms</code> -- and leave <code>/luckperms</code> alone. To do this, give <code>&quot;luckperms:luckperms&quot;</code> as the <code>commandName</code>, and set <code>unregisterNamespaces</code> to <code>false</code>. All together, the code looks like this:</p>
<div class="multi-pre">
<pre><code class="language-java Java">@Override
public void onEnable() {
    CommandAPIBukkit.unregister(&quot;luckperms:luckperms&quot;, false, true);
}
</code></pre>
<pre><code class="language-kotlin Kotlin">override fun onEnable() {
    CommandAPIBukkit.unregister(&quot;luckperms:luckperms&quot;, false, true)
}
</code></pre>
</div>
<p>Executing <code>/luckperms</code> will work as normal, but <code>/luckperms:luckperms</code> will give the unknown command message.</p>
<h2 id="unregistering-a-commandapi-command"><a class="header" href="#unregistering-a-commandapi-command">Unregistering a CommandAPI command</a></h2>
<p>Unregistering a command created by the CommandAPI is similar to both unregistering a Vanilla command and a plugin command. Like a Vanilla command, CommandAPI commands are stored in the Vanilla CommandDispatcher, so they should be unregistered with <code>unregisterBukkit</code> set to <code>false</code>. Like plugin commands, they may be created in <code>onEnable</code>, so you need to make sure your plugin is enabled after the plugin that adds the command.</p>
<p>Unlike plugin commands, CommandAPI commands may be created in <code>onLoad</code>, as discussed in <a href="./commandregistration.html#command-loading-order">Command loading order</a>. That just means you may also be able to unregister the command in you own plugin's <code>onLoad</code>. As always, simply make sure you unregister a command after it is created, and it will be removed properly.</p>
<p>For our example, let's say we want to unregister the <code>/break</code> command created by the <a href="https://github.com/JorelAli/CommandAPI/tree/master/examples/bukkit/maven">Bukkit Maven Example Project</a> for the CommandAPI. If you look at that plugin's code, you can see that it registers the <code>/break</code> command in it's <code>onEnable</code> method. Therefore, we can unregister the command in our own plugin's <code>onEnable</code>, making sure that our plugin will enable second by adding ExamplePlugin as a <a href="https://www.spigotmc.org/wiki/plugin-yml/#optional-attributes"><code>depend</code> or <code>softdepend</code></a>.</p>
<pre><code class="language-yaml">name: MyPlugin
main: some.package.name.Main
version: 1.0
depend:
  - CommandAPI
  - ExamplePlugin
</code></pre>
<blockquote>
<p><strong>Developer's Note:</strong></p>
<p>If you can't find the code where a CommandAPI command is registered or just don't have access to the code of a plugin, you can still figure out when a command is registered. If you set <a href="./config.html#verbose-outputs"><code>verbose-outputs</code></a> to <code>true</code> in the CommandAPI's configuration, it will log command registration.</p>
<p>For the ExamplePlugin, setting <code>verbose-outputs</code> to <code>true</code> gives this:</p>
<pre><code class="language-log">[Server thread/INFO]: [ExamplePlugin] Enabling ExamplePlugin v0.0.1
[Server thread/INFO]: [CommandAPI] Registering command /break block&lt;LocationArgument&gt;
[Server thread/INFO]: [CommandAPI] Registering command /myeffect target&lt;PlayerArgument&gt; potion&lt;PotionEffectArgument&gt;
[Server thread/INFO]: [CommandAPI] Registering command /nbt nbt&lt;NBTCompoundArgument&gt;
</code></pre>
<p>You can see that the ExamplePlugin registers its commands when <code>onEnable</code> is called.</p>
</blockquote>
<p>In summary, we will unregister the <code>/break</code> command in our plugin's <code>onEnable</code>. We added Example plugin to the <code>depend</code> list in our plugin.yml so that our <code>onEnable</code> method runs second. <code>unregisterNamespaces</code> and <code>unregisterBukkit</code> will be set to <code>false</code>, and those are the default values, so we can simply use <code>CommandAPI.unregister(String commandName)</code>. All together, the code looks like this:</p>
<div class="multi-pre">
<pre><code class="language-java Java">@Override
public void onEnable() {
    CommandAPI.unregister(&quot;break&quot;);
}
</code></pre>
<pre><code class="language-kotlin Kotlin">override fun onEnable() {
    CommandAPI.unregister(&quot;break&quot;)
}
</code></pre>
</div>
<p>Now, when you try to execute <code>/break</code>, you will just get the unknown command message as if it never existed.</p>
<h2 id="special-case-unregistering-bukkits-help"><a class="header" href="#special-case-unregistering-bukkits-help">Special case: Unregistering Bukkit's <code>/help</code></a></h2>
<p>If you look at the sequence of events at the top of this page, you might notice that Bukkit's <code>/help</code> command gets its own place in step 5. Unlike the other <a href="commandunregistration.html#unregistering-a-bukkit-command---version">Bukkit commands</a>, <code>/help</code> is special and gets registered after plugins are loaded and enabled (don't ask, I don't know why :P). That means unregistering <code>/help</code> in <code>onLoad</code> or <code>onEnable</code> does not work, since the command doesn't exist yet.</p>
<p>In order to run our unregister task after the server is enabled, we can use Bukkit's <a href="https://bukkit.fandom.com/wiki/Scheduler_Programming">Scheduler API</a>. There are many ways to set up and run a task, and this should work in whatever way you like. You can even give the task zero delay, since Bukkit only starts processing tasks after the server is enabled.</p>
<p>Since <code>/help</code> is in the Bukkit CommandMap, we need to use <code>CommandAPIBukkit#unregister</code> with <code>unregisterBukkit</code> set to <code>true</code>. We'll leave <code>/bukkit:help</code> alone, so <code>unregisterNamespaces</code> will be <code>false</code>. All together, we can unregister Bukkit's <code>/help</code> command with this code:</p>
<div class="multi-pre">
<pre><code class="language-java Java">@Override
public void onEnable() {
    new BukkitRunnable() {
        @Override
        public void run() {
            CommandAPIBukkit.unregister(&quot;help&quot;, false, true);
        }
    }.runTaskLater(this, 0);
}
</code></pre>
<pre><code class="language-kotlin Kotlin">override fun onEnable() {
    object : BukkitRunnable() {
        override fun run() {
            CommandAPIBukkit.unregister(&quot;help&quot;, false, true)
        }
    }.runTaskLater(this, 0)
}
</code></pre>
</div>
<p>Funnily, if you try to execute <code>/help</code>, the server will still tell you: <code>Unknown command. Type &quot;/help&quot; for help.</code>. Luckily, <code>unregisterNamespaces</code> was <code>false</code>, so you can still use <code>/bukkit:help</code> to figure out your problem.</p>
<h2 id="special-case-unregistering-only-minecraftgamemode"><a class="header" href="#special-case-unregistering-only-minecraftgamemode">Special case: Unregistering only <code>/minecraft:gamemode</code></a></h2>
<p>In the earlier example for <a href="commandunregistration.html#unregistering-a-vanilla-command---gamemode">Unregistering <code>/gamemode</code></a>, even though <code>unregisterNamespaces</code> was <code>false</code>, the <code>/minecraft:gamemode</code> command was also not executable. As explained up there, this happens because the namespaced version of commands in the Vanilla CommandDispatcher are not created until after plugins are loaded and enabled. Since we unregistered <code>/gamemode</code> in <code>onEnable</code>, when the time came for the server to transfer Vanilla commands into the Bukkit CommandMap, it didn't know to create the <code>minecraft:gamemode</code> command. Consequently, this means we cannot normally remove only the <code>/minecraft:gamemode</code> command without also unregistering <code>/gamemode</code>.</p>
<p>Of course, it is still possible to only unregister <code>/minecraft:gamemode</code> and the namespaced versions of other Vanilla commands. As always, in order to unregister a command, you have to unregister after the command is created. So, we just need to unregister <code>/minecraft:gamemode</code> after the server is enabled. Like the <a href="commandunregistration.html#special-case-unregistering-bukkits-help">previous special case</a>, we can use Bukkit's <a href="https://bukkit.fandom.com/wiki/Scheduler_Programming">Scheduler API</a> to run our unregister task after the server is enabled.</p>
<p>While <code>/minecraft:gamemode</code> only exists in the Bukkit CommandMap, it is the namespaced version of the Vanilla <code>/gamemode</code> command, so it is considered a Vanilla command. That means <code>unregisterBukkit</code> should be <code>false</code>, which is what it defaults to when using <code>CommandAPI#unregister</code>. The CommandAPI understands that once the server is enabled Vanilla commands will have been copied to the CommandMap, so it will be able to find <code>/minecraft:gamemode</code></p>
<p>Finally, <code>unregisterNamespaces</code> should be <code>false</code>, and since that's the default value we don't have to include it. All together, the code looks like this:</p>
<div class="multi-pre">
<pre><code class="language-java Java">@Override
public void onEnable() {
    new BukkitRunnable() {
        @Override
        public void run() {
            CommandAPI.unregister(&quot;minecraft:gamemode&quot;);
        }
    }.runTaskLater(this, 0);
}
</code></pre>
<pre><code class="language-kotlin Kotlin">override fun onEnable() {
    object : BukkitRunnable() {
        override fun run() {
            CommandAPI.unregister(&quot;minecraft:gamemode&quot;)
        }
    }.runTaskLater(this, 0)
}
</code></pre>
</div>
<p>With this code, <code>/gamemode</code> will execute as normal, but <code>/minecraft:gamemode</code> will give the unknown command message.</p>
<div class="warning">
<p><strong>Developer's Note:</strong></p>
<p>Doing the opposite action here -- only unregistering <code>/gamemode</code> but keeping <code>/minecraft:gamemode</code> -- is not recommended. That would be the following code, where <code>commandName</code> is <code>&quot;gamemode&quot;</code> (or any command in the Vanilla CommandDispatcher), and <code>unregisterNamespaces</code> is <code>false</code>:</p>
<div class="multi-pre">
<pre><code class="language-java Java">// NOT RECOMMENDED
@Override
public void onEnable() {
    new BukkitRunnable() {
        @Override
        public void run() {
            CommandAPI.unregister(&quot;gamemode&quot;);
        }
    }.runTaskLater(this, 0);
}
</code></pre>
<pre><code class="language-kotlin Kotlin">// NOT RECOMMENDED
override fun onEnable() {
    object : BukkitRunnable() {
        override fun run() {
            CommandAPI.unregister(&quot;gamemode&quot;)
        }
    }.runTaskLater(this, 0)
}
</code></pre>
</div>
<p>The expected outcome of this code is that <code>/minecraft:gamemode</code> would work as expected, and <code>/gamemode</code> would give the command not found message. However, that is only true for the player's commands. If you try to use <code>/minecraft:gamemode</code> in the console, it <em>will not work</em> properly. Specifically, while you can tab-complete the command's label, <code>minecraft:gamemode</code> the command's arguments will not have any suggestions. If you try to execute <code>/minecraft:gamemode</code> in the console, it will always tell you your command is unknown or incomplete.</p>
<p>The main point is that if you ever try to unregister a Vanilla command after the server is enabled, the namespaced version of that command will break for the console. To avoid this issue, always set <code>unregisterNamespaces</code> to <code>true</code> if <code>unregisterBukkit</code> is <code>false</code> when unregistering commands after the server is enabled.</p>
<div class="multi-pre">
<pre><code class="language-java Java">@Override
public void onEnable() {
    new BukkitRunnable() {
        @Override
        public void run() {
            CommandAPI.unregister(&quot;gamemode&quot;, true);
        }
    }.runTaskLater(this, 0);
}
</code></pre>
<pre><code class="language-kotlin Kotlin">override fun onEnable() {
    object : BukkitRunnable() {
        override fun run() {
            CommandAPI.unregister(&quot;gamemode&quot;, true)
        }
    }.runTaskLater(this, 0)
}
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-executors"><a class="header" href="#command-executors">Command executors</a></h1>
<blockquote>
<p><strong>Developer's Note:</strong></p>
<p>This section can be a little bit difficult to follow. If you only want the bare basic features <em>(executes a command)</em>, read the section on <em>Normal command executors</em> - this behaves very similar to the <code>onCommand</code> method in Bukkit.</p>
</blockquote>
<hr />
<p>The CommandAPI provides various command executors which are lambdas which execute the code you want when a command is called. With a lot of simplification, there are two main types of command executors:</p>
<ul>
<li>Ones that just runs the command (let's call it a <em>normal command executor</em>)</li>
<li>Ones that returns an integer as a result (let's call it a <em>resulting command executor</em>)</li>
</ul>
<blockquote>
<p><strong>Developer's Note:</strong></p>
<p>In general, you need not focus too much on what type of command executor to implement. If you know for certain that you're going to be using your command with command blocks, and specifically want to state whether a command returns a value, just ensure you return an integer at the end of your declared command executor. Java will infer the type <em>(whether it's a normal command executor or a resulting command executor)</em> automatically, so feel free to return an integer or not.</p>
</blockquote>
<p>In addition to these two types of command executors, there are ways to restrict the execution of commands to certain <code>CommandSender</code> subclasses. In other words, you can make commands executable by players in game only for instance. These restrictions are covered in more detail in <a href="./normalexecutors.html">Normal command executors</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="normal-command-executors"><a class="header" href="#normal-command-executors">Normal command executors</a></h1>
<p>Command executors are of the following format, where <code>sender</code> is a <a href="https://hub.spigotmc.org/javadocs/bukkit/org/bukkit/command/CommandSender.html"><code>CommandSender</code></a>, and <code>args</code> is a <a href="./commandarguments.html"><code>CommandArguments</code></a> object, which represents arguments which are parsed by the CommandAPI.</p>
<pre><code class="language-java">new CommandAPICommand(&quot;...&quot;)
    .executes((sender, args) -&gt; {
        //Code here  
    })
    .register();
</code></pre>
<p>With normal command executors, these do not need to return anything. By default, this will return a <em>success value</em> of 1 if it runs successfully, and a <em>success value</em> of 0 if it runs unsuccessfully, either by throwing an exception <em>(RuntimeException)</em> or by forcing the command to fail (See the section on <a href="./commandfailures.html">handling command failures</a>).</p>
<p>In short, this is what values are returned when a command is executed from a normal command executor:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"></th><th style="text-align: center">Command Works</th><th style="text-align: center">Command Doesn't Work</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong>Success Value</strong></td><td style="text-align: center">1</td><td style="text-align: center">0</td></tr>
<tr><td style="text-align: center"><strong>Result Value</strong></td><td style="text-align: center">1</td><td style="text-align: center">0</td></tr>
</tbody></table>
</div><div class="example">
<h3 id="example---creating-a-message-broadcasting-system"><a class="header" href="#example---creating-a-message-broadcasting-system">Example - Creating a message broadcasting system</a></h3>
<p>To illustrate this, let's take a look at a simple message broadcasting command. We'll make a command which sends a message to everyone on the server, using the following syntax:</p>
<pre><code class="language-mccmd">/broadcastmsg &lt;message&gt;
/broadcastmessage &lt;message&gt;
/broadcast &lt;message&gt;
</code></pre>
<p>We use an argument &quot;message&quot; to hold the message to broadcast, we provide some aliases and set a permission required to run the command. Then we declare our main command body by using the <code>.executes()</code> method, before finally registering the command:</p>
<div class="multi-pre">
<pre><code class="language-java Java">// Create our command
new CommandAPICommand(&quot;broadcastmsg&quot;)
    .withArguments(new GreedyStringArgument(&quot;message&quot;)) // The arguments
    .withAliases(&quot;broadcast&quot;, &quot;broadcastmessage&quot;)       // Command aliases
    .withPermission(CommandPermission.OP)               // Required permissions
    .executes((sender, args) -&gt; {
        String message = (String) args.get(&quot;message&quot;);
        Bukkit.getServer().broadcastMessage(message);
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">// Create our command
CommandAPICommand(&quot;broadcastmsg&quot;)
    .withArguments(GreedyStringArgument(&quot;message&quot;)) // The arguments
    .withAliases(&quot;broadcast&quot;, &quot;broadcastmessage&quot;)       // Command aliases
    .withPermission(CommandPermission.OP)               // Required permissions
    .executes(CommandExecutor { _, args -&gt;
        val message = args[&quot;message&quot;] as String
        Bukkit.getServer().broadcastMessage(message)
    })
    .register()
</code></pre>
</div>
<p>Note how when we finish up our implementation of <code>.executes()</code>, we don't return anything. This is unlike commands in the standard Bukkit API where the <code>onCommand</code> method returns a Boolean value:</p>
<pre><code class="language-java">boolean onCommand(CommandSender, Command, String, String[])
</code></pre>
<p>The returning of this Boolean value is handled automatically by the CommandAPI on a much lower level.</p>
</div>
<hr />
<h2 id="restricting-who-can-run-your-command"><a class="header" href="#restricting-who-can-run-your-command">Restricting who can run your command</a></h2>
<p>The <code>CommandAPICommand</code> class has multiple different <code>executes...()</code> methods that can restrict the command sender to any of the following objects:</p>
<div class="table-wrapper"><table><thead><tr><th>CommandSender Object</th><th>Method to use</th><th>Who can run this?</th></tr></thead><tbody>
<tr><td><code>CommandSender</code></td><td><code>.executes()</code></td><td>Any CommandSender</td></tr>
<tr><td><code>Player</code></td><td><code>.executesPlayer()</code></td><td>In-game players only</td></tr>
<tr><td><code>Entity</code></td><td><code>.executesEntity()</code></td><td>Entities only</td></tr>
<tr><td><code>BlockCommandSender</code></td><td><code>.executesCommandBlock()</code></td><td>Command blocks only</td></tr>
<tr><td><code>ConsoleCommandSender</code></td><td><code>.executesConsole()</code></td><td>The console only</td></tr>
<tr><td><code>ProxiedCommandSender</code></td><td><code>.executesProxy()</code></td><td>Proxied senders only<br />(via <code>/execute as ...</code>)</td></tr>
<tr><td><code>NativeProxyCommandSender</code></td><td><code>.executesNative()</code></td><td>See <a href="./native.html">Native commandsenders</a></td></tr>
</tbody></table>
</div><div class="example">
<h3 id="example---a-suicide-command"><a class="header" href="#example---a-suicide-command">Example - A <code>/suicide</code> command</a></h3>
<p>Say we wanted to create a command <code>/suicide</code>, which kills the player that executes it. Since this command can't be used by non-players (you can't kill a command block!), we can restrict it so only players can execute this command. Since it's a player, we can use the <code>.executesPlayer()</code> method:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;suicide&quot;)
    .executesPlayer((player, args) -&gt; {
        player.setHealth(0);
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;suicide&quot;)
    .executesPlayer(PlayerCommandExecutor { player, _ -&gt;
        player.setHealth(0.0)
    })
    .register()
</code></pre>
</div>
</div>
<hr />
<h2 id="multiple-command-executor-implementations"><a class="header" href="#multiple-command-executor-implementations">Multiple command executor implementations</a></h2>
<p>The CommandAPI allows you to chain different implementations of the command depending on the type of <code>CommandSender</code>. This allows you to easily specify what types of <code>CommandSender</code>s are required to run a command.</p>
<p>Extending on the suicide example above, we could write another implementation for a different <code>CommandSender</code>. Here, we write an implementation to make entities (non-player) go out with a bang when they run the command (using <code>/execute as &lt;entity&gt; run suicide</code> command).</p>
<div class="example">
<h3 id="example---a-suicide-command-with-different-implementations"><a class="header" href="#example---a-suicide-command-with-different-implementations">Example - A <code>/suicide</code> command with different implementations</a></h3>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;suicide&quot;)
    .executesPlayer((player, args) -&gt; {
        player.setHealth(0);
    })
    .executesEntity((entity, args) -&gt; {
        entity.getWorld().createExplosion(entity.getLocation(), 4);
        entity.remove();
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;suicide&quot;)
    .executesPlayer(PlayerCommandExecutor { player, _ -&gt;
        player.setHealth(0.0)
    })
    .executesEntity(EntityCommandExecutor { entity, _ -&gt;
        entity.world.createExplosion(entity.location, 4f)
        entity.remove()
    })
    .register()
</code></pre>
</div>
<p>This saves having to use <code>instanceof</code> multiple times to check the type of the <code>CommandSender</code>.</p>
</div>
<p>The different command sender priority is the following (from highest priority to lowest priority):</p>
<p>\begin{align}
&amp;\quad\texttt{.executesNative()} &amp;&amp; \texttt{(Always chosen if used)}\\
&amp;\quad\texttt{.executesPlayer()} \\
&amp;\quad\texttt{.executesEntity()} \\
&amp;\quad\texttt{.executesConsole()} \\
&amp;\quad\texttt{.executesCommandBlock()} \\
&amp;\quad\texttt{.executesProxy()} \\
&amp;\quad\texttt{.executes()}
\end{align}</p>
<hr />
<h2 id="multiple-command-executors-with-the-same-implementation"><a class="header" href="#multiple-command-executors-with-the-same-implementation">Multiple command executors with the same implementation</a></h2>
<p>The CommandAPI also allows you to have multiple command executors with the same command implementation. This is useful for when you want to restrict the command sender required to run a command, but want to run the same code for each different command sender type.</p>
<p>This is achieved using the <code>.executes(executor, ...)</code> method, which accepts a variadic array of <code>ExecutorType</code> objects. <code>ExecutorType</code> has the following values:</p>
<div class="table-wrapper"><table><thead><tr><th>ExecutorType Object</th><th>Who can run this?</th></tr></thead><tbody>
<tr><td><code>ALL</code></td><td>Any CommandSender</td></tr>
<tr><td><code>PLAYER</code></td><td>In-game players only</td></tr>
<tr><td><code>ENTITY</code></td><td>Entities only</td></tr>
<tr><td><code>BLOCK</code></td><td>Command blocks only</td></tr>
<tr><td><code>CONSOLE</code></td><td>The console only</td></tr>
<tr><td><code>PROXY</code></td><td>Proxied senders only<br />(via <code>/execute as ...</code>)</td></tr>
<tr><td><code>NATIVE</code></td><td>See <a href="./native.html">Native commandsenders</a></td></tr>
</tbody></table>
</div><div class="example">
<h3 id="example---a-suicide-command-with-the-same-implementation"><a class="header" href="#example---a-suicide-command-with-the-same-implementation">Example - A <code>/suicide</code> command with the same implementation</a></h3>
<p>Expanding on the suicide example above, we can restrict the command to only players and entities. We know that the command sender is a <code>LivingEntity</code>, so we can cast to it safely.</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;suicide&quot;)
    .executes((sender, args) -&gt; {
        LivingEntity entity;
        if (sender instanceof ProxiedCommandSender proxy) {
            entity = (LivingEntity) proxy.getCallee();
        } else {
            entity = (LivingEntity) sender;
        }
        entity.setHealth(0);
    }, ExecutorType.PLAYER, ExecutorType.PROXY)
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;suicide&quot;)
    .executes(CommandExecutor { sender, _ -&gt;
        val entity = (if (sender is ProxiedCommandSender) sender.callee else sender) as LivingEntity
        entity.setHealth(0.0)
    }, ExecutorType.PLAYER, ExecutorType.PROXY)
    .register()
</code></pre>
</div>
</div>
<hr />
<h2 id="using-the-executioninfo"><a class="header" href="#using-the-executioninfo">Using the ExecutionInfo</a></h2>
<p>You also have the option to implement a command executor which uses an <code>ExecutionInfo</code> object:</p>
<pre><code class="language-java">new CommandAPICommand(&quot;...&quot;)
    .executes(info -&gt; {
        // Use info here
    })
    .register();
</code></pre>
<p>The <code>ExecutionInfo</code> provides two user-facing methods which both let you access the <a href="https://hub.spigotmc.org/javadocs/bukkit/org/bukkit/command/CommandSender.html"><code>CommandSender</code></a> and the arguments:</p>
<pre><code class="language-java">CommandSender sender();
</code></pre>
<p>This method automatically detects which CommandSender type has been used, similar to the <code>.executesXXX()</code> method (see <a href="./normalexecutors.html#restricting-who-can-run-your-command">here</a>)! Therefore, casting is not necessary!</p>
<p>The second method lets you access the command's arguments:</p>
<pre><code class="language-java">CommandArguments args();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proxied-commandsenders"><a class="header" href="#proxied-commandsenders">Proxied commandsenders</a></h1>
<p>The CommandAPI has extra support for vanilla Minecraft's <code>/execute</code> command, by allowing the CommandSender to be an instance of the <code>ProxiedCommandSender</code> class. This allows the CommandSender to contain two extra pieces of information: The &quot;proxied sender&quot; and the original sender.</p>
<div class="example">
<h3 id="example---running-a-command-as-a-chicken"><a class="header" href="#example---running-a-command-as-a-chicken">Example - Running a command as a chicken</a></h3>
<p>Say we have a command which kills the sender of a command. This is easily implemented as follows:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;killme&quot;)
    .executesPlayer((player, args) -&gt; {
        player.setHealth(0);
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;killme&quot;)
    .executesPlayer(PlayerCommandExecutor { player, _ -&gt;
        player.setHealth(0.0)
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;killme&quot;) {
    playerExecutor { player, _ -&gt;
        player.health = 0.0
    }
}
</code></pre>
</div>
<p>But what if the sender of the command is <em>not</em> a player? By using Minecraft's <code>/execute</code> command, we could execute the command as <em>any</em> arbitrary entity, as shown with the command below:</p>
<pre><code class="language-mccmd">/execute as @e[type=chicken] run killme
</code></pre>
<p>To handle this case, we can use the <code>.executesProxy()</code> method to ensure that the command sender is a <code>ProxiedCommandSender</code>. Then, we can kill the <code>callee</code> <em>(the entity which is being 'forced' to run the command /killme)</em></p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;killme&quot;)
    .executesPlayer((player, args) -&gt; {
        player.setHealth(0);
    })
    .executesProxy((proxy, args) -&gt; {
        // Check if the callee (target) is an Entity and kill it
        if (proxy.getCallee() instanceof LivingEntity target) {
            target.setHealth(0);
        }
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;killme&quot;)
    .executesPlayer(PlayerCommandExecutor { player, _ -&gt;
        player.setHealth(0.0)
    })
    .executesProxy(ProxyCommandExecutor { proxy, _ -&gt;
        // Check if the callee (target) is an Entity and kill it
        if (proxy.callee is LivingEntity) {
            (proxy.callee as LivingEntity).setHealth(0.0)
        }
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;killme&quot;) {
    playerExecutor { player, _ -&gt;
        player.health = 0.0
    }
    proxyExecutor { proxy, _ -&gt;
        // Check if the callee (target) is an Entity and kill it
        if (proxy.callee is LivingEntity) {
            (proxy.callee as LivingEntity).health = 0.0
        }
    }
}
</code></pre>
</div>
<p>This allows the command above to run successfully, killing all chickens it can find.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="native-commandsenders"><a class="header" href="#native-commandsenders">Native commandsenders</a></h1>
<p>In a similar way that the <code>ProxiedCommandSender</code> is used to store information about two command senders: a caller (the one that wrote the command) and a callee (the one that ends up executing the command), the CommandAPI also has a special <code>NativeProxyCommandSender</code> class which is a more powerful representation of the <code>ProxiedCommandSender</code> class. In addition to inheriting all of the methods from <code>ProxiedCommandSender</code>, this class also has the following two methods:</p>
<pre><code class="language-java">public World getWorld();
public Location getLocation();
</code></pre>
<p>These methods contain additional information about the command executor's state, and are primarily designed to be used with Minecraft's <code>/execute</code> command.</p>
<hr />
<h2 id="minecrafts-execute-arguments"><a class="header" href="#minecrafts-execute-arguments">Minecraft's <code>/execute</code> arguments</a></h2>
<p>The following table represents how the different <code>/execute</code> arguments affect the <code>NativeProxyCommandSender</code> class:</p>
<div class="table-wrapper"><table><thead><tr><th>/execute argument</th><th>How it changes NativeProxyCommandSender</th></tr></thead><tbody>
<tr><td><code>/execute align</code></td><td>Changes <code>getLocation()</code> only</td></tr>
<tr><td><code>/execute anchored</code></td><td>Changes nothing</td></tr>
<tr><td><code>/execute as</code></td><td>Changes <code>getCallee()</code> only</td></tr>
<tr><td><code>/execute at</code></td><td>Changes <code>getLocation()</code> and <code>getWorld()</code> only</td></tr>
<tr><td><code>/execute facing</code></td><td>Changes <code>getLocation()</code> only</td></tr>
<tr><td><code>/execute in</code></td><td>Changes <code>getWorld()</code> only</td></tr>
<tr><td><code>/execute positioned</code></td><td>Changes <code>getLocation()</code> only</td></tr>
<tr><td><code>/execute rotated</code></td><td>Changes <code>getLocation()</code>only</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="using-the-native-commandsender"><a class="header" href="#using-the-native-commandsender">Using the native commandsender</a></h2>
<p>As described in the section about <a href="./normalexecutors.html">normal command executors</a>, there are multiple methods to register a command executor. For the <code>NativeProxyCommandSender</code>, the <code>.executesNative()</code> method should be used.</p>
<blockquote>
<p><strong>Note:</strong></p>
<p>The <code>.executesNative()</code> method has the highest priority over all over <code>.executesXXX()</code> methods - if you use the <code>.executesNative()</code> method, no other execution method will be run.</p>
</blockquote>
<hr />
<div class="example">
<h3 id="example---a-really-simple-break-block-command"><a class="header" href="#example---a-really-simple-break-block-command">Example - A really simple &quot;break block&quot; command</a></h3>
<p>Say we wanted to make a command that simply sets the current block to air. For this example, we'll use the following command syntax:</p>
<pre><code class="language-mccmd">/break
</code></pre>
<p>As you can see, this command takes no arguments. This is fine, since our &quot;argument&quot; will be the sender's location. We can access the sender's location using the <code>getLocation()</code> method from the <code>NativeProxyCommandSender</code> object, available from the <code>.executesNative()</code> method:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;break&quot;)
    .executesNative((sender, args) -&gt; {
        Location location = sender.getLocation();
        if (location != null) {
            location.getBlock().breakNaturally();
        }
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;break&quot;)
    .executesNative(NativeCommandExecutor { sender, _ -&gt;
        val location = sender.location
        location.block.breakNaturally()
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;break&quot;) {
    nativeExecutor { sender, _ -&gt;
        val location = sender.location
        location.block.breakNaturally()
    }
}
</code></pre>
</div>
<p>This can now be used via the following command examples:</p>
<pre><code class="language-mccmd">/execute positioned 100 62 50 run break
</code></pre>
<pre><code class="language-mccmd">/execute at @e[type=pig] run break
</code></pre>
<pre><code class="language-mccmd">/execute in minecraft:overworld positioned 20 60 -20 run break
</code></pre>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resulting-command-executors"><a class="header" href="#resulting-command-executors">Resulting command executors</a></h1>
<p>Resulting command executors are very similar to normal command executors, except they can return an integer <em>result value</em>.</p>
<pre><code class="language-java">(sender, args) -&gt; {
    //Code here
    return /*some integer here*/ ;
};
</code></pre>
<p>Similarly, these will return a <em>success value</em> of 1 if it runs successfully, and a <em>success value</em> of 0 if it runs unsuccessfully. <strong>If a success value of 0 occurs, the <em>result value</em> will be 0</strong>. In short:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center"></th><th style="text-align: center">Command Works</th><th style="text-align: center">Command Doesn't Work</th></tr></thead><tbody>
<tr><td style="text-align: center"><strong>Success Value</strong></td><td style="text-align: center">1</td><td style="text-align: center">0</td></tr>
<tr><td style="text-align: center"><strong>Result Value</strong></td><td style="text-align: center">result defined in your code</td><td style="text-align: center">0</td></tr>
</tbody></table>
</div>
<p>The concept of result values are better explained through examples:</p>
<div class="example">
<h3 id="example---random-number-result-command"><a class="header" href="#example---random-number-result-command">Example - Random number result command</a></h3>
<p>Say we want a command that returns a random number as a result. This can then be used by vanilla Minecraft's <code>/execute store result ...</code> command, which can be used for other command block chains.</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;randnum&quot;)
    .executes((sender, args) -&gt; {
        return ThreadLocalRandom.current().nextInt();
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;randnum&quot;)
    .executes(ResultingCommandExecutor { _, _ -&gt;
        Random.nextInt()
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;randnum&quot;) {
    anyResultingExecutor { _, _ -&gt;
        Random.nextInt()
    }
}
</code></pre>
</div>
<p>This returns a <strong>success value of 1</strong> <em>(Because no errors or <code>CommandAPI.failWithString(String)</code> was thrown)</em> and a <strong>result value of a random number</strong>.</p>
</div>
<div class="example">
<h3 id="example---lootbox-system-with-execute-command"><a class="header" href="#example---lootbox-system-with-execute-command">Example - Lootbox system with <code>/execute</code> command</a></h3>
<p>We can store state using <code>/execute store</code> and we can perform conditional checks using <code>/execute if</code>. By combining these, we can create a system which can be used with commandblocks to say, give players random lootboxes and redeem them. The concept is to create a command that generates a random number from 1 to 100. If the number is 1 (thus, the chance of being chosen is \(\frac{1}{100}\)), then we award a player with some reward, say 64 diamonds.</p>
<p>To do this, we'll declare two commands:</p>
<pre><code class="language-mccmd">/randomnumber        - returns a random number between 1 and 99 (inclusive)
/givereward &lt;player&gt; - gives a player 64 diamonds and broadcasts it in the chat
</code></pre>
<p>Since we're declaring commands that are to be used in <code>/execute</code>, we must ensure that these commands are registered in your plugin's <code>onLoad()</code> method. First, we write our implementation for <code>/randomnumber</code>. It is fairly straight forward using Java's <code>ThreadLocalRandom</code> to generate a random number:</p>
<div class="multi-pre">
<pre><code class="language-java Java">// Register random number generator command from 1 to 99 (inclusive)
new CommandAPICommand(&quot;randomnumber&quot;)
    .executes((sender, args) -&gt; {
        return ThreadLocalRandom.current().nextInt(1, 100); // Returns random number from 1 &lt;= x &lt; 100
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">// Register random number generator command from 1 to 99 (inclusive)
CommandAPICommand(&quot;randomnumber&quot;)
    .executes(ResultingCommandExecutor { _, _ -&gt;
        (1..100).random() // Returns random number from 1 &lt;= x &lt; 100
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">// Register random number generator command from 1 to 99 (inclusive)
commandAPICommand(&quot;randomnumber&quot;) {
    anyResultingExecutor { _, _ -&gt;
        (1..100).random()
    }
}
</code></pre>
</div>
<p>Now we write our implementation for <code>/givereward</code>. In this example, we use the <code>EntitySelectorArgument</code> to select a single player. We cast it to <code>Player</code> and then add the items to their inventory.</p>
<div class="multi-pre">
<pre><code class="language-java Java">// Register reward giving system for a target player
new CommandAPICommand(&quot;givereward&quot;)
    .withArguments(new EntitySelectorArgument.OnePlayer(&quot;target&quot;))
    .executes((sender, args) -&gt; {
        Player player = (Player) args.get(&quot;target&quot;);
        player.getInventory().addItem(new ItemStack(Material.DIAMOND, 64));
        Bukkit.broadcastMessage(player.getName() + &quot; won a rare 64 diamonds from a loot box!&quot;);
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">// Register reward giving system for a target player
CommandAPICommand(&quot;givereward&quot;)
    .withArguments(EntitySelectorArgument.OnePlayer(&quot;target&quot;))
    .executes(CommandExecutor { _, args -&gt;
        val player = args[&quot;target&quot;] as Player
        player.inventory.addItem(ItemStack(Material.DIAMOND, 64))
        Bukkit.broadcastMessage(&quot;${player.name} won a rare 64 diamonds from a loot box!&quot;)
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">// Register reward giving system for a target player
commandAPICommand(&quot;givereward&quot;) {
    entitySelectorArgumentOnePlayer(&quot;target&quot;)
    anyExecutor { _, args -&gt;
        val player = args[&quot;target&quot;] as Player
        player.inventory.addItem(ItemStack(Material.DIAMOND, 64))
        Bukkit.broadcastMessage(&quot;${player.name} won a rare 64 diamonds from a loot box!&quot;)
    }
}
</code></pre>
</div>
<hr />
<p>Now that we've declared these commands, we can now use them in practice. We can use a command block to store a random number under the scoreboard score <code>randVal</code> for a player called <code>SomePlayer</code>, by executing the command <code>/randomnumber</code>. Since <code>/randomnumber</code> <strong>returns</strong> an integer, this value is stored in the scoreboard score:</p>
<pre><code class="language-mccmd">/execute store result score SomePlayer randVal run randomnumber
</code></pre>
<p>To check if the random number is equal to 1, we can use the <code>/execute if</code> command. If their score stored in <code>randVal</code> matches 1, then we run the <code>/givereward</code> command.</p>
<pre><code class="language-mccmd">/execute if score SomePlayer randVal matches 1 run givereward SomePlayer
</code></pre>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="handling-command-failures"><a class="header" href="#handling-command-failures">Handling command failures</a></h1>
<p>Sometimes, you want your command to fail on purpose. This is the way to &quot;gracefully&quot; handle errors in your command execution. This is performed by throwing any of the following methods:</p>
<pre><code class="language-java">throw CommandAPI.failWithString(String message);
throw CommandAPI.failWithMessage(Message message);
throw CommandAPIBukkit.failWithBaseComponents(BaseComponent... message);
throw CommandAPIBukkit.failWithAdventureComponent(Component message);
throw CommandAPIBukkit.failWithAdventureComponent(ComponentLike message);
</code></pre>
<p>When the CommandAPI handles the fail method, it will cause the command to return a <em>success value</em> of 0, to indicate failure.</p>
<div class="example">
<h3 id="example---command-failing-for-element-not-in-a-list"><a class="header" href="#example---command-failing-for-element-not-in-a-list">Example - Command failing for element not in a list</a></h3>
<p>Say we have some list containing fruit and the player can choose from it. In order to do that, we can use a <code>StringArgument</code> and suggest it to the player using <code>.replaceSuggestions(info -&gt; String[])</code>. However, because this only lists <em>suggestions</em> to the player, it does <strong>not</strong> stop the player from entering an option that isn't on the list of suggestions.</p>
<p>Therefore, to gracefully handle this with a proper error message, we use one of the <code>CommandAPI.failWithXXX()</code> methods above with a meaningful error message which is displayed to the user.</p>
<div class="multi-pre">
<pre><code class="language-java Java">// Array of fruit
String[] fruit = new String[] {&quot;banana&quot;, &quot;apple&quot;, &quot;orange&quot;};

// Register the command
new CommandAPICommand(&quot;getfruit&quot;)
    .withArguments(new StringArgument(&quot;item&quot;).replaceSuggestions(ArgumentSuggestions.strings(fruit)))
    .executes((sender, args) -&gt; {
        String inputFruit = (String) args.get(&quot;item&quot;);
        
        if (Arrays.stream(fruit).anyMatch(inputFruit::equals)) {
            // Do something with inputFruit
        } else {
            // The sender's input is not in the list of fruit
            throw CommandAPI.failWithString(&quot;That fruit doesn't exist!&quot;);
        }
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">// List of fruit
val fruit = listOf&lt;String&gt;(&quot;banana&quot;, &quot;apple&quot;, &quot;orange&quot;)

// Register the command
CommandAPICommand(&quot;getfruit&quot;)
    .withArguments(StringArgument(&quot;item&quot;).replaceSuggestions(ArgumentSuggestions.strings(fruit)))
    .executes(CommandExecutor { _, args -&gt;
        val inputFruit = args[&quot;item&quot;] as String

        if(fruit.any { it == inputFruit }) {
            // Do something with inputFruit
        } else {
            // The sender's input is not in the list of fruit
            throw CommandAPI.failWithString(&quot;That fruit doesn't exist!&quot;)
        }
    })
    .register()
</code></pre>
</div>
</div>
<blockquote>
<p><strong>Developer's Note:</strong></p>
<p>In general, it's a good idea to handle unexpected cases with one of the <code>CommandAPI.failWithXXX()</code> methods. Most arguments used by the CommandAPI will have their own built-in failsafe system <em>(e.g. the <code>EntitySelectorArgument</code> will not execute the command executor if it fails to find an entity)</em>, so this feature is for those extra cases.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arguments"><a class="header" href="#arguments">Arguments</a></h1>
<p>Arguments in the CommandAPI are registered by using an <code>Argument[]</code> or <code>List&lt;Argument&gt;</code> object. There are two things you need to keep in mind when creating arguments:</p>
<ul>
<li>The order which they will be used</li>
<li>The type of each argument</li>
</ul>
<p>By definition of a <code>List</code>, the order of the elements inserted into it are preserved, meaning the order you add arguments to the <code>List</code> will be the resulting order of which arguments are presented to the user when they run that command.</p>
<p>Adding arguments for registration is simple:</p>
<pre><code class="language-java">// Create a List
List&lt;Argument&gt; arguments = new ArrayList&lt;&gt;();

// Add an argument with the node &quot;target&quot;, which is a PlayerArgument
arguments.add(new PlayerArgument(&quot;target&quot;));
</code></pre>
<p>The String value is the node that is registered into Minecraft's internal command graph. This name is also used as a prompt that is shown to a player when they are entering the command.</p>
<hr />
<p>The CommandAPI is very flexible when it comes to registering arguments, and lets you use a number of different methods to suit your preference:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;mycommand&quot;)
    .withArguments(new StringArgument(&quot;arg0&quot;))
    .withArguments(new StringArgument(&quot;arg1&quot;))
    .withArguments(new StringArgument(&quot;arg2&quot;))
    // And so on
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;mycommand&quot;)
    .withArguments(StringArgument(&quot;arg0&quot;))
    .withArguments(StringArgument(&quot;arg1&quot;))
    .withArguments(StringArgument(&quot;arg2&quot;))
    // And so on
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;mycommand&quot;) {
    stringArgument(&quot;arg0&quot;)
    stringArgument(&quot;arg1&quot;)
    stringArgument(&quot;arg2&quot;)
    // And so on
}
</code></pre>
</div>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;mycommand&quot;)
    .withArguments(new StringArgument(&quot;arg0&quot;), new StringArgument(&quot;arg1&quot;), new StringArgument(&quot;arg2&quot;))
    // And so on
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;mycommand&quot;)
    .withArguments(StringArgument(&quot;arg0&quot;), StringArgument(&quot;arg1&quot;), StringArgument(&quot;arg2&quot;))
    // And so on
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;mycommand&quot;) {
    arguments(StringArgument(&quot;arg0&quot;), StringArgument(&quot;arg1&quot;), StringArgument(&quot;arg2&quot;))
    // And so on
}
</code></pre>
</div>
<div class="multi-pre">
<pre><code class="language-java Java">List&lt;Argument&lt;?&gt;&gt; arguments = new ArrayList&lt;&gt;();
arguments.add(new StringArgument(&quot;arg0&quot;));
arguments.add(new StringArgument(&quot;arg1&quot;));
arguments.add(new StringArgument(&quot;arg2&quot;));

new CommandAPICommand(&quot;mycommand&quot;)
    .withArguments(arguments)
    // And so on
</code></pre>
<pre><code class="language-kotlin Kotlin">val arguments = listOf(
    StringArgument(&quot;arg0&quot;),
    StringArgument(&quot;arg1&quot;),
    StringArgument(&quot;arg2&quot;)
)

CommandAPICommand(&quot;mycommand&quot;)
    .withArguments(arguments)
    // And so on
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">val arguments = listOf(
    StringArgument(&quot;arg0&quot;),
    StringArgument(&quot;arg1&quot;),
    StringArgument(&quot;arg2&quot;)
)

commandAPICommand(&quot;mycommand&quot;) {
    arguments(*arguments.toTypedArray())
    // And so on
}
</code></pre>
</div>
<hr />
<h2 id="argument-casting"><a class="header" href="#argument-casting">Argument Casting</a></h2>
<p>To access arguments, they have to be casted to the type that the argument represents. The order of the arguments in the <a href="./commandarguments.html"><code>CommandArguments args</code></a> is the same as the order in which the arguments were declared.</p>
<div class="multi-pre">
<pre><code class="language-java Java">List&lt;Argument&lt;?&gt;&gt; commandArguments = new ArrayList&lt;&gt;();
commandArguments.add(new StringArgument(&quot;arg0&quot;));
commandArguments.add(new PotionEffectArgument(&quot;arg1&quot;));
commandArguments.add(new LocationArgument(&quot;arg2&quot;));

new CommandAPICommand(&quot;cmd&quot;)
    .withArguments(commandArguments)
    .executes((sender, args) -&gt; {
        String stringArg = (String) args.get(&quot;arg0&quot;);
        PotionEffectType potionArg = (PotionEffectType) args.get(&quot;arg1&quot;);
        Location locationArg = (Location) args.get(&quot;arg2&quot;);
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">val commandArguments = listOf(
    StringArgument(&quot;arg0&quot;),
    PotionEffectArgument(&quot;arg1&quot;),
    LocationArgument(&quot;arg2&quot;)
)

CommandAPICommand(&quot;cmd&quot;)
    .withArguments(commandArguments)
    .executes(CommandExecutor { _, args -&gt;
        val stringArg = args[&quot;arg0&quot;] as String
        val potionArg = args[&quot;arg1&quot;] as PotionEffectType
        val locationArg = args[&quot;arg2&quot;] as Location
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">val args = listOf(
    StringArgument(&quot;arg0&quot;),
    PotionEffectArgument(&quot;arg1&quot;),
    LocationArgument(&quot;arg2&quot;)
)

commandAPICommand(&quot;cmd&quot;) {
    arguments(*args.toTypedArray())
    anyExecutor { _, args -&gt;
        val stringArg = args[&quot;arg0&quot;] as String
        val potionArg = args[&quot;arg1&quot;] as PotionEffectType
        val locationArg = args[&quot;arg2&quot;] as Location
    }
}
</code></pre>
</div>
<p>The type to cast each argument (declared in the <code>dev.jorel.commandapi.arguments</code> package) is listed below:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: right">Argument class</th><th style="text-align: left">Data type</th></tr></thead><tbody>
<tr><td style="text-align: right"><a href="./argument_angle.html"><code>AngleArgument</code></a></td><td style="text-align: left"><code>float</code></td></tr>
<tr><td style="text-align: right"><a href="./advancementargument.html"><code>AdvancementArgument</code></a></td><td style="text-align: left"><code>org.bukkit.advancement.Advancement</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_chat_adventure.html#adventure-chat-argument"><code>AdventureChatArgument</code></a></td><td style="text-align: left"><code>net.kyori.adventure.text.Component</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_chat_adventure.html#adventure-chat-color-argument"><code>AdventureChatColorArgument</code></a></td><td style="text-align: left"><code>net.kyori.adventure.text.format.NamedTextColor</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_chat_adventure.html#adventure-chat-component-argument"><code>AdventureChatComponentArgument</code></a></td><td style="text-align: left"><code>net.kyori.adventure.text.Component</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_axis.html"><code>AxisArgument</code></a></td><td style="text-align: left"><code>java.util.EnumSet&lt;org.bukkit.Axis&gt;</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_biome.html"><code>BiomeArgument</code></a></td><td style="text-align: left"><code>org.bukkit.block.Biome</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_biome.html"><code>BiomeArgument.NamespacedKey</code></a></td><td style="text-align: left"><code>org.bukkit.NamespacedKey</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_blockpredicate.html"><code>BlockPredicateArgument</code></a></td><td style="text-align: left"><code>java.util.function.Predicate</code><br /> <code>&lt;org.bukkit.block.Block&gt;</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_blockstate.html"><code>BlockStateArgument</code></a></td><td style="text-align: left"><code>org.bukkit.block.data.BlockData</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_primitives.html#boolean-arguments"><code>BooleanArgument</code></a></td><td style="text-align: left"><code>boolean</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_chat_spigot.html#chat-argument"><code>ChatArgument</code></a></td><td style="text-align: left"><code>net.md_5.bungee.api.chat.BaseComponent[]</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_chats.html#chat-color-argument"><code>ChatColorArgument</code></a></td><td style="text-align: left"><code>org.bukkit.ChatColor</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_chat_spigot.html#chat-component-argument"><code>ChatComponentArgument</code></a></td><td style="text-align: left"><code>net.md_5.bungee.api.chat.BaseComponent[]</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_command.html"><code>CommandArgument</code></a></td><td style="text-align: left"><code>dev.jorel.commandapi.wrappers.CommandResult</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_custom.html"><code>CustomArgument&lt;T, B&gt;</code></a></td><td style="text-align: left"><code>T</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_primitives.html#numerical-arguments"><code>DoubleArgument</code></a></td><td style="text-align: left"><code>double</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_enchantment.html"><code>EnchantmentArgument</code></a></td><td style="text-align: left"><code>org.bukkit.enchantments.Enchantment</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_entities.html#entity-selector-argument"><code>EntitySelectorArgument.ManyEntities</code></a></td><td style="text-align: left"><code>Collection&lt;org.bukkit.entity.Entity&gt;</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_entities.html#entity-selector-argument"><code>EntitySelectorArgument.ManyPlayers</code></a></td><td style="text-align: left"><code>Collection&lt;org.bukkit.entity.Player&gt;</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_entities.html#entity-selector-argument"><code>EntitySelectorArgument.OneEntity</code></a></td><td style="text-align: left"><code>org.bukkit.entity.Entity</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_entities.html#entity-selector-argument"><code>EntitySelectorArgument.OnePlayer</code></a></td><td style="text-align: left"><code>org.bukkit.entity.Player</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_entities.html#entity-type-argument"><code>EntityTypeArgument</code></a></td><td style="text-align: left"><code>org.bukkit.entity.EntityType</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_primitives.html#numerical-arguments"><code>FloatArgument</code></a></td><td style="text-align: left"><code>float</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_range.html#the-integerrange--floatrange-class"><code>FloatRangeArgument</code></a></td><td style="text-align: left"><code>dev.jorel.commandapi.wrappers.FloatRange</code></td></tr>
<tr><td style="text-align: right"><a href="./functionwrapper.html"><code>FunctionArgument</code></a></td><td style="text-align: left"><code>dev.jorel.commandapi.wrappers.FunctionWrapper[]</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_strings.html#greedy-string-argument"><code>GreedyStringArgument</code></a></td><td style="text-align: left"><code>String</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_primitives.html#numerical-arguments"><code>IntegerArgument</code></a></td><td style="text-align: left"><code>int</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_range.html#the-integerrange--floatrange-class"><code>IntegerRangeArgument</code></a></td><td style="text-align: left"><code>dev.jorel.commandapi.wrappers.IntegerRange</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_itemstack.html"><code>ItemStackArgument</code></a></td><td style="text-align: left"><code>org.bukkit.inventory.ItemStack</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_itemstackpredicate.html"><code>ItemStackPredicateArgument</code></a></td><td style="text-align: left"><code>java.util.function.Predicate</code><br /> <code>&lt;org.bukkit.inventory.ItemStack&gt;</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_list.html"><code>ListArgument</code></a></td><td style="text-align: left"><code>java.util.Collection&lt;T&gt;</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_literal.html"><code>LiteralArgument</code></a></td><td style="text-align: left">N/A</td></tr>
<tr><td style="text-align: right"><a href="./argument_locations.html#location-2d-space"><code>Location2DArgument</code></a></td><td style="text-align: left"><code>dev.jorel.commandapi.wrappers.Location2D</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_locations.html#location-3d-space"><code>LocationArgument</code></a></td><td style="text-align: left"><code>org.bukkit.Location</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_primitives.html#numerical-arguments"><code>LongArgument</code></a></td><td style="text-align: left"><code>long</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_loottable.html"><code>LootTableArgument</code></a></td><td style="text-align: left"><code>org.bukkit.loot.LootTable</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_map.html"><code>MapArgument</code></a></td><td style="text-align: left"><code>java.util.LinkedHashMap</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_mathoperation.html"><code>MathOperationArgument</code></a></td><td style="text-align: left"><code>dev.jorel.commandapi.wrappers.MathOperation</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_multiliteral.html"><code>MultiLiteralArgument</code></a></td><td style="text-align: left"><code>String</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_namespacedkey.html"><code>NamespacedKeyArgument</code></a></td><td style="text-align: left"><code>org.bukkit.NamespacedKey</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_nbt.html"><code>NBTCompoundArgument&lt;T&gt;</code></a></td><td style="text-align: left">The cast type changes depending on whether you're shading the CommandAPI or using the CommandAPI as a plugin:<br /><ul><li>Shading:<br /><code>T</code> (implemented yourself)</li><br /><li>Plugin:<br /><code>dev.jorel.commandapi.nbtapi.NBTContainer</code></li></ul></td></tr>
<tr><td style="text-align: right"><a href="./argument_objectives.html#objective-argument"><code>ObjectiveArgument</code></a></td><td style="text-align: left"><code>org.bukkit.scoreboard.Objective</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_objectives.html#objective-criteria-argument"><code>ObjectiveCriteriaArgument</code></a></td><td style="text-align: left"><code>String</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_entities.html#offlineplayer-argument"><code>OfflinePlayerArgument</code></a></td><td style="text-align: left"><code>org.bukkit.OfflinePlayer</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_particles.html"><code>ParticleArgument</code></a></td><td style="text-align: left"><code>dev.jorel.commandapi.wrappers.ParticleData</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_entities.html#player-argument"><code>PlayerArgument</code></a></td><td style="text-align: left"><code>org.bukkit.entity.Player</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_potion.html"><code>PotionEffectArgument</code></a></td><td style="text-align: left"><code>org.bukkit.potion.PotionEffectType</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_potion.html"><code>PotionEffectArgument.NamespacedKey</code></a></td><td style="text-align: left"><code>org.bukkit.NamespacedKey</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_recipe.html"><code>RecipeArgument</code></a></td><td style="text-align: left">The cast type changes depending on your Minecraft version:<br><ul><li>Version 1.14.4 and below:<br /><code>org.bukkit.inventory.Recipe</code></li><br /><li>1.15 and above:<br /><code>org.bukkit.inventory.ComplexRecipe</code> </li></ul></td></tr>
<tr><td style="text-align: right"><a href="./argument_rotation.html"><code>RotationArgument</code></a></td><td style="text-align: left"><code>dev.jorel.commandapi.wrappers.Rotation</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_scoreboards.html#scoreboard-slot-argument"><code>ScoreboardSlotArgument</code></a></td><td style="text-align: left"><code>dev.jorel.commandapi.wrappers.ScoreboardSlot</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_scoreboards.html#score-holder-argument"><code>ScoreHolderArgument.Single</code></a></td><td style="text-align: left"><code>String</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_scoreboards.html#score-holder-argument"><code>ScoreHolderArgument.Multiple</code></a></td><td style="text-align: left"><code>Collection&lt;String&gt;</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_sound.html"><code>SoundArgument</code></a></td><td style="text-align: left"><code>org.bukkit.Sound</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_sound.html"><code>SoundArgument.NamespacedKey</code></a></td><td style="text-align: left"><code>org.bukkit.NamespacedKey</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_strings.html#string-argument"><code>StringArgument</code></a></td><td style="text-align: left"><code>String</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_team.html"><code>TeamArgument</code></a></td><td style="text-align: left"><code>org.bukkit.scoreboard.Team</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_strings.html#text-argument"><code>TextArgument</code></a></td><td style="text-align: left"><code>String</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_time.html"><code>TimeArgument</code></a></td><td style="text-align: left"><code>int</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_uuid.html"><code>UUIDArgument</code></a></td><td style="text-align: left"><code>java.util.UUID</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_world.html"><code>WorldArgument</code></a></td><td style="text-align: left"><code>org.bukkit.World</code></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="commandarguments"><a class="header" href="#commandarguments">CommandArguments</a></h1>
<p>The <code>CommandArguments</code> class was introduced in CommandAPI 9.0.0 and provides a much more powerful way of accessing arguments than just an array of arguments which existed until 9.0.0.</p>
<p>While the argument array just gives the possibility to access the arguments via the array notation (<code>args[0]</code>), the <code>CommandArguments</code> class offers much more, including:</p>
<ul>
<li><a href="commandarguments.html#access-the-inner-structure-directly">Access the inner structure directly</a></li>
<li><a href="commandarguments.html#access-arguments">Access arguments</a></li>
<li><a href="commandarguments.html#access-raw-arguments">Access raw arguments</a></li>
<li><a href="commandarguments.html#access-unsafe-arguments">Access unsafe arguments</a></li>
<li><a href="commandarguments.html#access-safe-arguments">Access safe arguments</a></li>
</ul>
<hr />
<h2 id="access-the-inner-structure-directly"><a class="header" href="#access-the-inner-structure-directly">Access the inner structure directly</a></h2>
<p>To access the inner structure of the <code>CommandArguments</code> class directly, it provides various methods which you can learn about below:</p>
<p><strong>Get the argument array</strong></p>
<pre><code class="language-java">Object[] args();
</code></pre>
<p>This returns the array of arguments as defined when creating your command.</p>
<p><strong>Get the arguments mapped to their node name</strong></p>
<pre><code class="language-java">Map&lt;String, Object&gt; argsMap();
</code></pre>
<p>This returns an unmodifiable map which contains the arguments mapped to their node names.</p>
<p><strong>Get the raw argument array</strong></p>
<pre><code class="language-java">String[] rawArgs();
</code></pre>
<p>This returns the array of raw arguments. An explanation of what raw arguments are can be found in the section about <a href="commandarguments.html#access-raw-arguments">accessing raw arguments</a>.</p>
<p><strong>Get the raw arguments mapped to their node name</strong></p>
<pre><code class="language-java">Map&lt;String, String&gt; rawArgsMap();
</code></pre>
<p>This returns an unmodifiable map which contains the raw arguments mapped to their node names. An explanation of what raw arguments are can be found in the section about <a href="commandarguments.html#access-raw-arguments">accessing raw arguments</a>.</p>
<p><strong>Other useful methods</strong></p>
<pre><code class="language-java">String fullInput();    // Returns the full command input (including the / character)
int count();           // Returns the amount of arguments
</code></pre>
<hr />
<h2 id="access-arguments"><a class="header" href="#access-arguments">Access arguments</a></h2>
<p>The <code>CommandArguments</code> class provides its arguments in a way similar to how a <code>List</code> or <code>Map</code> let you access their contents. When using these methods, you need to cast the arguments to their respective type. The <code>CommandArguments</code> class also provides a way to <a href="commandarguments.html#access-unsafe-arguments">access unsafe arguments</a>.</p>
<p>You can choose to access arguments by their node name or by their index.</p>
<h3 id="access-arguments-by-node-name"><a class="header" href="#access-arguments-by-node-name">Access arguments by node name</a></h3>
<p>Accessing arguments by their node name is the recommended way of accessing arguments.</p>
<p>There are four methods you can use to access arguments by their node name:</p>
<pre><code class="language-java">Object get(String nodeName);
Object getOrDefault(String nodeName, Object defaultValue);
Object getOrDefault(String nodeName, Supplier&lt;?&gt; defaultValue);
Optional&lt;Object&gt; getOptional(String nodeName);
</code></pre>
<h3 id="access-arguments-by-index"><a class="header" href="#access-arguments-by-index">Access arguments by index</a></h3>
<p>Accessing arguments by their index is the original way of accessing arguments. However, we recommend to <a href="commandarguments.html#access-arguments-by-node-name">access arguments by node name</a>.</p>
<p>Similar to the four methods of accessing arguments by their node name, there also are four methods you can use to access arguments by their index:</p>
<pre><code class="language-java">Object get(int index);
Object getOrDefault(int index, Object defaultValue);
Object getOrDefault(int index, Supplier&lt;?&gt; defaultValue);
Optional&lt;Object&gt; getOptional(int index);
</code></pre>
<div class="example">
<h3 id="example---access-arguments-by-node-name-and-index"><a class="header" href="#example---access-arguments-by-node-name-and-index">Example - Access arguments by node name and index</a></h3>
<p>To demonstrate the different ways of accessing arguments, we want to register a command <code>/mycommand</code> like this:</p>
<pre><code class="language-mccmd">/mycommand &lt;name&gt; &lt;amount&gt;
/mycommand &lt;name&gt; &lt;amount&gt; &lt;player&gt;
/mycommand &lt;name&gt; &lt;amount&gt; &lt;player&gt; &lt;target&gt;
/mycommand &lt;name&gt; &lt;amount&gt; &lt;player&gt; &lt;target&gt; &lt;message&gt;
</code></pre>
<p>This is how these commands are implemented:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;mycommand&quot;)
    .withArguments(new StringArgument(&quot;name&quot;))
    .withArguments(new IntegerArgument(&quot;amount&quot;))
    .withOptionalArguments(new PlayerArgument(&quot;player&quot;))
    .withOptionalArguments(new PlayerArgument(&quot;target&quot;))
    .withOptionalArguments(new GreedyStringArgument(&quot;message&quot;))
    .executesPlayer((player, args) -&gt; {
        String name = (String) args.get(0); // Access arguments by index
        int amount = (int) args.get(&quot;amount&quot;); // Access arguments by node name
        Player p = (Player) args.getOrDefault(&quot;player&quot;, player); // Access arguments using the getOrDefault(String, Object) method
        Player target = (Player) args.getOrDefault(&quot;target&quot;, () -&gt; player); // Access arguments using the getOrDefault(String, Supplier&lt;?&gt;) method
        String message = (String) args.getOptional(&quot;message&quot;).orElse(&quot;Hello!&quot;); // Access arguments using the getOptional(String) method

        // Do whatever with these values
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;mycommand&quot;)
    .withArguments(StringArgument(&quot;name&quot;))
    .withArguments(IntegerArgument(&quot;amount&quot;))
    .withOptionalArguments(PlayerArgument(&quot;player&quot;))
    .withOptionalArguments(PlayerArgument(&quot;target&quot;))
    .withOptionalArguments(GreedyStringArgument(&quot;message&quot;))
    .executesPlayer(PlayerCommandExecutor { player, args -&gt;
        val name = args[0] as String // Access arguments by index
        val amount = args[&quot;amount&quot;] as Int // Access arguments by node name
        val p = args.getOrDefault(&quot;player&quot;, player) as Player // Access arguments using the getOrDefault(String, Object) method
        val target = args.getOrDefault(&quot;target&quot;) { player } as Player // Access arguments using the getOrDefault(String, Supplier&lt;?&gt;) method
        val message = args.getOptional(&quot;message&quot;).orElse(&quot;Hello!&quot;) as String // Access arguments using the getOptional(String) method

        // Do whatever with these values
    })
    .register();
</code></pre>
</div>
</div>
<hr />
<h2 id="access-raw-arguments"><a class="header" href="#access-raw-arguments">Access raw arguments</a></h2>
<p>A &quot;raw argument&quot; is the <code>String</code> form of an argument as written in a command. For example:</p>
<p>A user defines a command <code>/mycommand</code> that accepts a <code>double</code> as the first argument and an entity selector as the second argument. It could be executed with the values <code>15.3</code> as the <code>double</code> value and <code>@e</code> as the entity selector:</p>
<pre><code class="language-mccmd">/mycommand 15.3 @e
</code></pre>
<p>When <a href="commandarguments.html#access-raw-arguments">accessing the raw arguments</a> of this command there are <code>15.3</code> and <code>@e</code> available as <code>String</code>s.</p>
<p>However, when <a href="commandarguments.html#access-arguments">accessing the arguments</a> of this command there is <code>15.3</code> available as <code>double</code> and <code>@e</code> available as <code>Collection&lt;Entity&gt;</code>.</p>
<p>Raw arguments are accessed basically the same way you would <a href="commandarguments.html#access-arguments">access arguments</a>. You can access them by their node name and their index in the argument array.</p>
<h3 id="access-raw-arguments-by-node-name"><a class="header" href="#access-raw-arguments-by-node-name">Access raw arguments by node name</a></h3>
<p>Accessing raw arguments by their node name is the recommended way of doing it.</p>
<p>To access raw arguments by their node name, you can use these methods:</p>
<pre><code class="language-java">String getRaw(String nodeName);
String getOrDefaultRaw(String nodeName, String defaultValue);
String getOrDefaultRaw(String nodeName, Supplier&lt;String&gt; defaultValue);
Optional&lt;String&gt; getRawOptional(String nodeName);
</code></pre>
<h3 id="access-raw-arguments-by-index"><a class="header" href="#access-raw-arguments-by-index">Access raw arguments by index</a></h3>
<p>Of course, if you don't want to access raw arguments by their node name, we also provide the option to access them by index with these methods:</p>
<pre><code class="language-java">String getRaw(int index);
String getOrDefaultRaw(int index, String defaultValue);
String getOrDefaultRaw(int index, Supplier&lt;String&gt; defaultValue);
Optional&lt;String&gt; getRawOptional(int index);
</code></pre>
<div class="example">
<h3 id="example---access-raw-arguments-by-node-name-and-index"><a class="header" href="#example---access-raw-arguments-by-node-name-and-index">Example - Access raw arguments by node name and index</a></h3>
<p>To demonstrate how to access raw arguments, we are going to implement the <code>/mycommand</code> again, this time with the following syntax:</p>
<pre><code class="language-mccmd">/mycommand &lt;entities&gt;
</code></pre>
<p>We want to find out which entity selector is being used when the command is executed.</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;mycommand&quot;)
    .withArguments(new EntitySelectorArgument.ManyEntities(&quot;entities&quot;))
    .executesPlayer((player, args) -&gt; {
        String entitySelector = args.getRaw(&quot;entities&quot;); // Access the raw argument with getRaw(String)

        // Do whatever with the entity selector
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;mycommand&quot;)
    .withArguments(EntitySelectorArgument.ManyEntities(&quot;entities&quot;))
    .executesPlayer(PlayerCommandExecutor { player, args -&gt;
        val entitySelector = args.getRaw(&quot;entities&quot;)!! // Access the raw argument with getRaw(String)

        // Do whatever with the entity selector
    })
    .register();
</code></pre>
</div>
</div>
<hr />
<h2 id="access-unsafe-arguments"><a class="header" href="#access-unsafe-arguments">Access unsafe arguments</a></h2>
<p>When <a href="commandarguments.html#access-arguments">accessing arguments</a> you need to cast the <code>Object</code> returned by these methods to the type the argument returns. More about casting arguments <a href="./arguments.html#argument-casting">here</a>.</p>
<p>Unsafe arguments provide the ability to access an argument without needing to cast it to the argument's type. When not using unsafe arguments, your code looks like this:</p>
<pre><code class="language-java">String name = (String) args.get(&quot;name&quot;);
</code></pre>
<p>When using unsafe arguments you can make your code look like this:</p>
<pre><code class="language-java">String name = args.getUnchecked(&quot;name&quot;);
</code></pre>
<p>Unsafe arguments can also be accessed by their node names and their indices.</p>
<h3 id="access-arguments-by-node-name-1"><a class="header" href="#access-arguments-by-node-name-1">Access arguments by node name</a></h3>
<p>Unsafe arguments can also be accessed by node name which, again, is the recommended way of doing it.</p>
<p>Use these methods when accessing unsafe arguments by their node name:</p>
<pre><code class="language-java">T getUnchecked(String nodeName);
T getOrDefaultUnchecked(String nodeName, T defaultValue);
T getOrDefaultUnchecked(String nodeName, Supplier&lt;T&gt; defaultValue);
Optional&lt;T&gt; getOptionalUnchecked(String nodeName);
</code></pre>
<h3 id="access-arguments-by-index-1"><a class="header" href="#access-arguments-by-index-1">Access arguments by index</a></h3>
<p>If you want to access unsafe arguments by index, you can do that by using these methods:</p>
<pre><code class="language-java">T getUnchecked(int index);
T getOrDefaultUnchecked(int index, T defaultValue);
T getOrDefaultUnchecked(int index, Supplier&lt;T&gt; defaultValue);
Optional&lt;T&gt; getOptionalUnchecked(int index);
</code></pre>
<div class="example">
<h3 id="example---access-unsafe-arguments-by-node-name-and-index"><a class="header" href="#example---access-unsafe-arguments-by-node-name-and-index">Example - Access unsafe arguments by node name and index</a></h3>
<p>Finally, we want to implement the <code>/mycommand</code> again. This time we use this syntax:</p>
<pre><code class="language-mccmd">/mycommand &lt;player&gt;
</code></pre>
<p>Here, we don't actually want to cast the argument, so we use unsafe arguments to remove that cast:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;mycommand&quot;)
    .withArguments(new PlayerArgument(&quot;player&quot;))
    .executesPlayer((player, args) -&gt; {
        Player p = args.getUnchecked(&quot;player&quot;);

        // Do whatever with the player
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;mycommand&quot;)
    .withArguments(PlayerArgument(&quot;player&quot;))
    .executesPlayer(PlayerCommandExecutor { player, args -&gt;
        val p: Player = args.getUnchecked(&quot;player&quot;)!!

        // Do whatever with the player
    })
    .register();
</code></pre>
</div>
</div>
<hr />
<h2 id="access-safe-arguments"><a class="header" href="#access-safe-arguments">Access safe arguments</a></h2>
<div class="warning">
<p><strong>Developer's Note:</strong></p>
<p>The following methods cannot be used to access a value returned by a <code>CustomArgument</code> as its return type depends on the base argument for it.</p>
</div>
<p>Lastly, the CommandArguments class offers you a way to access your arguments in a more safe way by using internal casts. Again, methods are offered to access arguments by their
index or their node name:</p>
<pre><code class="language-java">T getByClass(String nodeName, Class&lt;T&gt; argumentType);
T getByClassOrDefault(String nodeName, Class&lt;T&gt; argumentType, T defaultValue);
T getOptionalByClass(String nodeName, Class&lt;T&gt; argumentType);
T getByClass(int index, Class&lt;T&gt; argumentType);
T getByClassOrDefault(int index, Class&lt;T&gt; argumentType, T defaultValue);
T getOptionalByClass(int index, Class&lt;T&gt; argumentType);
</code></pre>
<p>Compared to the other methods the <code>CommandArguments</code> class offers, these methods take an additional parameter of type <code>Class&lt;T&gt;</code> where <code>T</code> is the return type
of the argument with the given node name or index.</p>
<p>For example, say you declared a <code>new StringArgument(&quot;value&quot;)</code> and you now want to access the return value of this argument using safe casting. This would be done as follows:</p>
<div class="multi-pre">
<pre><code class="language-java Java">String value = args.getByClass(&quot;value&quot;, String.class);
</code></pre>
<pre><code class="language-kotlin Kotlin">val value = args.getByClass(&quot;value&quot;, String::class.java)
</code></pre>
</div>
<h3 id="access-safe-arguments-using-an-argument-instance"><a class="header" href="#access-safe-arguments-using-an-argument-instance">Access safe arguments using an argument instance</a></h3>
<p>Finally, there is one more, even safer way of accessing safe arguments: by using an argument instance:</p>
<pre><code class="language-java">T getByArgument(Argument&lt;T&gt; argumentType);
T getByArgumentOrDefault(Argument&lt;T&gt; argumentType, T defaultValue);
T getOptionalByArgument(Argument&lt;T&gt; argumentType);
</code></pre>
<p>However, while safer, this also introduces the need to first initialize your arguments before you can start implementing your command.
To visualize this, we want to implement the command from <a href="commandarguments.html#example---access-arguments-by-node-name-and-index">Access arguments by node name and index</a> again, but this time using safe arguments with an argument instance:</p>
<div class="example">
<h3 id="example---access-safe-arguments-using-an-argument-instance"><a class="header" href="#example---access-safe-arguments-using-an-argument-instance">Example - Access safe arguments using an argument instance</a></h3>
<div class="multi-pre">
<pre><code class="language-java Java">StringArgument nameArgument = new StringArgument(&quot;name&quot;);
IntegerArgument amountArgument = new IntegerArgument(&quot;amount&quot;);
PlayerArgument playerArgument = new PlayerArgument(&quot;player&quot;);
PlayerArgument targetArgument = new PlayerArgument(&quot;target&quot;);
GreedyStringArgument messageArgument = new GreedyStringArgument(&quot;message&quot;);

new CommandAPICommand(&quot;mycommand&quot;)
    .withArguments(nameArgument)
    .withArguments(amountArgument)
    .withOptionalArguments(playerArgument)
    .withOptionalArguments(targetArgument)
    .withOptionalArguments(messageArgument)
    .executesPlayer((player, args) -&gt; {
        String name = args.getByArgument(nameArgument);
        int amount = args.getByArgument(amountArgument);
        Player p = args.getByArgumentOrDefault(playerArgument, player);
        Player target = args.getByArgumentOrDefault(targetArgument, player);
        String message = args.getOptionalByArgument(messageArgument).orElse(&quot;Hello!&quot;);

        // Do whatever with these values
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">val nameArgument = StringArgument(&quot;name&quot;)
val amountArgument = IntegerArgument(&quot;amount&quot;)
val playerArgument = PlayerArgument(&quot;player&quot;)
val targetArgument = PlayerArgument(&quot;target&quot;)
val messageArgument = GreedyStringArgument(&quot;message&quot;)

CommandAPICommand(&quot;mycommand&quot;)
    .withArguments(nameArgument)
    .withArguments(amountArgument)
    .withOptionalArguments(playerArgument)
    .withOptionalArguments(targetArgument)
    .withOptionalArguments(messageArgument)
    .executesPlayer(PlayerCommandExecutor { player, args -&gt;
        val name: String = args.getByArgument(nameArgument)!!
        val amount: Int = args.getByArgument(amountArgument)!!
        val p: Player = args.getByArgumentOrDefault(playerArgument, player)
        val target: Player = args.getByArgumentOrDefault(targetArgument, player)
        val message: String = args.getOptionalByArgument(messageArgument).orElse(&quot;Hello!&quot;)

        // Do whatever with these values
    })
    .register();
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="optional-arguments"><a class="header" href="#optional-arguments">Optional Arguments</a></h1>
<p>Sometimes, you want to implement a command that has arguments that do not need to be entered. Take a <code>/sayhi</code> command for example. You may want to say &quot;Hi&quot; to yourself, or to another player. For that, we want this command syntax:</p>
<pre><code class="language-mccmd">/sayhi          - Says &quot;Hi!&quot; to yourself
/sayhi &lt;target&gt; - Says &quot;Hi!&quot; to a target player
</code></pre>
<p>To implement these commands, the CommandAPI provides two methods to help you with that:</p>
<pre><code class="language-java">Argument withOptionalArguments(List&lt;Argument&lt;?&gt;&gt; args);
Argument withOptionalArguments(Argument&lt;?&gt;... args);
</code></pre>
<div class="example">
<h3 id="example---sayhi-command-with-an-optional-argument"><a class="header" href="#example---sayhi-command-with-an-optional-argument">Example - /sayhi command with an optional argument</a></h3>
<p>For example, say we're registering a command <code>/sayhi</code>:</p>
<pre><code class="language-mccmd">/sayhi          - Says &quot;Hi!&quot; to yourself
/sayhi &lt;target&gt; - Says &quot;Hi!&quot; to a target player
</code></pre>
<p>For that, we are going to register a command <code>/sayhi</code>. To add optional arguments, we are going to use the <code>withOptionalArguments(Argument... args)</code> method:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;sayhi&quot;)
    .withOptionalArguments(new PlayerArgument(&quot;target&quot;))
    .executesPlayer((player, args) -&gt; {
        Player target = (Player) args.get(&quot;target&quot;);
        if (target != null) {
            target.sendMessage(&quot;Hi!&quot;);
        } else {
            player.sendMessage(&quot;Hi!&quot;);
        }
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;sayhi&quot;)
    .withOptionalArguments(PlayerArgument(&quot;target&quot;))
    .executesPlayer(PlayerCommandExecutor { player, args -&gt;
        val target: Player? = args[&quot;target&quot;] as Player?
        if (target != null) {
            target.sendMessage(&quot;Hi!&quot;)
        } else {
            player.sendMessage(&quot;Hi!&quot;)
        }
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;sayhi&quot;) {
    playerArgument(&quot;target&quot;, optional = true)
    playerExecutor { player, args -&gt;
        val target: Player? = args[&quot;target&quot;] as Player?
        if (target != null) {
            target.sendMessage(&quot;Hi!&quot;)
        } else {
            player.sendMessage(&quot;Hi!&quot;)
        }
    }
}
</code></pre>
</div>
<p>This gives us the ability to run both <code>/sayhi</code> and <code>/sayhi &lt;target&gt;</code> with the same command name &quot;sayhi&quot;, but have different results based on the arguments used.</p>
<p>You can notice two things:</p>
<ul>
<li>We use the <code>withOptionalArguments</code> method to add an optional argument to a command</li>
<li>We use <code>args.get(&quot;target&quot;)</code> to get our player out of the arguments</li>
</ul>
<p>With optional arguments, there is a possibility of them being not present in the arguments of a command. The reason we use <code>args.get(&quot;target&quot;)</code> is that this will just return <code>null</code> and you can handle what should happen.</p>
</div>
<h2 id="setting-existing-arguments-as-optional-arguments"><a class="header" href="#setting-existing-arguments-as-optional-arguments">Setting existing arguments as optional arguments</a></h2>
<p>In order to set arguments as optional the CommandAPI has the method <code>setOptional(boolean)</code>:</p>
<pre><code class="language-java">Argument setOptional(boolean optional);
</code></pre>
<p>When using the <code>withOptionalArguments</code> method it might be interesting to know that it calls the <code>setOptional()</code> method internally. This means that the following two examples are identical:</p>
<pre><code class="language-java">new CommandAPICommand(&quot;optional&quot;)
    .withOptionalArguments(new PlayerArgument(&quot;target&quot;))
</code></pre>
<pre><code class="language-java">new CommandAPICommand(&quot;optional&quot;)
    .withArguments(new PlayerArgument(&quot;target&quot;).setOptional(true))
</code></pre>
<p>However, calling <code>withOptionalArguments</code> is safer because it makes sure that the argument is optional because of that internal call.</p>
<h2 id="avoiding-null-values"><a class="header" href="#avoiding-null-values">Avoiding null values</a></h2>
<p>Previously, we've looked at how to handle null values. To make all of this easier, the CommandAPI implements multiple additional methods for <a href="./commandarguments.html"><code>CommandArguments</code></a>:</p>
<pre><code class="language-java">Object getOrDefault(int index, Object defaultValue);
Object getOrDefault(int index, Supplier&lt;?&gt; defaultValue);
Object getOrDefault(String nodeName, Object defaultValue);
Object getOrDefault(String nodeName, Supplier&lt;?&gt; defaultValue);
Optional&lt;Object&gt; getOptional(int index)
Optional&lt;Object&gt; getOptional(String nodeName)
</code></pre>
<p>The examples will be using the <code>getOptional</code> methods but there is no downside of using the <code>getOrDefault</code> methods.</p>
<div class="example">
<h3 id="example---sayhi-command-while-using-the-getoptional-method"><a class="header" href="#example---sayhi-command-while-using-the-getoptional-method">Example - /sayhi command while using the getOptional method</a></h3>
<p>Let's register the <code>/sayhi</code> command from above a second time - this time using a <code>getOptional</code> method. We are using the exact same command syntax:</p>
<pre><code class="language-mccmd">/sayhi          - Says &quot;Hi!&quot; to yourself
/sayhi &lt;target&gt; - Says &quot;Hi!&quot; to a target player
</code></pre>
<p>This is how the <code>getOptional</code> method is being implemented:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;sayhi&quot;)
    .withOptionalArguments(new PlayerArgument(&quot;target&quot;))
    .executesPlayer((player, args) -&gt; {
        Player target = (Player) args.getOptional(&quot;target&quot;).orElse(player);
        target.sendMessage(&quot;Hi!&quot;);
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;sayhi&quot;)
    .withOptionalArguments(PlayerArgument(&quot;target&quot;))
    .executesPlayer(PlayerCommandExecutor { player, args -&gt;
        val target: Player = args.getOptional(&quot;target&quot;).orElse(player) as Player
        target.sendMessage(&quot;Hi!&quot;)
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;sayhi&quot;) {
    playerArgument(&quot;target&quot;, optional = true)
    playerExecutor { player, args -&gt;
        val target: Player = args.getOptional(&quot;target&quot;).orElse(player) as Player
        target.sendMessage(&quot;Hi!&quot;)
    }
}
</code></pre>
</div>
</div>
<h2 id="implementing-required-arguments-after-optional-arguments"><a class="header" href="#implementing-required-arguments-after-optional-arguments">Implementing required arguments after optional arguments</a></h2>
<p>We've now talked about how to implement optional arguments and how to avoid null values returned by optional arguments when they aren't provided when executing the command.</p>
<p>Now we also want to talk about how to implement required arguments after optional arguments. For this, the CommandAPI implements a <code>combineWith</code> method for arguments:</p>
<pre><code class="language-java">AbstractArgument combineWith(Argument&lt;?&gt;... combinedArguments);
</code></pre>
<p>You will need to use this method if you want to have a required argument after an optional argument. In general, this is which pattern the CommandAPI follows while dealing with optional arguments:</p>
<ol>
<li>You have a <code>CommandAPICommand</code> and you add arguments to it.</li>
<li>After your required arguments, you can provide optional arguments.</li>
</ol>
<p>At this point your command is basically done. Any attempt to add a required argument will result in an <code>OptionalArgumentException</code>. However, this is where the <code>combineWith</code> method comes in.
This method allows you to combine arguments. Let's say you have an optional <code>StringArgument</code> (here simplified to <code>A</code>) and you want a required <code>PlayerArgument</code> (here simplified to <code>B</code>).
Argument <code>B</code> should only be required if argument <code>A</code> is given. To implement that logic, we are going to use the <code>combineWith</code> method so that we have this syntax:</p>
<pre><code class="language-java">A.combineWith(B)
</code></pre>
<p>This does two things:</p>
<ol>
<li>When checking optional argument constraints the argument <code>B</code> will be ignored so the <code>OptionalArgumentException</code> will not be thrown</li>
<li>It allows you to define additional optional arguments afterwards which can only be entered if argument <code>B</code> has been entered</li>
</ol>
<p>This is how you would add another optional <code>PlayerArgument</code> (here simplified to <code>C</code>):</p>
<pre><code class="language-java">new CommandAPICommand(&quot;mycommand&quot;)
    .withOptionalArguments(A.combineWith(B))
    .withOptionalArguments(C)
</code></pre>
<p>Let's say you declare your arguments like this:</p>
<pre><code class="language-java">new CommandAPICommand(&quot;mycommand&quot;)
    .withOptionalArguments(A.combineWith(B))
    .withArguments(C)
</code></pre>
<p>This would result in an <code>OptionalArgumentException</code> because you are declaring a required argument after an optional argument without creating that exception for argument <code>C</code> like you do for argument <code>B</code>.</p>
<div class="example">
<h3 id="example---required-arguments-after-optional-arguments"><a class="header" href="#example---required-arguments-after-optional-arguments">Example - Required arguments after optional arguments</a></h3>
<p>We want to register a command <code>/rate</code> with the following syntax:</p>
<pre><code class="language-mccmd">/rate                           - Sends an information message
/rate &lt;topic&gt; &lt;rating&gt;          - Rates a topic with a rating and sends a message to the command sender
/rate &lt;topic&gt; &lt;rating&gt; &lt;target&gt; - Rates a topic with a rating and sends a message to the target
</code></pre>
<p>To implement that structure we make use of the <code>combineWith</code> method to make the argument after the optional argument &lt;topic&gt; required:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;rate&quot;)
    .withOptionalArguments(new StringArgument(&quot;topic&quot;).combineWith(new IntegerArgument(&quot;rating&quot;, 0, 10)))
    .withOptionalArguments(new PlayerArgument(&quot;target&quot;))
    .executes((sender, args) -&gt; {
        String topic = (String) args.get(&quot;topic&quot;);
        if(topic == null) {
            sender.sendMessage(
                &quot;Usage: /rate &lt;topic&gt; &lt;rating&gt; &lt;player&gt;(optional)&quot;,
                &quot;Select a topic to rate, then give a rating between 0 and 10&quot;,
                &quot;You can optionally add a player at the end to give the rating to&quot;
            );
            return;
        }

        // We know this is not null because rating is required if topic is given
        int rating = (int) args.get(&quot;rating&quot;);

        // The target player is optional, so give it a default here
        CommandSender target = (CommandSender) args.getOptional(&quot;target&quot;).orElse(sender);

        target.sendMessage(&quot;Your &quot; + topic + &quot; was rated: &quot; + rating + &quot;/10&quot;);
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;rate&quot;)
    .withOptionalArguments(StringArgument(&quot;topic&quot;).combineWith(IntegerArgument(&quot;rating&quot;, 0, 10)))
    .withOptionalArguments(PlayerArgument(&quot;target&quot;))
    .executes(CommandExecutor { sender, args -&gt;
        val topic: String? = args[&quot;topic&quot;] as String?
        if (topic == null) {
            sender.sendMessage(
                &quot;Usage: /rate &lt;topic&gt; &lt;rating&gt; &lt;player&gt;(optional)&quot;,
                &quot;Select a topic to rate, then give a rating between 0 and 10&quot;,
                &quot;You can optionally add a player at the end to give the rating to&quot;
            )
            return@CommandExecutor
        }

        // We know this is not null because rating is required if topic is given
        val rating = args[&quot;rating&quot;] as Int

        // The target player is optional, so give it a default here
        val target: CommandSender = args.getOptional(&quot;target&quot;).orElse(sender) as CommandSender

        target.sendMessage(&quot;Your $topic was rated: $rating/10&quot;)
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;rate&quot;) {
    argument(StringArgument(&quot;topic&quot;).setOptional(true).combineWith(IntegerArgument(&quot;rating&quot;, 0, 10)))
    playerArgument(&quot;target&quot;, optional = true)
    anyExecutor { sender, args -&gt;
        val topic: String? = args[&quot;topic&quot;] as String?
        if (topic == null) {
            sender.sendMessage(
                &quot;Usage: /rate &lt;topic&gt; &lt;rating&gt; &lt;player&gt;(optional)&quot;,
                &quot;Select a topic to rate, then give a rating between 0 and 10&quot;,
                &quot;You can optionally add a player at the end to give the rating to&quot;
            )
            return@anyExecutor
        }

        // We know this is not null because rating is required if topic is given
        val rating = args[&quot;rating&quot;] as Int

        // The target player is optional, so give it a default here
        val target: CommandSender = args.getOptional(&quot;target&quot;).orElse(sender) as CommandSender

        target.sendMessage(&quot;Your $topic was rated: $rating/10&quot;)
    }
}
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="listed-arguments"><a class="header" href="#listed-arguments">Listed arguments</a></h1>
<p>Arguments have a setting which determine whether or not they are present in the <a href="./commandarguments.html"><code>CommandArguments args</code></a> that is populated when executing a command.</p>
<p>By default, the <code>LiteralArgument</code> has this setting set to <code>false</code>, hence the literal values are <em>not</em> present in the <a href="commandarguments.html"><code>CommandArguments args</code></a>.</p>
<p>This flag is set using the following function:</p>
<pre><code class="language-java">Argument setListed(boolean listed);
</code></pre>
<div class="example">
<h3 id="example---setting-listed-arguments"><a class="header" href="#example---setting-listed-arguments">Example - Setting listed arguments</a></h3>
<p>Say we have the following command:</p>
<pre><code class="language-mccmd">/mycommand &lt;player&gt; &lt;value&gt; &lt;message&gt;
</code></pre>
<p>Let's also say that in our implementation of this command, we don't actually perform any processing for <code>&lt;value&gt;</code>. Hence, listing it in the <a href="./commandarguments.html"><code>CommandArguments args</code></a> is unnecessary.</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;mycommand&quot;)
    .withArguments(new PlayerArgument(&quot;player&quot;))
    .withArguments(new IntegerArgument(&quot;value&quot;).setListed(false))
    .withArguments(new GreedyStringArgument(&quot;message&quot;))
    .executes((sender, args) -&gt; {
        // args == [player, message]
        Player player = (Player) args.get(&quot;player&quot;);
        String message = (String) args.get(&quot;message&quot;); // Note that the IntegerArgument is not available in the CommandArguments
        player.sendMessage(message);
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;mycommand&quot;)
    .withArguments(PlayerArgument(&quot;player&quot;))
    .withArguments(IntegerArgument(&quot;value&quot;).setListed(false))
    .withArguments(GreedyStringArgument(&quot;message&quot;))
    .executes(CommandExecutor { _, args -&gt;
        // args == [player, message]
        val player = args[&quot;player&quot;] as Player
        val message = args[&quot;message&quot;] as String // Note that the IntegerArgument is not available in the CommandArguments
        player.sendMessage(message)
    })
    .register()
</code></pre>
</div>
<p>In this scenario, the argument <code>&lt;value&gt;</code> is not present in the <a href="./commandarguments.html"><code>CommandArguments args</code></a> for the executor.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="argument-suggestions"><a class="header" href="#argument-suggestions">Argument suggestions</a></h1>
<p>Sometimes, you want to modify the list of suggestions that are provided by an argument. To handle this, CommandAPI arguments have two methods:</p>
<pre><code class="language-java">Argument replaceSuggestions(ArgumentSuggestions suggestions);
Argument includeSuggestions(ArgumentSuggestions suggestions);
</code></pre>
<p>The <code>replaceSuggestions</code> method replaces all suggestions with the provided list of suggestions, whereas the <code>includeSuggestions</code> method will include the provided suggestions with the suggestions already present by the argument.</p>
<p>Because argument suggestions are arguably the most powerful feature that the CommandAPI offers, I've split this section into a number of subsections. To give an overview on what CommandAPI argument suggestions can do:</p>
<ul>
<li>Provide a list of suggestions</li>
<li>Provide a list of suggestions depending on the command sender</li>
<li>Provide a list of suggestions based on what the player has already typed in the command</li>
<li>Provide a list of suggestions asynchronously</li>
<li>Provide a list of suggestions with tooltips to guide users on what certain suggestions do</li>
<li>Append suggestions to an existing list of suggestions</li>
</ul>
<hr />
<h2 id="the-argumentsuggestions-interface"><a class="header" href="#the-argumentsuggestions-interface">The <code>ArgumentSuggestions</code> interface</a></h2>
<p>The two methods above require an <code>ArgumentSuggestions</code> object, which is a functional interface that takes in a <code>SuggestionInfo</code> record and the current Brigadier <code>SuggestionsBuilder</code> and returns a <code>CompletableFuture&lt;Suggestions&gt;</code> object. This may sound a bit complicated, but this allows you to implement very powerful suggestions using a combination of the CommandAPI and raw Brigadier API methods. More information about using Brigadier-level suggestions can be found in the <a href="./brigadiersuggestions.html">brigadier suggestions</a> section.</p>
<p>To simplify this, the CommandAPI provides a number of methods to generate suggestions:</p>
<pre><code class="language-java">ArgumentSuggestions strings(String... suggestions);
ArgumentSuggestions strings(Collection&lt;String&gt;);
ArgumentSuggestions strings(Function&lt;SuggestionInfo, String[]&gt; suggestions);
ArgumentSuggestions stringCollection(Function&lt;SuggestionInfo&lt;CommandSender&gt;, Collection&lt;String&gt;&gt;);
ArgumentSuggestions stringsAsync(Function&lt;SuggestionInfo, CompletableFuture&lt;String[]&gt;&gt; suggestions);
ArgumentSuggestions stringCollectionAsync(Function&lt;SuggestionInfo&lt;CommandSender&gt;, CompletableFuture&lt;Collection&lt;String&gt;&gt;&gt;);

ArgumentSuggestions stringsWithTooltips(IStringTooltip... suggestions);
ArgumentSuggestions stringsWithTooltips(Collection&lt;IStringTooltip&gt;);
ArgumentSuggestions stringsWithTooltips(Function&lt;SuggestionInfo, IStringTooltip[]&gt; suggestions);
ArgumentSuggestions stringsWithTooltipsCollection(Function&lt;SuggestionInfo&lt;CommandSender&gt;, Collection&lt;IStringTooltip&gt;&gt;);
ArgumentSuggestions stringsWithTooltipsAsync(Function&lt;SuggestionInfo, CompletableFuture&lt;IStringTooltip[]&gt;&gt; suggestions);
ArgumentSuggestions stringsWithTooltipsCollectionAsync(Function&lt;SuggestionInfo&lt;CommandSender&gt;, CompletableFuture&lt;Collection&lt;IStringTooltip&gt;&gt;&gt;);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-suggestionsinfo-record"><a class="header" href="#the-suggestionsinfo-record">The <code>SuggestionsInfo</code> record</a></h1>
<p>Argument suggestion methods can accept a function which takes in a <code>SuggestionsInfo</code> object and returns a suitable format for suggestions. The <code>SuggestionInfo</code> class is a record which contains the following methods:</p>
<pre><code class="language-java">public record SuggestionInfo {
    CommandSender sender();
    CommandArguments previousArgs();
    String currentInput();
    String currentArg();
}
</code></pre>
<p>These methods can be used to aid with providing context-aware suggestions for users. The fields are as follows:</p>
<pre><code class="language-java">CommandSender sender();
</code></pre>
<p><code>sender()</code> represents the command sender which is typing this command and requesting these suggestions. This is normally a <code>Player</code>, but can also be a console command sender if using a Paper server.</p>
<hr />
<pre><code class="language-java">CommandArguments previousArgs();
</code></pre>
<p><code>previousArgs()</code> represents the previously declared arguments, which are parsed and interpreted as if they were being used to execute the command. See <a href="./stringargumentsuggestions.html#suggestions-depending-on-previous-arguments">this example on the string argument suggestions page</a> for an idea of how to utilize this field.</p>
<hr />
<pre><code class="language-java">String currentInput();
</code></pre>
<p><code>currentInput()</code> represents the current input that the command sender has entered. This is effectively everything that they have typed, including the leading <code>/</code> symbol which is required to start a command. If a user is typing <code>/mycommand hellowor¦</code>, the result of <code>currentInput()</code> would be <code>&quot;/mycommand hellowor&quot;</code>.</p>
<hr />
<pre><code class="language-java">String currentArg();
</code></pre>
<p><code>currentArg()</code> represents the current text which the command sender has entered for the argument which you're trying to provide suggestions for. If a user is typing <code>/mycommand hellowor¦</code>, the result of <code>currentArg()</code> would be <code>&quot;hellowor&quot;</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string-argument-suggestions"><a class="header" href="#string-argument-suggestions">String argument suggestions</a></h1>
<h2 id="suggestions-with-a-string-array"><a class="header" href="#suggestions-with-a-string-array">Suggestions with a String Array</a></h2>
<p>The first method, <code>replaceSuggestions(ArgumentSuggestions suggestions)</code>, allows you to <em>replace</em> the suggestions normally associated with that argument. This can be replaced with an array of strings by using the <code>strings(String... suggestions)</code> method.</p>
<div class="example">
<h3 id="example---teleport-to-worlds-by-replacing-suggestions"><a class="header" href="#example---teleport-to-worlds-by-replacing-suggestions">Example - Teleport to worlds by replacing suggestions</a></h3>
<p>Say we're creating a plugin with the ability to teleport to different warps on the server. If we were to retrieve a list of warps, we would be able to replace the suggestions of a typical <code>StringArgument</code> to teleport to that warp. Let's create a command with the following syntax:</p>
<pre><code class="language-mccmd">/warp &lt;warp&gt;
</code></pre>
<p>We then implement our warp teleporting command using <code>replaceSuggestions()</code> on the <code>StringArgument</code> to provide a list of warps to teleport to:</p>
<div class="multi-pre">
<pre><code class="language-java Java">List&lt;Argument&lt;?&gt;&gt; arguments = new ArrayList&lt;&gt;();
arguments.add(new StringArgument(&quot;world&quot;).replaceSuggestions(ArgumentSuggestions.strings( 
    &quot;northland&quot;, &quot;eastland&quot;, &quot;southland&quot;, &quot;westland&quot;
)));

new CommandAPICommand(&quot;warp&quot;)
    .withArguments(arguments)
    .executesPlayer((player, args) -&gt; {
        String warp = (String) args.get(&quot;world&quot;);
        player.teleport(warps.get(warp)); // Look up the warp in a map, for example
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">val arguments = listOf&lt;Argument&lt;*&gt;&gt;(
    StringArgument(&quot;world&quot;).replaceSuggestions(ArgumentSuggestions.strings(
        &quot;northland&quot;, &quot;eastland&quot;, &quot;southland&quot;, &quot;westland&quot;
    ))
)

CommandAPICommand(&quot;warp&quot;)
    .withArguments(arguments)
    .executesPlayer(PlayerCommandExecutor { player, args -&gt;
        val warp = args[&quot;world&quot;] as String
        player.teleport(warps[warp]!!) // Look up the warp in a map, for example
    })
    .register()
</code></pre>
</div>
</div>
<p>The second method, <code>includeSuggestions(ArgumentSuggestions suggestions)</code>, allows you to <em>include</em> additional suggestions in combination with the list of existing suggestions for a command.</p>
<hr />
<h2 id="suggestions-depending-on-a-command-sender"><a class="header" href="#suggestions-depending-on-a-command-sender">Suggestions depending on a command sender</a></h2>
<p>The <code>strings(Function&lt;SuggestionInfo, String[]&gt; suggestions)</code> method in <code>ArgumentSuggestions</code> allows you to modify suggestions normally associated with that argument with an array of strings that are evaluated dynamically using information about the command sender, using the <code>sender()</code> method.</p>
<div class="example">
<h3 id="example---friend-list-by-replacing-suggestions"><a class="header" href="#example---friend-list-by-replacing-suggestions">Example - Friend list by replacing suggestions</a></h3>
<p>Say you have a plugin which has a &quot;friend list&quot; for players. If you want to teleport to a friend in that list, you could use a <code>PlayerArgument</code>, which has the list of suggestions replaced with the list of friends that that player has. Since the list of friends <em>depends on the sender</em>, we can use the function to determine what our suggestions should be. Let's use the following command to teleport to a friend from our friend list:</p>
<pre><code class="language-mccmd">/friendtp &lt;friend&gt;
</code></pre>
<p>Let's say we have a simple class to get the friends of a command sender:</p>
<div class="multi-pre">
<pre><code class="language-java Java">public class Friends {
    
    static Map&lt;UUID, String[]&gt; friendsMap = new HashMap&lt;&gt;();
    
    public static String[] getFriends(CommandSender sender) {
        if (sender instanceof Player player) {
            // Look up friends in a database or file
            return friendsMap.get(player.getUniqueId());
        } else {
            return new String[0];
        }
    }
}
</code></pre>
<pre><code class="language-kotlin Kotlin">class Friends {

    companion object {

        val friends = mutableMapOf&lt;UUID, Array&lt;String&gt;&gt;()

        fun getFriends(sender: CommandSender): Array&lt;String&gt; {
            if (sender is Player) {
                // Look up friends in a database or file
                return friends[sender.uniqueId]!!
            } else {
                return arrayOf&lt;String&gt;()
            }
        }

    }

}
</code></pre>
</div>
<p>We can then use this to generate our suggested list of friends:</p>
<div class="multi-pre">
<pre><code class="language-java Java">List&lt;Argument&lt;?&gt;&gt; arguments = new ArrayList&lt;&gt;();
arguments.add(new PlayerArgument(&quot;friend&quot;).replaceSuggestions(ArgumentSuggestions.strings(info -&gt;
    Friends.getFriends(info.sender())
)));

new CommandAPICommand(&quot;friendtp&quot;)
    .withArguments(arguments)
    .executesPlayer((player, args) -&gt; {
        Player target = (Player) args.get(&quot;friend&quot;);
        player.teleport(target);
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">val arguments = listOf&lt;Argument&lt;*&gt;&gt;(
    PlayerArgument(&quot;friend&quot;).replaceSuggestions(ArgumentSuggestions.strings { info -&gt;
        Friends.getFriends(info.sender())
    } )
)

CommandAPICommand(&quot;friendtp&quot;)
    .withArguments(arguments)
    .executesPlayer(PlayerCommandExecutor { player, args -&gt;
        val target = args[&quot;friend&quot;] as Player
        player.teleport(target)
    })
    .register()
</code></pre>
</div>
</div>
<hr />
<h2 id="suggestions-depending-on-previous-arguments"><a class="header" href="#suggestions-depending-on-previous-arguments">Suggestions depending on previous arguments</a></h2>
<p>The <code>strings(Function&lt;SuggestionInfo, String[]&gt;)</code> method also has the capability to suggest arguments based on the values of previously inputted arguments, using the <code>previousArgs()</code> method in <code>SuggestionInfo</code>. This <code>previousArgs()</code> method returns a <strong>list of previous arguments</strong> which are parsed exactly like any regular CommandAPI command argument.</p>
<div class="warning">
<p><strong>Note:</strong></p>
<p>The ability to use previously declared arguments <em>does not work via redirects</em>. This means that any command that comes before it that leads into a command that uses suggestions depending on previous arguments will not work. For example, if we had a command <code>/mycommand &lt;arg1&gt; &lt;arg2&gt; &lt;arg3&gt;</code> and ran it as normal, it would work as normal:</p>
<pre><code class="language-mccmd">/mycommand arg1 arg2 arg3
</code></pre>
<p>However, if we redirect execution via the <code>/execute</code> command to have the following:</p>
<pre><code class="language-mccmd">/execute run mycommand &lt;suggestions&gt;
</code></pre>
<p>This won't work, because we make use of a redirect:</p>
<p>\(\texttt{/execute run} \xrightarrow{redirect} \texttt{mycommand arg1 arg2 arg3}\)</p>
<p>It is not possible to access the <a href="./commandarguments.html"><code>CommandArguments</code></a> of previously declared arguments. <strong>If a command occurs via a redirect, the <a href="./commandarguments.html"><code>CommandArguments</code></a> of previously declared arguments will be null</strong>.</p>
</div>
<div class="example">
<h3 id="example---sending-a-message-to-a-nearby-player"><a class="header" href="#example---sending-a-message-to-a-nearby-player">Example - Sending a message to a nearby player</a></h3>
<p>Say we wanted to create a command that lets you send a message to a specific player in a given radius. <em>(This is a bit of a contrived example, but let's roll with it)</em>. To do this, we'll use the following command syntax:</p>
<pre><code class="language-mccmd">/localmsg &lt;radius&gt; &lt;target&gt; &lt;message&gt;
</code></pre>
<p>When run, this command will send a message to a target player within the provided radius. To help identify which players are within a radius, we can replace the suggestions on the <code>&lt;target&gt;</code> argument to include a list of players within the provided radius. We do this with the following code:</p>
<div class="multi-pre">
<pre><code class="language-java Java">// Declare our arguments as normal
List&lt;Argument&lt;?&gt;&gt; commandArgs = new ArrayList&lt;&gt;();
commandArgs.add(new IntegerArgument(&quot;radius&quot;));

// Replace the suggestions for the PlayerArgument.
// info.sender() refers to the command sender that is running this command
// info.previousArgs() refers to the Object[] of previously declared arguments (in this case, the IntegerArgument radius)
commandArgs.add(new PlayerArgument(&quot;target&quot;).replaceSuggestions(ArgumentSuggestions.strings(info -&gt; {

    // Cast the first argument (radius, which is an IntegerArgument) to get its value
    int radius = (int) info.previousArgs().get(&quot;radius&quot;);
    
    // Get nearby entities within the provided radius
    Player player = (Player) info.sender();
    Collection&lt;Entity&gt; entities = player.getWorld().getNearbyEntities(player.getLocation(), radius, radius, radius);
    
    // Get player names within that radius
    return entities.stream()
        .filter(e -&gt; e.getType() == EntityType.PLAYER)
        .map(Entity::getName)
        .toArray(String[]::new);
})));
commandArgs.add(new GreedyStringArgument(&quot;message&quot;));

// Declare our command as normal
new CommandAPICommand(&quot;localmsg&quot;)
    .withArguments(commandArgs)
    .executesPlayer((player, args) -&gt; {
        Player target = (Player) args.get(&quot;target&quot;);
        String message = (String) args.get(&quot;message&quot;);
        target.sendMessage(message);
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">// Declare our arguments as normal
val commandArgs = mutableListOf&lt;Argument&lt;*&gt;&gt;()
commandArgs.add(IntegerArgument(&quot;radius&quot;))

// Replace the suggestions for the PlayerArgument.
// info.sender() refers to the command sender that is running this command
// info.previousArgs() refers to the Object[] of previously declared arguments (in this case, the IntegerArgument radius)
commandArgs.add(PlayerArgument(&quot;target&quot;).replaceSuggestions(ArgumentSuggestions.strings { info: SuggestionInfo&lt;CommandSender&gt; -&gt;

    // Cast the first argument (radius, which is an IntegerArgument) to get its value
    val radius = (info.previousArgs()[&quot;radius&quot;] as Int).toDouble()

    // Get nearby entities within the provided radius
    val player = info.sender() as Player
    val entities = player.world.getNearbyEntities(player.location, radius, radius, radius)

    // Get player names within that radius
    entities
        .filter { it.type == EntityType.PLAYER }
        .map { it.name }
        .toTypedArray()
}))
commandArgs.add(GreedyStringArgument(&quot;message&quot;))

// Declare our command as normal
CommandAPICommand(&quot;localmsg&quot;)
    .withArguments(*commandArgs.toTypedArray())
    .executesPlayer(PlayerCommandExecutor { _, args -&gt;
        val target = args[&quot;target&quot;] as Player
        val message = args[&quot;message&quot;] as String
        target.sendMessage(message)
    })
    .register()
</code></pre>
</div>
<p>As shown in this code, we use the <code>previousArgs()</code> method access the previously declared arguments. In this example, <code>info.previousArgs()</code> will be <code>{ int }</code>, where this <code>int</code> refers to the radius. Note how this object array only has the previously declared arguments (and not for example <code>{ int, Player, String }</code>).</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="safely-typed-argument-suggestions"><a class="header" href="#safely-typed-argument-suggestions">Safely typed argument suggestions</a></h1>
<p>So far, we've covered how to replace suggestions using the <code>replaceSuggestions()</code> method. The issue with using strings for suggestion listings is that they are prone to errors - it is possible to suggest something which is not actually a valid argument, which makes that suggestion unusable. As a result, some arguments include the <code>replaceSafeSuggestions()</code>, which provides type-safety checks for argument suggestions, as well as automatic &quot;Bukkit-to-suggestion&quot; conversion.</p>
<p>The whole point of the safe argument suggestions method is that parameters entered in this method are <strong>guaranteed</strong> to work.</p>
<p>The use of the safe replace suggestions function is the same as <code>replaceSuggestions()</code> from the previous section, except instead of returning a <code>String[]</code>, you now return a <code>T[]</code>, where <code>T</code> is the class corresponding to the argument. This is described in more detail in the table below.</p>
<pre><code class="language-java">Argument replaceSafeSuggestions(SafeSuggestions&lt;T&gt; suggestions);
Argument includeSafeSuggestions(SafeSuggestions&lt;T&gt; suggestions);
</code></pre>
<hr />
<h2 id="the-safesuggestions-interface"><a class="header" href="#the-safesuggestions-interface">The <code>SafeSuggestions</code> interface</a></h2>
<p>Similar to the <a href="./argumentsuggestions.html#the-argumentsuggestions-interface"><code>ArgumentSuggestions</code> interface</a>, safe suggestions use the <code>SafeSuggestions</code> interface which is a functional interface that takes in a mapping function from an Object to a String and returns some <code>ArgumentSuggestions</code> which represent the argument's suggestions. Again, this is typically implemented for anyone that wants to use a more powerful suggestion system.</p>
<p>As with <code>ArgumentSuggestions</code>, the CommandAPI provides some methods to generate safe suggestions:</p>
<pre><code class="language-java">SafeSuggestions&lt;T&gt; suggest(T... suggestions);
SafeSuggestions&lt;T&gt; suggest(Function&lt;SuggestionInfo, T[]&gt; suggestions);
SafeSuggestions&lt;T&gt; suggestAsync(Function&lt;SuggestionInfo, CompletableFuture&lt;T[]&gt;&gt; suggestions);

SafeSuggestions&lt;T&gt; tooltips(Tooltip&lt;T&gt;... suggestions);
SafeSuggestions&lt;T&gt; tooltips(Function&lt;SuggestionInfo, Tooltip&lt;T&gt;[]&gt; suggestions);
SafeSuggestions&lt;T&gt; tooltipsAsync(Function&lt;SuggestionInfo, CompletableFuture&lt;Tooltip&lt;T&gt;[]&gt;&gt; suggestions);
</code></pre>
<hr />
<h2 id="supported-arguments"><a class="header" href="#supported-arguments">Supported arguments</a></h2>
<p>Not all arguments support safe suggestions. This is mostly due to implementation constraints or inadequate support by the Bukkit API.</p>
<p>The list of supported arguments are displayed in the following table. The parameter <code>T</code> (shown in the method signatures above) are also provided for each argument. This parameter is the same as the cast argument described in <a href="./arguments.html#argument-casting">Argument Casting</a>, except for a few exceptions which are outlined in <strong>bold</strong>.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: right">Argument</th><th style="text-align: left">Class (T)</th></tr></thead><tbody>
<tr><td style="text-align: right"><a href="./advancementargument.html"><code>AdvancementArgument</code></a></td><td style="text-align: left"><code>org.bukkit.advancement.Advancement</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_axis.html"><code>AxisArgument</code></a></td><td style="text-align: left"><code>java.util.EnumSet&lt;org.bukkit.Axis&gt;</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_biome.html"><code>BiomeArgument</code></a></td><td style="text-align: left"><code>org.bukkit.block.Biome</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_primitives.html#boolean-arguments"><code>BooleanArgument</code></a></td><td style="text-align: left"><strong><code>Boolean</code></strong></td></tr>
<tr><td style="text-align: right"><a href="./argument_chats.html#chat-color-argument"><code>ChatColorArgument</code></a></td><td style="text-align: left"><code>org.bukkit.ChatColor</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_primitives.html#numerical-arguments"><code>DoubleArgument</code></a></td><td style="text-align: left"><strong><code>Double</code></strong></td></tr>
<tr><td style="text-align: right"><a href="./argument_enchantment.html"><code>EnchantmentArgument</code></a></td><td style="text-align: left"><code>org.bukkit.enchantments.Enchantment</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_entities.html#entity-type-argument"><code>EntityTypeArgument</code></a></td><td style="text-align: left"><code>org.bukkit.entity.EntityType</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_primitives.html#numerical-arguments"><code>FloatArgument</code></a></td><td style="text-align: left"><strong><code>Float</code></strong></td></tr>
<tr><td style="text-align: right"><a href="./argument_range.html#the-integerrange--floatrange-class"><code>FloatRangeArgument</code></a></td><td style="text-align: left"><code>dev.jorel.commandapi.wrappers.FloatRange</code></td></tr>
<tr><td style="text-align: right"><a href="./functionwrapper.html"><code>FunctionArgument</code></a></td><td style="text-align: left"><strong><code>org.bukkit.NamespacedKey</code></strong></td></tr>
<tr><td style="text-align: right"><a href="./argument_strings.html#greedy-string-argument"><code>GreedyStringArgument</code></a></td><td style="text-align: left"><code>String</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_primitives.html#numerical-arguments"><code>IntegerArgument</code></a></td><td style="text-align: left"><strong><code>Integer</code></strong></td></tr>
<tr><td style="text-align: right"><a href="./argument_range.html#the-integerrange--floatrange-class"><code>IntegerRangeArgument</code></a></td><td style="text-align: left"><code>dev.jorel.commandapi.wrappers.IntegerRange</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_itemstack.html"><code>ItemStackArgument</code></a></td><td style="text-align: left"><code>org.bukkit.inventory.ItemStack</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_locations.html#location-2d-space"><code>Location2DArgument</code></a></td><td style="text-align: left"><code>dev.jorel.commandapi.wrappers.Location2D</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_locations.html#location-3d-space"><code>LocationArgument</code></a></td><td style="text-align: left"><code>org.bukkit.Location</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_primitives.html#numerical-arguments"><code>LongArgument</code></a></td><td style="text-align: left"><strong><code>Long</code></strong></td></tr>
<tr><td style="text-align: right"><a href="./argument_loottable.html"><code>LootTableArgument</code></a></td><td style="text-align: left"><code>org.bukkit.loot.LootTable</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_mathoperation.html"><code>MathOperationArgument</code></a></td><td style="text-align: left"><code>dev.jorel.commandapi.wrappers.MathOperation</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_nbt.html"><code>NBTCompoundArgument</code></a></td><td style="text-align: left"><code>de.tr7zw.nbtapi.NBTContainer</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_objectives.html#objective-argument"><code>ObjectiveArgument</code></a></td><td style="text-align: left"><strong><code>org.bukkit.scoreboard.Objective</code></strong></td></tr>
<tr><td style="text-align: right"><a href="./argument_entities.html#player-argument"><code>OfflinePlayerArgument</code></a></td><td style="text-align: left"><code>org.bukkit.OfflinePlayer</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_particles.html"><code>ParticleArgument</code></a></td><td style="text-align: left"><code>org.bukkit.Particle</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_entities.html#player-argument"><code>PlayerArgument</code></a></td><td style="text-align: left"><code>org.bukkit.entity.Player</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_potion.html"><code>PotionEffectArgument</code></a></td><td style="text-align: left"><code>org.bukkit.potion.PotionEffectType</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_recipe.html"><code>RecipeArgument</code></a></td><td style="text-align: left"><code>org.bukkit.inventory.Recipe</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_rotation.html"><code>RotationArgument</code></a></td><td style="text-align: left"><code>dev.jorel.commandapi.wrappers.Rotation</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_scoreboards.html#scoreboard-slot-argument"><code>ScoreboardSlotArgument</code></a></td><td style="text-align: left"><code>dev.jorel.commandapi.wrappers.ScoreboardSlot</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_sound.html"><code>SoundArgument</code></a></td><td style="text-align: left"><code>org.bukkit.Sound</code></td></tr>
<tr><td style="text-align: right"><a href="./argument_team.html"><code>TeamArgument</code></a></td><td style="text-align: left"><strong><code>org.bukkit.scoreboard.Team</code></strong></td></tr>
<tr><td style="text-align: right"><a href="./argument_time.html"><code>TimeArgument</code></a></td><td style="text-align: left"><strong><code>dev.jorel.commandapi.wrappers.Time</code></strong></td></tr>
<tr><td style="text-align: right"><a href="./argument_world.html"><code>WorldArgument</code></a></td><td style="text-align: left"><code>org.bukkit.World</code></td></tr>
</tbody></table>
</div>
<hr />
<h2 id="safe-time-arguments"><a class="header" href="#safe-time-arguments">Safe time arguments</a></h2>
<p>While most of the arguments are fairly straight forward, I'd like to bring your attention to the <code>TimeArgument</code>'s safe suggestions function. This uses <code>dev.jorel.commandapi.wrappers.Time</code> as the class for <code>T</code> to ensure type-safety. The <code>Time</code> class has three static methods:</p>
<pre><code class="language-java">Time ticks(int ticks);
Time days(int days);
Time seconds(int seconds);
</code></pre>
<p>These create representations of ticks (e.g. <code>40t</code>), days (e.g. <code>2d</code>) and seconds (e.g. <code>60s</code>) respectively.</p>
<hr />
<h2 id="safe-function-arguments"><a class="header" href="#safe-function-arguments">Safe function arguments</a></h2>
<p>Although all safe arguments are indeed &quot;type-safe&quot;, the function argument uses a <code>NamespacedKey</code> which cannot be checked fully at compile time. As a result, this is argument should be used with caution - providing a <code>NamespacedKey</code> suggestion that does not exist when the server is running will cause that command to fail if that suggestion is used.</p>
<hr />
<h2 id="safe-scoreboard-slot-arguments"><a class="header" href="#safe-scoreboard-slot-arguments">Safe scoreboard slot arguments</a></h2>
<p>Scoreboard slots now include two new static methods so they can be used with safe arguments:</p>
<pre><code class="language-java">ScoreboardSlot of(DisplaySlot slot);
ScoreboardSlot ofTeamColor(ChatColor color);
</code></pre>
<p>This allows you to create <code>ScoreboardSlot</code> instances which can be used with the safe replace suggestions method.</p>
<hr />
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>While this should be fairly straight forward, here's a few examples of how this can be used in practice:</p>
<div class="example">
<h3 id="example---safe-recipe-arguments"><a class="header" href="#example---safe-recipe-arguments">Example - Safe recipe arguments</a></h3>
<p>Say we have a plugin that registers custom items which can be crafted. In this example, we use an &quot;emerald sword&quot; with a custom crafting recipe. Now say that we want to have a command that gives the player the item from our declared recipes, which will have the following syntax:</p>
<pre><code class="language-mccmd">/giverecipe &lt;recipe&gt;
</code></pre>
<p>To do this, we first register our custom items:</p>
<div class="multi-pre">
<pre><code class="language-java Java">// Create our itemstack
ItemStack emeraldSword = new ItemStack(Material.DIAMOND_SWORD);
ItemMeta meta = emeraldSword.getItemMeta();
meta.setDisplayName(&quot;Emerald Sword&quot;);
meta.setUnbreakable(true);
emeraldSword.setItemMeta(meta);

// Create and register our recipe
ShapedRecipe emeraldSwordRecipe = new ShapedRecipe(new NamespacedKey(this, &quot;emerald_sword&quot;), emeraldSword);
emeraldSwordRecipe.shape(
    &quot;AEA&quot;, 
    &quot;AEA&quot;, 
    &quot;ABA&quot;
);
emeraldSwordRecipe.setIngredient('A', Material.AIR);
emeraldSwordRecipe.setIngredient('E', Material.EMERALD);
emeraldSwordRecipe.setIngredient('B', Material.BLAZE_ROD);
getServer().addRecipe(emeraldSwordRecipe);

// Omitted, more itemstacks and recipes
</code></pre>
<pre><code class="language-kotlin Kotlin">// Create our itemstack
val emeraldSword = ItemStack(Material.DIAMOND_SWORD)
val meta = emeraldSword.itemMeta
meta?.setDisplayName(&quot;Emerald Sword&quot;)
meta?.isUnbreakable = true
emeraldSword.itemMeta = meta

// Create and register our recipe
val emeraldSwordRecipe = ShapedRecipe(NamespacedKey(this, &quot;emerald_sword&quot;), emeraldSword)
emeraldSwordRecipe.shape(
    &quot;AEA&quot;,
    &quot;AEA&quot;,
    &quot;ABA&quot;
)
emeraldSwordRecipe.setIngredient('A', Material.AIR)
emeraldSwordRecipe.setIngredient('E', Material.EMERALD)
emeraldSwordRecipe.setIngredient('B', Material.BLAZE_ROD)
server.addRecipe(emeraldSwordRecipe)

// Omitted, more itemstacks and recipes
</code></pre>
</div>
<p>Once we've done that, we can now include them in our command registration. To do this, we use <code>replaceSafeSuggestions(recipes)</code> and then register our command as normal:</p>
<div class="multi-pre">
<pre><code class="language-java Java">// Safely override with the recipe we've defined
List&lt;Argument&lt;?&gt;&gt; arguments = new ArrayList&lt;&gt;();
arguments.add(new RecipeArgument(&quot;recipe&quot;).replaceSafeSuggestions(SafeSuggestions.suggest(info -&gt; 
    new Recipe[] { emeraldSwordRecipe, /* Other recipes here */ }
)));

// Register our command
new CommandAPICommand(&quot;giverecipe&quot;)
    .withArguments(arguments)
    .executesPlayer((player, args) -&gt; {
        Recipe recipe = (Recipe) args.get(&quot;recipe&quot;);
        player.getInventory().addItem(recipe.getResult());
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">// Safely override with the recipe we've defined
val arguments = listOf&lt;Argument&lt;*&gt;&gt;(
    RecipeArgument(&quot;recipe&quot;).replaceSafeSuggestions(SafeSuggestions.suggest {
        arrayOf(emeraldSwordRecipe, /* Other recipes here */)
    })
)

// Register our command
CommandAPICommand(&quot;giverecipe&quot;)
    .withArguments(arguments)
    .executesPlayer(PlayerCommandExecutor { player, args -&gt;
        val recipe = args[&quot;recipe&quot;] as Recipe
        player.inventory.addItem(recipe.result)
    })
    .register()
</code></pre>
</div>
</div>
<div class="example">
<h3 id="example---safe-spawnmob-suggestions"><a class="header" href="#example---safe-spawnmob-suggestions">Example - Safe /spawnmob suggestions</a></h3>
<p>Say we have a command to spawn mobs:</p>
<pre><code class="language-mccmd">/spawnmob &lt;mob&gt;
</code></pre>
<p>Now say that we don't want non-op players to spawn bosses. To do this, we'll create a <code>List&lt;EntityType&gt;</code> which is the list of all mobs that non-ops are allowed to spawn:</p>
<div class="multi-pre">
<pre><code class="language-java Java">EntityType[] forbiddenMobs = new EntityType[] {EntityType.ENDER_DRAGON, EntityType.WITHER};
List&lt;EntityType&gt; allowedMobs = new ArrayList&lt;&gt;(Arrays.asList(EntityType.values()));
allowedMobs.removeAll(Arrays.asList(forbiddenMobs)); // Now contains everything except enderdragon and wither
</code></pre>
<pre><code class="language-kotlin Kotlin">val forbiddenMobs = listOf&lt;EntityType&gt;(EntityType.ENDER_DRAGON, EntityType.WITHER)
val allowedMobs = EntityType.values().toMutableList()
allowedMobs.removeAll(forbiddenMobs) // Now contains everything except enderdragon and wither
</code></pre>
</div>
<p>We then use our safe arguments to return an <code>EntityType[]</code> as the list of values that are suggested to the player. In this example, we use the <code>sender()</code> method to determine if the sender has permissions to view the suggestions:</p>
<div class="multi-pre">
<pre><code class="language-java Java">List&lt;Argument&lt;?&gt;&gt; safeArguments = new ArrayList&lt;&gt;();
safeArguments.add(new EntityTypeArgument(&quot;mob&quot;).replaceSafeSuggestions(SafeSuggestions.suggest(
    info -&gt; {
        if (info.sender().isOp()) {
            // All entity types
            return EntityType.values();
        } else {
            // Only allowedMobs
            return allowedMobs.toArray(new EntityType[0]);
        }
    })
));
</code></pre>
<pre><code class="language-kotlin Kotlin">val safeArguments = listOf&lt;Argument&lt;*&gt;&gt;(
    EntityTypeArgument(&quot;mob&quot;).replaceSafeSuggestions(SafeSuggestions.suggest {
        info -&gt;
            if (info.sender().isOp) {
                // All entity types
                EntityType.values()
            } else {
                // Only allowedMobs
                allowedMobs.toTypedArray()
            }
        }
    )
)
</code></pre>
</div>
<p>Now we register our command as normal:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;spawnmob&quot;)
    .withArguments(safeArguments)
    .executesPlayer((player, args) -&gt; {
        EntityType entityType = (EntityType) args.get(&quot;mob&quot;);
        player.getWorld().spawnEntity(player.getLocation(), entityType);
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;spawnmob&quot;)
    .withArguments(safeArguments)
    .executesPlayer(PlayerCommandExecutor { player, args -&gt;
        val entityType = args[&quot;mob&quot;] as EntityType
        player.world.spawnEntity(player.location, entityType)
    })
    .register()
</code></pre>
</div>
</div>
<div class="example">
<h3 id="example---removing-a-potion-effect-from-a-player"><a class="header" href="#example---removing-a-potion-effect-from-a-player">Example - Removing a potion effect from a player</a></h3>
<p>Say we wanted to remove a potion effect from a player. To do this, we'll use the following command syntax:</p>
<pre><code class="language-mccmd">/removeeffect &lt;player&gt; &lt;potioneffect&gt;
</code></pre>
<p>Now, we don't want to remove a potion effect that doesn't exist on a player, so instead we'll use the safe arguments to find a list of potion effects on the target player and then only suggest those potion effects. To do this, we'll use the <code>previousArguments()</code> method, as it allows us to access the previously defined <code>&lt;player&gt;</code> argument.</p>
<div class="multi-pre">
<pre><code class="language-java Java">List&lt;Argument&lt;?&gt;&gt; safeArgs = new ArrayList&lt;&gt;();
safeArgs.add(new EntitySelectorArgument.OnePlayer(&quot;target&quot;));
safeArgs.add(new PotionEffectArgument(&quot;potioneffect&quot;).replaceSafeSuggestions(SafeSuggestions.suggest(
    info -&gt; {
        Player target = (Player) info.previousArgs().get(0);
        
        // Convert PotionEffect[] into PotionEffectType[]
        return target.getActivePotionEffects().stream()
            .map(PotionEffect::getType)
            .toArray(PotionEffectType[]::new);
    })
));
</code></pre>
<pre><code class="language-kotlin Kotlin">val safeArgs = mutableListOf&lt;Argument&lt;*&gt;&gt;()
safeArgs.add(EntitySelectorArgument.OnePlayer(&quot;target&quot;))
safeArgs.add(PotionEffectArgument(&quot;potioneffect&quot;).replaceSafeSuggestions(SafeSuggestions.suggest {
    info -&gt;
        val target = info.previousArgs()[&quot;target&quot;] as Player

        // Convert PotionEffect[] into PotionEffectType[]
        target.activePotionEffects.map{ it.type }.toTypedArray()
    })
)
</code></pre>
</div>
<p>And then we can register our command as normal:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;removeeffect&quot;)
    .withArguments(safeArgs)
    .executesPlayer((player, args) -&gt; {
        Player target = (Player) args.get(&quot;target&quot;);
        PotionEffectType potionEffect = (PotionEffectType) args.get(&quot;potioneffect&quot;);
        target.removePotionEffect(potionEffect);
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;removeeffect&quot;)
    .withArguments(safeArgs)
    .executesPlayer(PlayerCommandExecutor { _, args -&gt;
        val target = args[&quot;target&quot;] as Player
        val potionEffect = args[&quot;potioneffect&quot;] as PotionEffectType
        target.removePotionEffect(potionEffect)
    })
    .register()
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="argument-suggestions-with-tooltips"><a class="header" href="#argument-suggestions-with-tooltips">Argument suggestions with tooltips</a></h1>
<p><img src="./images/warps.gif" alt="A /warp command with suggestions of various locations. Hovering over the suggestions with the mouse cursor displays tooltips describing what the locations are" /></p>
<p>The CommandAPI can also display tooltips for specific argument suggestions. These are shown to the user when they hover over a given suggestion and can be used to provide more context to a user about the suggestions that are shown to them. In this section, we'll outline the two ways of creating suggestions with tooltips:</p>
<ul>
<li>Normal (String) suggestions with tooltips</li>
<li>Safely typed suggestions with tooltips</li>
</ul>
<p>Tooltips <em>can</em> have formatting to change how the text is displayed by using the <code>ChatColor</code> class.</p>
<hr />
<h2 id="tooltips-with-normal-string-based-suggestions"><a class="header" href="#tooltips-with-normal-string-based-suggestions">Tooltips with normal (String-based) suggestions</a></h2>
<p>To use these features, the CommandAPI includes the <code>stringsWithTooltips</code> methods for arguments, that accept <code>IStringTooltip</code> objects instead of <code>String</code> objects:</p>
<pre><code class="language-java">ArgumentSuggestions stringsWithTooltips(IStringTooltip... suggestions);
ArgumentSuggestions stringsWithTooltips(Function&lt;SuggestionInfo, IStringTooltip[]&gt; suggestions);
</code></pre>
<p>The <code>StringTooltip</code> class is the CommandAPI's default implementation of <code>IStringTooltip</code>, which has some static methods to construct tooltips easily:</p>
<pre><code class="language-java">StringTooltip none(String suggestion);
StringTooltip ofString(String suggestion, String tooltip);
StringTooltip ofMessage(String suggestion, Message tooltip);
StringTooltip ofBaseComponents(String suggestion, BaseComponent... tooltip);
StringTooltip ofAdventureComponent(String suggestion, Component tooltip);
</code></pre>
<p>The first method, <code>StringTooltip.none(String)</code> creates a normal suggestion entry with no tooltip. The other methods create a suggestion with the provided tooltip text in either <code>String</code>, Brigadier <code>Message</code>, Spigot <code>BaseComponent[]</code> or Adventure <code>Component</code> format.</p>
<div class="example">
<h3 id="example---an-emotes-command-with-string-suggestion-tooltips"><a class="header" href="#example---an-emotes-command-with-string-suggestion-tooltips">Example - An emotes command with string suggestion tooltips</a></h3>
<p>Say we want to create a simple command to provide in-game emotes between players. For example, if you did <code>/emote wave Bob</code>, you'll &quot;wave&quot; to the player <em>Bob</em>. For this example, we'll use the following command syntax:</p>
<pre><code class="language-mccmd">/emote &lt;emote&gt; &lt;target&gt;
</code></pre>
<p>First, we'll declare our arguments. Here, we'll use the <code>stringsWithTooltips</code> method, along with the <code>StringTooltip.ofString(String, String)</code> method to create emote suggestions and include suitable descriptions:</p>
<div class="multi-pre">
<pre><code class="language-java Java">List&lt;Argument&lt;?&gt;&gt; arguments = new ArrayList&lt;&gt;();
arguments.add(new StringArgument(&quot;emote&quot;)
    .replaceSuggestions(ArgumentSuggestions.stringsWithTooltips(info -&gt;
        new IStringTooltip[] {
            StringTooltip.ofString(&quot;wave&quot;, &quot;Waves at a player&quot;),
            StringTooltip.ofString(&quot;hug&quot;, &quot;Gives a player a hug&quot;),
            StringTooltip.ofString(&quot;glare&quot;, &quot;Gives a player the death glare&quot;)
        }
    ))
);
arguments.add(new PlayerArgument(&quot;target&quot;));
</code></pre>
<pre><code class="language-kotlin Kotlin">val arguments = mutableListOf&lt;Argument&lt;*&gt;&gt;()
arguments.add(StringArgument(&quot;emote&quot;)
    .replaceSuggestions(ArgumentSuggestions.stringsWithTooltips { info -&gt;
        arrayOf&lt;IStringTooltip&gt;(
            StringTooltip.ofString(&quot;wave&quot;, &quot;Waves at a player&quot;),
            StringTooltip.ofString(&quot;hug&quot;, &quot;Gives a player a hug&quot;),
            StringTooltip.ofString(&quot;glare&quot;, &quot;Gives a player the death glare&quot;)
        )
    })
)
arguments.add(PlayerArgument(&quot;target&quot;))
</code></pre>
</div>
<p>Finally, we declare our command as normal:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;emote&quot;)
    .withArguments(arguments)
    .executesPlayer((player, args) -&gt; {
        String emote = (String) args.get(&quot;emote&quot;);
        Player target = (Player) args.get(&quot;target&quot;);
        
        switch (emote) {
        case &quot;wave&quot;:
            target.sendMessage(player.getName() + &quot; waves at you!&quot;);
            break;
        case &quot;hug&quot;:
            target.sendMessage(player.getName() + &quot; hugs you!&quot;);
            break;
        case &quot;glare&quot;:
            target.sendMessage(player.getName() + &quot; gives you the death glare...&quot;);
            break;
        default:
            player.sendMessage(&quot;Invalid emote '&quot; + emote + &quot;'!&quot;);
            break;
        }
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;emote&quot;)
    .withArguments(*arguments.toTypedArray())
    .executesPlayer(PlayerCommandExecutor { player, args -&gt;
        val emote = args[&quot;emote&quot;] as String
        val target = args[&quot;target&quot;] as Player

        when (emote) {
            &quot;wave&quot; -&gt; target.sendMessage(&quot;${player.name} waves at you!&quot;)
            &quot;hug&quot; -&gt; target.sendMessage(&quot;${player.name} hugs you!&quot;)
            &quot;glare&quot; -&gt; target.sendMessage(&quot;${player.name} gives you the death glare...&quot;)
        }
    })
    .register()
</code></pre>
</div>
</div>
<hr />
<h2 id="using-istringtooltip-directly"><a class="header" href="#using-istringtooltip-directly">Using <code>IStringTooltip</code> directly</a></h2>
<p>The <code>IStringTooltip</code> interface can be implemented by any other class to provide tooltips for custom objects. The <code>IStringTooltip</code> interface has the following methods:</p>
<pre><code class="language-java">public interface IStringTooltip {
    public String getSuggestion();
    public Message getTooltip();
}
</code></pre>
<blockquote>
<p>Note that the <code>Message</code> class is from the Brigadier library, which you will have to add as a dependency to your plugin. Information on how to do that can be found <a href="https://github.com/Mojang/brigadier#installation">here</a>.</p>
</blockquote>
<p>This is incredibly useful if you are using suggestions with custom objects, such as a plugin that has custom items.</p>
<div class="example">
<h3 id="example---using-istringtooltip-for-custom-items"><a class="header" href="#example---using-istringtooltip-for-custom-items">Example - Using <code>IStringTooltip</code> for custom items</a></h3>
<p>Let's say we've created a simple plugin which has custom items. For a custom item, we'll have a simple class <code>CustomItem</code> that sets its name, lore and attached itemstack:</p>
<div class="multi-pre">
<pre><code class="language-java Java">public @SuppressWarnings(&quot;deprecation&quot;)
class CustomItem implements IStringTooltip {

    private ItemStack itemstack;
    private String name;
    
    public CustomItem(ItemStack itemstack, String name, String lore) {
        ItemMeta meta = itemstack.getItemMeta();
        meta.setDisplayName(name);
        meta.setLore(Arrays.asList(lore));
        itemstack.setItemMeta(meta);
        this.itemstack = itemstack;
        this.name = name;
    }
    
    public String getName() {
        return this.name;
    }
    
    public ItemStack getItem() {
        return this.itemstack;
    }
    
    @Override
    public String getSuggestion() {
        return this.itemstack.getItemMeta().getDisplayName();
    }

    @Override
    public Message getTooltip() {
        return BukkitTooltip.messageFromString(this.itemstack.getItemMeta().getLore().get(0));
    }
    
}
</code></pre>
<pre><code class="language-kotlin Kotlin">class CustomItem(val item: ItemStack, val name: String, lore: String): IStringTooltip {

    init {
        val meta = item.itemMeta
        meta.setDisplayName(name)
        meta.lore = listOf(lore)
        item.itemMeta = meta
    }

    override fun getSuggestion(): String = this.item.itemMeta.displayName

    override fun getTooltip(): Message = BukkitTooltip.messageFromString(this.item.itemMeta.lore?.get(0) ?: &quot;&quot;)

}
</code></pre>
</div>
<p>We make use of the <code>Tooltip.messageFromString()</code> method to generate a Brigadier <code>Message</code> object from our string tooltip.</p>
<p>Let's also say that our plugin has registered lots of <code>CustomItem</code>s and has this stored in a <code>CustomItem[]</code> in our plugin. We could then use this as our input for suggestions:</p>
<div class="multi-pre">
<pre><code class="language-java Java">CustomItem[] customItems = new CustomItem[] {
    new CustomItem(new ItemStack(Material.DIAMOND_SWORD), &quot;God sword&quot;, &quot;A sword from the heavens&quot;),
    new CustomItem(new ItemStack(Material.PUMPKIN_PIE), &quot;Sweet pie&quot;, &quot;Just like grandma used to make&quot;)
};
    
new CommandAPICommand(&quot;giveitem&quot;)
    .withArguments(new StringArgument(&quot;item&quot;).replaceSuggestions(ArgumentSuggestions.stringsWithTooltips(customItems))) // We use customItems[] as the input for our suggestions with tooltips
    .executesPlayer((player, args) -&gt; {
        String itemName = (String) args.get(&quot;item&quot;);
        
        // Give them the item
        for (CustomItem item : customItems) {
            if (item.getName().equals(itemName)) {
                player.getInventory().addItem(item.getItem());
                break;
            }
        }
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">val customItems = arrayOf&lt;CustomItem&gt;(
    CustomItem(ItemStack(Material.DIAMOND_SWORD), &quot;God sword&quot;, &quot;A sword from the heavens&quot;),
    CustomItem(ItemStack(Material.PUMPKIN_PIE), &quot;Sweet pie&quot;, &quot;Just like grandma used to make&quot;)
)

CommandAPICommand(&quot;giveitem&quot;)
    .withArguments(StringArgument(&quot;item&quot;).replaceSuggestions(ArgumentSuggestions.stringsWithTooltips(*customItems))) // We use customItems[] as the input for our suggestions with tooltips
    .executesPlayer(PlayerCommandExecutor { player, args -&gt;
        val itemName = args[&quot;item&quot;] as String

        // Give them the item
        for (item in customItems) {
            if (item.name == itemName) {
                player.inventory.addItem(item.item)
                break
            }
        }
    })
    .register()
</code></pre>
</div>
</div>
<hr />
<h2 id="tooltips-with-safe-suggestions"><a class="header" href="#tooltips-with-safe-suggestions">Tooltips with safe suggestions</a></h2>
<p>Using tooltips with safe suggestions is almost identical to the method described above for normal suggestions, except for two things. Firstly, you must use <code>tooltips</code> method instead of the <code>stringsWithTooltips</code> method and secondly, instead of using <code>StringTooltip</code>, you must use <code>Tooltip&lt;S&gt;</code>. Let's look at these differences in more detail.</p>
<p>The <code>tooltips</code> methods are fairly similar to the <code>stringsWithTooltips</code> methods, except instead of using <code>StringTooltip</code>, it simply uses <code>Tooltip&lt;S&gt;</code>:</p>
<pre><code class="language-java">SafeSuggestions&lt;T&gt; tooltips(Tooltip&lt;T&gt;... suggestions);
SafeSuggestions&lt;T&gt; tooltips(Function&lt;SuggestionInfo, Tooltip&lt;T&gt;[]&gt; suggestions);
</code></pre>
<p>The <code>Tooltip&lt;S&gt;</code> class represents a tooltip for a given object <code>S</code>. For example, a tooltip for a <code>LocationArgument</code> would be a <code>Tooltip&lt;Location&gt;</code> and a tooltip for an <code>EnchantmentArgument</code> would be a <code>Tooltip&lt;Enchantment&gt;</code>.</p>
<p>Just like the <code>StringTooltip</code> class, the <code>Tooltip&lt;S&gt;</code> class provides the following static methods, which operate exactly the same as the ones in the <code>StringTooltip</code> class:</p>
<pre><code class="language-java">Tooltip&lt;S&gt; none(S object);
Tooltip&lt;S&gt; ofString(S object, String tooltip);
Tooltip&lt;S&gt; ofMessage(S object, Message tooltip);
Tooltip&lt;S&gt; ofBaseComponents(S object, BaseComponent... tooltip);
Tooltip&lt;S&gt; ofAdventureComponent(S object, Component tooltip);

Tooltip&lt;S&gt;[] arrayOf(Tooltip&lt;S&gt;... tooltips);
</code></pre>
<p>The use of <code>arrayOf</code> is heavily recommended as it provides the necessary type safety for Java code to ensure that the correct types are being passed to the <code>tooltips</code> method.</p>
<div class="example">
<h3 id="example---teleportation-command-with-suggestion-descriptions"><a class="header" href="#example---teleportation-command-with-suggestion-descriptions">Example - Teleportation command with suggestion descriptions</a></h3>
<p>Say we wanted to create a custom teleport command which suggestions a few key locations. In this example, we'll use the following command syntax:</p>
<pre><code class="language-mccmd">/warp &lt;location&gt;
</code></pre>
<p>First, we'll declare our arguments. Here, we use a <code>LocationArgument</code> and use the <code>tooltips</code> method, with a parameter for the command sender, so we can get information about the world. We populate the suggestions with tooltips using <code>Tooltip.ofString(Location, String)</code> and collate them together with <code>Tooltip.arrayOf(Tooltip&lt;Location&gt;...)</code>:</p>
<div class="multi-pre">
<pre><code class="language-java Java">List&lt;Argument&lt;?&gt;&gt; arguments = new ArrayList&lt;&gt;();
arguments.add(new LocationArgument(&quot;location&quot;)
    .replaceSafeSuggestions(SafeSuggestions.tooltips(info -&gt; {
        // We know the sender is a player if we use .executesPlayer()
        Player player = (Player) info.sender();
        return BukkitTooltip.arrayOf(
            BukkitTooltip.ofString(player.getWorld().getSpawnLocation(), &quot;World spawn&quot;),
            BukkitTooltip.ofString(player.getBedSpawnLocation(), &quot;Your bed&quot;),
            BukkitTooltip.ofString(player.getTargetBlockExact(256).getLocation(), &quot;Target block&quot;)
        );
    })));
</code></pre>
<pre><code class="language-kotlin Kotlin">val arguments = listOf&lt;Argument&lt;*&gt;&gt;(
    LocationArgument(&quot;location&quot;)
        .replaceSafeSuggestions(SafeSuggestions.tooltips { info -&gt;
            // We know the sender is a player if we use .executesPlayer()
            val player = info.sender() as Player
            BukkitTooltip.arrayOf(
                BukkitTooltip.ofString(player.world.spawnLocation, &quot;World spawn&quot;),
                BukkitTooltip.ofString(player.bedSpawnLocation, &quot;Your bed&quot;),
                BukkitTooltip.ofString(player.getTargetBlockExact(256)?.location, &quot;Target block&quot;)
            )
        } )
)
</code></pre>
</div>
<p>In the arguments declaration, we've casted the command sender to a player. To ensure that the command sender is definitely a player, we'll use the <code>executesPlayer</code> command execution method in our command declaration:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;warp&quot;)
    .withArguments(arguments)
    .executesPlayer((player, args) -&gt; {
        player.teleport((Location) args.get(&quot;location&quot;));
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;warp&quot;)
    .withArguments(arguments)
    .executesPlayer(PlayerCommandExecutor { player, args -&gt;
        player.teleport(args[&quot;location&quot;] as Location)
    })
    .register()
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asynchronous-suggestions"><a class="header" href="#asynchronous-suggestions">Asynchronous suggestions</a></h1>
<p>In addition to normal suggestions, safely-typed suggestions and suggestions with tooltips, the CommandAPI can support computing the list of suggestions to send to a player asynchronously. This allows you to perform suggestions independent of the main server thread, which is useful for slow operations, such as:</p>
<ul>
<li>Retrieving suggestions from a remote database</li>
<li>Retrieving information from the web</li>
<li>Retrieving suggestions from a file</li>
</ul>
<p><img src="./images/asyncsuggestions.gif" alt="asynchronous suggestions" /></p>
<p>The asynchronous methods for suggestions are similar in format to normal suggestions, except for two things: the name of the method ends with <code>Async</code>, and the return type for the inner function is a <code>CompletableFuture</code>:</p>
<pre><code class="language-java">ArgumentSuggestions stringsAsync(Function&lt;SuggestionInfo, CompletableFuture&lt;String[]&gt;&gt; suggestions);
ArgumentSuggestions stringsWithTooltipsAsync(Function&lt;SuggestionInfo, CompletableFuture&lt;IStringTooltip[]&gt;&gt; suggestions);
    
SafeSuggestions&lt;T&gt; suggestAsync(Function&lt;SuggestionInfo, CompletableFuture&lt;T[]&gt;&gt; suggestions);
SafeSuggestions&lt;T&gt; tooltipsAsync(Function&lt;SuggestionInfo, CompletableFuture&lt;Tooltip&lt;T&gt;[]&gt;&gt; suggestions);
</code></pre>
<h2 id="creating-completable-futures"><a class="header" href="#creating-completable-futures">Creating completable futures</a></h2>
<p>The easiest way to create a <code>CompleteableFuture</code> for asynchronous suggestions is to use Java's <code>CompletableFuture.supplyAsync()</code> method. If you have a simple array of string suggestions (<code>String[]</code>), these can be turned into a completable future (<code>CompletableFuture&lt;String[]&gt;</code>) using this method:</p>
<pre><code class="language-java">new String[] { &quot;dirt&quot;, &quot;grass&quot;, &quot;cobblestone&quot;, };
</code></pre>
<p>$$\downarrow$$</p>
<pre><code class="language-java">CompletableFuture.supplyAsync(() -&gt; {
    return new String[] { &quot;dirt&quot;, &quot;grass&quot;, &quot;cobblestone&quot;, };
});
</code></pre>
<blockquote>
<p><strong>Developer's Note:</strong></p>
<p>As with all asynchronous operations running in a Minecraft server, you should <strong>not</strong> try to access the Bukkit API within an asynchronous block. If you want to run code which accesses Bukkit's API while inside an asynchronous block, you can schedule a synchronous task using the Bukkit scheduler, for example:</p>
<pre><code class="language-java">CompletableFuture.supplyAsync(() -&gt; {

   Bukkit.getScheduler().scheduleAsyncDelayedTask(plugin, () -&gt; 
       // Your code here
   );

   return new String[] { &quot;dirt&quot;, &quot;grass&quot;, &quot;cobblestone&quot;, };
});
</code></pre>
</blockquote>
<h2 id="asynchronous-suggestions-examples"><a class="header" href="#asynchronous-suggestions-examples">Asynchronous suggestions examples</a></h2>
<div class="example">
<h3 id="reading-keys-from-a-config-file"><a class="header" href="#reading-keys-from-a-config-file">Reading keys from a config file</a></h3>
<p>Say you wanted to write a command to modify your plugin's config file. Since the config file is an external file, you ideally want to access the file in a separate thread to the main server thread to retain performance for players on the server. We have the following command syntax:</p>
<pre><code class="language-mccmd">/setconfig &lt;key&gt; &lt;value&gt;
</code></pre>
<p>We make use of the <code>ArgumentSuggestions.stringsAsync</code> method to provide asynchronous suggestions. In our completable future implementation, we access the keys from the plugin configuration.</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;setconfig&quot;)
    .withArguments(new StringArgument(&quot;key&quot;).replaceSuggestions(ArgumentSuggestions.stringsAsync(info -&gt; {
        return CompletableFuture.supplyAsync(() -&gt; {
            return plugin.getConfig().getKeys(false).toArray(new String[0]);
        });
    })))
    .withArguments(new TextArgument(&quot;value&quot;))
    .executes((sender, args) -&gt; {
        String key = (String) args.get(&quot;key&quot;);
        String value = (String) args.get(&quot;value&quot;);
        plugin.getConfig().set(key, value);
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;setconfig&quot;)
    .withArguments(StringArgument(&quot;key&quot;).replaceSuggestions(ArgumentSuggestions.stringsAsync { _ -&gt;
        CompletableFuture.supplyAsync { plugin.config.getKeys(false).toTypedArray() }
    } ))
    .withArguments(TextArgument(&quot;value&quot;))
    .executes(CommandExecutor { _, args -&gt;
        val key = args[&quot;key&quot;] as String
        val value = args[&quot;value&quot;] as String
        plugin.config.set(key, value)
    })
    .register()
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="argument-types"><a class="header" href="#argument-types">Argument types</a></h1>
<p>For more information on argument casting types, see <a href="./arguments.html#argument-casting">Argument Casting</a>. This section is primarily about use cases for each argument and any implementation notes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="primitive-arguments"><a class="header" href="#primitive-arguments">Primitive arguments</a></h1>
<p>Primitive arguments are arguments that represent Java primitive types, such as <code>int</code>, <code>float</code>, <code>double</code>, <code>boolean</code> and <code>long</code>. These arguments are defined in their respective classes:</p>
<div class="table-wrapper"><table><thead><tr><th>Primitive type</th><th>CommandAPI class</th></tr></thead><tbody>
<tr><td><code>int</code></td><td><code>IntegerArgument</code></td></tr>
<tr><td><code>float</code></td><td><code>FloatArgument</code></td></tr>
<tr><td><code>double</code></td><td><code>DoubleArgument</code></td></tr>
<tr><td><code>long</code></td><td><code>LongArgument</code></td></tr>
<tr><td><code>boolean</code></td><td><code>BooleanArgument</code></td></tr>
</tbody></table>
</div>
<p>These arguments simply cast to their primitive type and don't need any extra work.</p>
<hr />
<h2 id="boolean-arguments"><a class="header" href="#boolean-arguments">Boolean arguments</a></h2>
<p><img src="./images/arguments/boolean.png" alt="A boolean argument showing the suggestions 'false' and 'true'" /></p>
<p>The <code>BooleanArgument</code> class represents the Boolean values <code>true</code> and <code>false</code>.</p>
<div class="example">
<h3 id="example---config-editing-plugin"><a class="header" href="#example---config-editing-plugin">Example - Config editing plugin</a></h3>
<p>Say we want to create a plugin that lets you edit its own <code>config.yml</code> file using a command. To do this, let's create a command with the following syntax:</p>
<pre><code class="language-mccmd">/editconfig &lt;config-key&gt; &lt;value&gt;
</code></pre>
<p>We first retrieve the keys from the configuration file using the typical Bukkit API. We construct our <code>List</code> to hold our arguments, with the first parameter being a String key (in the form of a <code>TextArgument</code>, <a href="./argumentsuggestions.html">overridden with an array of suggestions</a>). Finally, we register our command and update the config, ensuring that we cast the <code>BooleanArgument</code> to <code>boolean</code>:</p>
<div class="multi-pre">
<pre><code class="language-java Java">// Load keys from config file
String[] configKeys = getConfig().getKeys(true).toArray(new String[0]);

// Register our command
new CommandAPICommand(&quot;editconfig&quot;)
    .withArguments(new TextArgument(&quot;config-key&quot;).replaceSuggestions(ArgumentSuggestions.strings(info -&gt; configKeys)))
    .withArguments(new BooleanArgument(&quot;value&quot;))
    .executes((sender, args) -&gt; {
        // Update the config with the boolean argument
        getConfig().set((String) args.get(&quot;config-key&quot;), (boolean) args.get(&quot;value&quot;));
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">// Load keys from config file
val configKeys: Array&lt;String&gt; = config.getKeys(true).toTypedArray()

// Register our command
CommandAPICommand(&quot;editconfig&quot;)
    .withArguments(TextArgument(&quot;config-key&quot;).replaceSuggestions(ArgumentSuggestions.strings { _ -&gt; configKeys }))
    .withArguments(BooleanArgument(&quot;value&quot;))
    .executes(CommandExecutor { _, args -&gt;
        // Update the config with the boolean argument
        config.set(args[&quot;config-key&quot;] as String, args[&quot;value&quot;] as Boolean)
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">// Load keys from config file
val configKeys: Array&lt;String&gt; = getConfig().getKeys(true).toTypedArray()

// Register our command
commandAPICommand(&quot;editconfig&quot;) {
    argument(TextArgument(&quot;config-key&quot;).replaceSuggestions(ArgumentSuggestions.strings { configKeys }))
    booleanArgument(&quot;value&quot;)
    anyExecutor { _, args -&gt;
        // Update the config with the boolean argument
        getConfig().set(args[&quot;config-key&quot;] as String, args[&quot;value&quot;] as Boolean)
    }
}
</code></pre>
</div>
</div>
<hr />
<h2 id="numerical-arguments"><a class="header" href="#numerical-arguments">Numerical arguments</a></h2>
<p>Numbers are represented using the designated number classes:</p>
<div class="table-wrapper"><table><thead><tr><th>Class</th><th>Description</th></tr></thead><tbody>
<tr><td><code>IntegerArgument</code></td><td>Whole numbers between <code>Integer.MIN_VALUE</code> and <code>Integer.MAX_VALUE</code></td></tr>
<tr><td><code>LongArgument</code></td><td>Whole numbers between <code>Long.MIN_VALUE</code> and <code>Long.MAX_VALUE</code></td></tr>
<tr><td><code>DoubleArgument</code></td><td>Double precision floating point numbers</td></tr>
<tr><td><code>FloatArgument</code></td><td>Single precision floating point numbers</td></tr>
</tbody></table>
</div>
<p>Each numerical argument can have ranges applied to them, which restricts the user to only entering numbers from within a certain range. This is done using the constructor, and the range specified:</p>
<div class="table-wrapper"><table><thead><tr><th>Constructor</th><th>Description</th></tr></thead><tbody>
<tr><td><code>new IntegerArgument()</code></td><td>Any range</td></tr>
<tr><td><code>new IntegerArgument(min)</code></td><td>Values greater than <em>or equal to</em> <code>min</code></td></tr>
<tr><td><code>new IntegerArgument(min, max)</code></td><td>Values greater than or equal to <code>min</code> and less than or equal to <code>max</code></td></tr>
</tbody></table>
</div>
<p>Each range is <em>inclusive</em>, so it includes the number given to it. If the minimum value provided is larger than the maximum value, an <code>InvalidRangeException</code> is thrown.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ranged-arguments"><a class="header" href="#ranged-arguments">Ranged arguments</a></h1>
<p><img src="./images/arguments/floatrange.png" alt="A float range argument command with the argument &quot;0.5.3.5&quot; entered" /></p>
<p>Ranged arguments allow players to provide a range between two numbers, all within a single argument. The CommandAPI provides two ranged arguments, <code>IntegerRangeArgument</code> for ranges with only integer values, and <code>FloatRangeArgument</code> for ranged with potential floating point values.</p>
<p>These consist of values such as:</p>
<div class="table-wrapper"><table><thead><tr><th>Input</th><th>What it means</th></tr></thead><tbody>
<tr><td><code>5</code></td><td>The number 5</td></tr>
<tr><td><code>5..10</code></td><td>Numbers between 5 and 10, including 5 and 10</td></tr>
<tr><td><code>5..</code></td><td>Numbers greater than or equal to 5 (bounded by Java's max number size)</td></tr>
<tr><td><code>..5</code></td><td>Numbers less than or equal to 5 (bounded by Java's min number size)</td></tr>
</tbody></table>
</div>
<p>This allows you to let users define a range of values, which can be used to limit a value, such as the number of players in a region or for a random number generator.</p>
<hr />
<h2 id="the-integerrange--floatrange-class"><a class="header" href="#the-integerrange--floatrange-class">The IntegerRange &amp; FloatRange class</a></h2>
<p>The CommandAPI returns an <code>IntegerRange</code> from the <code>IntegerRangeArgument</code>, and a <code>FloatRange</code> from the <code>FloatRangeArgument</code>, which represents the upper and lower bounds of the numbers provided by the command sender, as well as a method to check if a number is within that range.</p>
<p>The <code>IntegerRange</code> class has the following methods:</p>
<pre><code class="language-java">class IntegerRange {
    public int getLowerBound();
    public int getUpperBound();
    public boolean isInRange(int);
}
</code></pre>
<p>The <code>FloatRange</code> class has the following methods:</p>
<pre><code class="language-java">class FloatRange {
    public float getLowerBound();
    public float getUpperBound();
    public boolean isInRange(float);
}
</code></pre>
<div class="example">
<h2 id="example---searching-chests-for-certain-items"><a class="header" href="#example---searching-chests-for-certain-items">Example - Searching chests for certain items</a></h2>
<p>Say you're working on a plugin for server administrators to help them find restricted items. A method of doing so would be to search chests in a given radius for certain items. As such, we can use the following syntax:</p>
<pre><code class="language-mccmd">/searchchests &lt;range&gt; &lt;item&gt;
</code></pre>
<p>Now, we simply create our arguments using <code>IntegerRangeArgument</code> for our range and <code>ItemStackArgument</code> as the item to search for. We can then find all chests in a given area and determine if it is within the range provided by the command sender by using <code>range.isInRange(distance)</code>:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;searchrange&quot;)
    .withArguments(new IntegerRangeArgument(&quot;range&quot;)) // Range argument
    .withArguments(new ItemStackArgument(&quot;item&quot;))     // The item to search for
    .executesPlayer((player, args) -&gt; {
        // Retrieve the range from the arguments
        IntegerRange range = (IntegerRange) args.get(&quot;range&quot;);
        ItemStack itemStack = (ItemStack) args.get(&quot;item&quot;);

        // Store the locations of chests with certain items
        List&lt;Location&gt; locations = new ArrayList&lt;&gt;();

        // Iterate through all chunks, and then all tile entities within each chunk
        for (Chunk chunk : player.getWorld().getLoadedChunks()) {
            for (BlockState blockState : chunk.getTileEntities()) {

                // The distance between the block and the player
                int distance = (int) blockState.getLocation().distance(player.getLocation());

                // Check if the distance is within the specified range 
                if (range.isInRange(distance)) {

                    // Check if the tile entity is a chest
                    if (blockState instanceof Chest chest) {
                        
                        // Check if the chest contains the item specified by the player
                        if (chest.getInventory().contains(itemStack.getType())) {
                            locations.add(chest.getLocation());
                        }
                    }
                }

            }
        }

        // Output the locations of the chests, or whether no chests were found
        if (locations.isEmpty()) {
            player.sendMessage(&quot;No chests were found&quot;);
        } else {
            player.sendMessage(&quot;Found &quot; + locations.size() + &quot; chests:&quot;);
            locations.forEach(location -&gt; {
                player.sendMessage(&quot;  Found at: &quot; 
                        + location.getX() + &quot;, &quot; 
                        + location.getY() + &quot;, &quot; 
                        + location.getZ());
            });
        }
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;searchrange&quot;)
    .withArguments(IntegerRangeArgument(&quot;range&quot;)) // Range argument
    .withArguments(ItemStackArgument(&quot;item&quot;))     // The item to search for
    .executesPlayer(PlayerCommandExecutor { player, args -&gt;
        // Retrieve the range from the arguments
        val range = args[&quot;range&quot;] as IntegerRange
        val itemStack = args[&quot;item&quot;] as ItemStack

        // Store the locations of chests with certain items
        val locations = mutableListOf&lt;Location&gt;()

        // Iterate through all chunks, and then all tile entities within each chunk
        for (chunk in player.world.loadedChunks) {
            for (blockState in chunk.tileEntities) {

                // The distance between the block and the player
                val distance = blockState.location.distance(player.location).toInt()

                // Check if the distance is within the specified range
                if (range.isInRange(distance)) {

                    // Check if the tile entity is a chest
                    if (blockState is Chest) {

                        // Check if the chest contains the item specified by the player
                        if (blockState.inventory.contains(itemStack.type)) {
                            locations.add(blockState.location)
                        }
                    }
                }

            }
        }

        // Output the locations of the chests, or whether no chests were found
        if (locations.isEmpty()) {
            player.sendMessage(&quot;No chests were found&quot;)
        } else {
            player.sendMessage(&quot;Found ${locations.size} chests:&quot;)
            locations.forEach {
                player.sendMessage(&quot;  Found at: ${it.x}, ${it.y}, ${it.z}&quot;)
            }
        }
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;searchrange&quot;) {
    integerRangeArgument(&quot;range&quot;) // Range argument
    itemStackArgument(&quot;item&quot;) // The item to search for
    playerExecutor { player, args -&gt;
        // Retrieve the range from the arguments
        val range = args[&quot;range&quot;] as IntegerRange
        val itemStack = args[&quot;item&quot;] as ItemStack

        // Store the locations of chests with certain items
        val locations = mutableListOf&lt;Location&gt;()

        // Iterate through all chunks, and then all tile entities within each chunk
        for (chunk in player.world.loadedChunks) {
            for (blockState in chunk.tileEntities) {

                // The distance between the block and the player
                val distance = blockState.location.distance(player.location).toInt()

                // Check if the distance is within the specified range
                if (range.isInRange(distance)) {

                    // Check if the tile entity is a chest
                    if (blockState is Chest) {

                        // Check if the chest contains the item specified by the player
                        if (blockState.inventory.contains(itemStack.type)) {
                            locations.add(blockState.location)
                        }
                    }
                }

            }
        }

        // Output the locations of the chests, or whether no chests were found
        if (locations.isEmpty()) {
            player.sendMessage(&quot;No chests were found&quot;)
        } else {
            player.sendMessage(&quot;Found ${locations.size} chests:&quot;)
            locations.forEach {
                player.sendMessage(&quot;  Found at: ${it.x}, ${it.y}, ${it.z}&quot;)
            }
        }
    }
}
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string-arguments"><a class="header" href="#string-arguments">String arguments</a></h1>
<p>There are three types of arguments that return Java's <code>String</code> object. Each have their own unique set of features which make them suitable for specific needs.</p>
<hr />
<h2 id="string-argument"><a class="header" href="#string-argument">String argument</a></h2>
<p>The <code>StringArgument</code> class is used to represent a single word. These words <strong>can only contain alphanumeric characters (A-Z, a-z and 0-9) and the underscore (_), plus (+), minus (-) and period (.) characters.</strong></p>
<p>Accepted <code>StringArgument</code> values:</p>
<pre><code class="language-txt">Hello
123
hello123
hello-123
hello.WORLD
Hello_world
</code></pre>
<p>Rejected <code>StringArgument</code> values:</p>
<pre><code class="language-txt">hello@email.com
yesn't
</code></pre>
<div class="example">
<h3 id="examples-of-stringargument-uses"><a class="header" href="#examples-of-stringargument-uses">Examples of StringArgument uses</a></h3>
<ul>
<li>Entering strings to identify offline players</li>
</ul>
</div>
<hr />
<h2 id="text-argument"><a class="header" href="#text-argument">Text argument</a></h2>
<p>The <code>TextArgument</code> acts similar to any String in Java. These can be single words, like the <code>StringArgument</code>, or have additional characters (e.g. spaces, symbols) <strong>if surrounded by quotes</strong>. To type quotation marks, you can use <code>\&quot;</code> (as similar to Java) to escape these special characters.</p>
<p>Accepted <code>TextArgument</code> values:</p>
<pre><code class="language-txt">hello
&quot;hello world!&quot;
&quot;hello@gmail.com&quot;
&quot;this has \&quot; &lt;&lt;-- speech marks! &quot;
</code></pre>
<p>Rejected <code>TextArgument</code> values:</p>
<pre><code class="language-txt">hello world
私
&quot;speech marks: &quot;&quot;
</code></pre>
<div class="example">
<h3 id="examples-of-textargument-uses"><a class="header" href="#examples-of-textargument-uses">Examples of TextArgument uses</a></h3>
<ul>
<li>Editing the contents of a sign</li>
<li>A command that requires multiple text arguments (say, username and password?)</li>
</ul>
</div>
<hr />
<h2 id="greedy-string-argument"><a class="header" href="#greedy-string-argument">Greedy string argument</a></h2>
<blockquote>
<p><strong>Greedy Arguments:</strong></p>
<p>The <code>GreedyStringArgument</code>, similar to the <code>ChatArgument</code> uses the entire argument array from its current position. This means that it never ends, therefore if it is used, it must be the last element of your <code>List</code> of arguments.</p>
<p>For example, if you have a command <code>/message &lt;message&gt; &lt;target&gt;</code>, it would not be able to determine where the message ends and the <code>&lt;target&gt;</code> argument begins.</p>
<p>If a <code>GreedyStringArgument</code> or <code>ChatArgument</code> is not declared at the end of the <code>List</code> of arguments, or multiple of these arguments are used in the same <code>List</code>, the CommandAPI throws a <code>GreedyArgumentException</code>.</p>
</blockquote>
<p>The <code>GreedyStringArgument</code> takes the <code>TextArgument</code> a step further. <strong>Any characters and symbols are allowed</strong> and quotation marks are not required.</p>
<div class="example">
<h3 id="example---messaging-command"><a class="header" href="#example---messaging-command">Example - Messaging command</a></h3>
<p>Say we have a simple message command of the following form:</p>
<pre><code class="language-mccmd">/message &lt;target&gt; &lt;message&gt;
</code></pre>
<p>This would be ideal for a greedy string, since it can consume all text after the player's name:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;message&quot;)
    .withArguments(new PlayerArgument(&quot;target&quot;))
    .withArguments(new GreedyStringArgument(&quot;message&quot;))
    .executes((sender, args) -&gt; {
        ((Player) args.get(&quot;target&quot;)).sendMessage((String) args.get(&quot;message&quot;));
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;message&quot;)
    .withArguments(PlayerArgument(&quot;target&quot;))
    .withArguments(GreedyStringArgument(&quot;message&quot;))
    .executes(CommandExecutor { _, args -&gt;
        (args[&quot;target&quot;] as Player).sendMessage(args[&quot;message&quot;] as String)
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;message&quot;) {
    playerArgument(&quot;target&quot;)
    greedyStringArgument(&quot;message&quot;)
    anyExecutor { _, args -&gt;
        (args[&quot;target&quot;] as Player).sendMessage(args[&quot;message&quot;] as String)
    }
}
</code></pre>
</div>
<p>Any text entered after the <code>&lt;target&gt;</code> argument would be sent to the player. For example, the command could be used as follows:</p>
<pre><code class="language-mccmd">/message Skepter This is some incredibly long string with &quot;symbols&quot; and $p3c!aL characters~
</code></pre>
<p>Note how this only works if the greedy string argument is <em>at the end</em>. If, say, the command was <code>/message &lt;message&gt; &lt;target&gt;</code>, it would not be able to determine where the <code>&lt;message&gt;</code> argument ends and the <code>&lt;target&gt;</code> argument begins.</p>
</div>
<div class="example">
<h3 id="examples-of-greedystringargument-uses"><a class="header" href="#examples-of-greedystringargument-uses">Examples of GreedyStringArgument uses</a></h3>
<ul>
<li>A messaging/whisper command (as shown in the example above)</li>
<li>A mailing command</li>
<li>Any command involving lots of text, such as a command to write the contents of a book</li>
<li>Any command which involves an unreasonable/unknown amount of arguments</li>
<li>Any command where you want to parse arguments similar to how regular Bukkit would</li>
</ul>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="position-based-arguments"><a class="header" href="#position-based-arguments">Position-based arguments</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="location-arguments"><a class="header" href="#location-arguments">Location arguments</a></h1>
<p><img src="./images/arguments/loc.png" alt="A Location argument showing the options '', ' ' and ' ~ ~'" /></p>
<p>In the CommandAPI, there are two arguments used to represent location. The <code>LocationArgument</code> argument, which represents a 3D location \( (x, y, z) \) and the <code>Location2DArgument</code>, which represents 2D location \( (x, z) \).</p>
<hr />
<h2 id="location-3d-space"><a class="header" href="#location-3d-space">Location (3D space)</a></h2>
<p>The <code>LocationArgument</code> class is used to specify a location in the <strong>command sender's current world</strong>, returning a Bukkit <code>Location</code> object. It allows the user to enter three numbers as coordinates, or use relative coordinates (i.e. the <code>~</code> and <code>^</code> operators).</p>
<p>The <code>LocationArgument</code> constructor requires a <code>LocationType</code>, which specifies the type of location that is accepted by the command. The <code>LocationType</code> enum consists of two values:</p>
<h3 id="locationtypeblock_position"><a class="header" href="#locationtypeblock_position"><code>LocationType.BLOCK_POSITION</code></a></h3>
<p><code>BLOCK_POSITION</code> refers to integer block coordinates. When in-game as a player, the suggested location is the coordinates of block you are looking at when you type the command.</p>
<p><img src="./images/arguments/locationargument_blockposition.png" alt="BLOCK_POSITION" /></p>
<h3 id="locationtypeprecise_position"><a class="header" href="#locationtypeprecise_position"><code>LocationType.PRECISE_POSITION</code></a></h3>
<p><code>PRECISE_PRECISION</code> uses exact coordinates, using the <code>double</code> primitive type. When in-game as a player, the suggested location is the exact coordinates of where your cursor is pointing at when you type the command.</p>
<p><img src="./images/arguments/locationargument_preciseposition.png" alt="PRECISE_POSITION" /></p>
<p>If no <code>LocationType</code> is provided, <strong>the <code>LocationArgument</code> will use <code>PRECISE_POSITION</code> by default</strong>.</p>
<p>The <code>LocationArgument</code> constructor can also accept a <code>boolean centerPosition</code>. If set to <code>true</code>, when using <code>LocationType.PRECISE_POSITION</code>, if an integer is provided in the value, it will add 0.5 to the x and z coordinates to center the position within a block. If set to <code>false</code>, the integer value will be provided as is.</p>
<p>If no <code>centerPosition</code> parameter is provided, <strong>the <code>LocationArgument</code> will use <code>centerPosition = true</code> by default</strong>.</p>
<div class="example">
<h3 id="example---locationargument-precise-position-centering"><a class="header" href="#example---locationargument-precise-position-centering">Example - LocationArgument precise position centering</a></h3>
<p>Say you use the following constructor, which sets <code>centerPosition</code> to <code>true</code>:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new LocationArgument(&quot;location&quot;, LocationType.PRECISE_POSITION, true);
</code></pre>
<pre><code class="language-kotlin Kotlin">LocationArgument(&quot;location&quot;, LocationType.PRECISE_POSITION, true)
</code></pre>
</div>
<p><strong>Integer positions are centered</strong></p>
<p>Let's also say you use the following location using this location argument in a command:</p>
<pre><code class="language-text">10 20 30
</code></pre>
<p>The resulting location will be the following, which centers the position of the x and z coordinates. This does not change the y coordinate:</p>
<pre><code class="language-text">10.5 20 30.5
</code></pre>
<p><strong>Non-integer positions remain as normal</strong></p>
<p>If you use the following location using this location argument in a command:</p>
<pre><code class="language-text">10.2 20.2 30.2
</code></pre>
<p>The resulting location will be the following, which does not change the x and z coordinates, because the positions are not integers:</p>
<pre><code class="language-text">10.2 20.2 30.2
</code></pre>
<hr />
<p>Say you use the following constructor, which sets <code>centerPosition</code> to <code>false</code>:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new LocationArgument(&quot;location&quot;, LocationType.PRECISE_POSITION, false);
</code></pre>
<pre><code class="language-kotlin Kotlin">LocationArgument(&quot;location&quot;, LocationType.PRECISE_POSITION, false)
</code></pre>
</div>
<p><strong>Integer positions are not centered</strong></p>
<p>Let's also say you use the following location using this location argument in a command:</p>
<pre><code class="language-text">10 20 30
</code></pre>
<p>The resulting location will be the following, which does not modify the position of the x and z coordinates:</p>
<pre><code class="language-text">10 20 30
</code></pre>
</div>
<hr />
<div class="example">
<h3 id="example---break-block-using-coordinates"><a class="header" href="#example---break-block-using-coordinates">Example - Break block using coordinates</a></h3>
<p>We can declare a simple command to break a block:</p>
<pre><code class="language-mccmd">/break &lt;location&gt;
</code></pre>
<p>Simply put, given the coordinates provided to the command, &quot;break&quot; the block by setting it's type to <code>Material.AIR</code>. For this example, we're referring to block specific coordinates, so we want to use <code>LocationType.BLOCK_POSITION</code>:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;break&quot;)
    // We want to target blocks in particular, so use BLOCK_POSITION
    .withArguments(new LocationArgument(&quot;block&quot;, LocationType.BLOCK_POSITION))
    .executesPlayer((player, args) -&gt; {
        Location location = (Location) args.get(&quot;block&quot;);
        location.getBlock().setType(Material.AIR);
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;break&quot;)
    // We want to target blocks in particular, so use BLOCK_POSITION
    .withArguments(LocationArgument(&quot;block&quot;, LocationType.BLOCK_POSITION))
    .executesPlayer(PlayerCommandExecutor { _, args -&gt;
        (args[&quot;block&quot;] as Location).block.type = Material.AIR
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;break&quot;) {
    // We want to target blocks in particular, so use BLOCK_POSITION
    locationArgument(&quot;block&quot;, LocationType.BLOCK_POSITION)
    playerExecutor { _, args -&gt;
        (args[&quot;block&quot;] as Location).block.type = Material.AIR
    }
}
</code></pre>
</div>
</div>
<hr />
<h2 id="location-2d-space"><a class="header" href="#location-2d-space">Location (2D space)</a></h2>
<p><img src="./images/arguments/loc2d.png" alt="A location 2D argument showing the options '' and ' ~'" /></p>
<p>The <code>Location2DArgument</code> is pretty much identical in use to the <code>LocationArgument</code> for 3D coordinates, except instead of returning a <code>Location</code> object, it instead returns a <code>Location2D</code> object that extends <code>Location</code> (thus, being compatible anywhere you would normally be able to use <code>Location</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rotation-arguments"><a class="header" href="#rotation-arguments">Rotation arguments</a></h1>
<p><img src="./images/arguments/rotation.png" alt="An image of a rotation argument showing /rotationargument 90 180" /></p>
<p>The <code>RotationArgument</code> allows users to specify a pair of pitch and yaw coordinates. By default (using the <code>~</code> symbol), this refers to the player's current pitch and yaw of where they are looking at.</p>
<p>The <code>RotationArgument</code> class returns a <code>Rotation</code> object, which consists of the following methods:</p>
<div class="table-wrapper"><table><thead><tr><th>Method name</th><th>What it does</th></tr></thead><tbody>
<tr><td><code>float getPitch()</code></td><td>Returns a player's pitch (up and down rotation)</td></tr>
<tr><td><code>float getYaw()</code></td><td>Returns a player's yaw (left and right rotation)</td></tr>
<tr><td><code>float getNormalizedPitch()</code></td><td>Returns a player's pitch between -90 and 90 degrees</td></tr>
<tr><td><code>float getNormalizedYaw()</code></td><td>Returns a player's yaw between -180 and 180 degrees</td></tr>
</tbody></table>
</div><div class="example">
<h3 id="example-rotate-an-armor-stand-head"><a class="header" href="#example-rotate-an-armor-stand-head">Example: Rotate an armor stand head</a></h3>
<p>Say we want to make an armor stand look in a certain direction. To do this, we'll use the following command:</p>
<pre><code class="language-mccmd">/rotate &lt;rotation&gt; &lt;target&gt;
</code></pre>
<p>To do this, we'll use the rotation from the <code>RotationArgument</code> and select an entity using the <code>EntitySelectorArgument.OneEntity</code> class. We then check if our entity is an armor stand and if so, we set its head pose to the given rotation.</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;rotate&quot;)
    .withArguments(new RotationArgument(&quot;rotation&quot;))
    .withArguments(new EntitySelectorArgument.OneEntity(&quot;target&quot;))
    .executes((sender, args) -&gt; {
        Rotation rotation = (Rotation) args.get(&quot;rotation&quot;);
        Entity target = (Entity) args.get(&quot;target&quot;);

        if (target instanceof ArmorStand armorStand) {
            armorStand.setHeadPose(new EulerAngle(Math.toRadians(rotation.getPitch()), Math.toRadians(rotation.getYaw() - 90), 0));
        }
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;rotate&quot;)
    .withArguments(RotationArgument(&quot;rotation&quot;))
    .withArguments(EntitySelectorArgument.OneEntity(&quot;target&quot;))
    .executes(CommandExecutor { _, args -&gt;
        val rotation = args[&quot;rotation&quot;] as Rotation
        val target = args[&quot;target&quot;] as Entity

        if (target is ArmorStand) {
            target.headPose = EulerAngle(Math.toRadians(rotation.pitch.toDouble()), Math.toRadians(rotation.yaw.toDouble() - 90), 0.0)
        }
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;rotate&quot;) {
    rotationArgument(&quot;rotation&quot;)
    entitySelectorArgumentOneEntity(&quot;target&quot;)
    anyExecutor { _, args -&gt;
        val rotation = args[&quot;rotation&quot;] as Rotation
        val target = args[&quot;target&quot;] as Entity

        if (target is ArmorStand) {
            target.headPose = EulerAngle(Math.toRadians(rotation.pitch.toDouble()), Math.toRadians(rotation.yaw.toDouble() - 90), 0.0)
        }
    }
}
</code></pre>
</div>
<p>Note how the head pose requires an <code>EulerAngle</code> as opposed to a pitch and yaw. To account for this, we convert our rotation (which is in degrees) into an <code>EulerAngle</code> in radians.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="axisargument"><a class="header" href="#axisargument">AxisArgument</a></h1>
<p><img src="./images/arguments/axis.png" alt="An image of an axis argument with the suggestions x, xy, xyz, xz, y, yz and z" /></p>
<p>The <code>AxisArgument</code> class refers to the x, y and z axes. When used with the CommandAPI, it returns an <code>EnumSet&lt;Axis&gt;</code> <em>(You can view the documentation for <code>EnumSet</code> <a href="https://docs.oracle.com/javase/7/docs/api/java/util/EnumSet.html">here</a>)</em>.</p>
<div class="example">
<h3 id="examples-of-axisargument-uses"><a class="header" href="#examples-of-axisargument-uses">Examples of AxisArgument uses</a></h3>
<ul>
<li>Reflecting a structure in the x, y or z axis</li>
</ul>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chat-arguments"><a class="header" href="#chat-arguments">Chat arguments</a></h1>
<p>The CommandAPI provides a number of ways to interact with chat formatting in Minecraft. These are the following:</p>
<ul>
<li><strong>ChatColor</strong>: The color of text rendered in Minecraft</li>
<li><strong>Chat</strong>: Text which is said in chat. This also includes entity selectors such as <code>@a</code> and <code>@r</code></li>
<li><strong>ChatComponent</strong>: Minecraft's <a href="https://minecraft.wiki/w/Raw_JSON_text_format">Raw JSON text format</a></li>
</ul>
<p>The CommandAPI implements <strong>ChatColor</strong>, <strong>Chat</strong> and <strong>ChatComponent</strong> in two separate ways: <a href="./argument_chat_spigot.html">Spigot-compatible</a> and <a href="./argument_chat_adventure.html">Adventure-compatible</a>. The differences between these and how to use them are described in their own relevant pages.</p>
<p>The CommandAPI also supports Minecraft 1.19's chat preview feature. To use Minecraft 1.19's chat preview feature, information on that can be found in <a href="./chatpreview.html">Chat preview</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spigot-chat-arguments"><a class="header" href="#spigot-chat-arguments">Spigot chat arguments</a></h1>
<h2 id="chat-color-argument"><a class="header" href="#chat-color-argument">Chat color argument</a></h2>
<p><img src="./images/arguments/chatcolor.png" alt="Chatcolor argument in-game, displaying a list of Minecraft chat colors" /></p>
<p>The <code>ChatColorArgument</code> class is used to represent a given chat color (e.g. red or green). This argument returns the <code>ChatColor</code> object.</p>
<div class="example">
<h3 id="example---username-color-changing-plugin"><a class="header" href="#example---username-color-changing-plugin">Example - Username color changing plugin</a></h3>
<p>Say we want to create a plugin to change the color of a player's username. We want to create a command of the following form:</p>
<pre><code class="language-mccmd">/namecolor &lt;chatcolor&gt;
</code></pre>
<p>We then use the <code>ChatColorArgument</code> to change the player's name color:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;namecolor&quot;)
    .withArguments(new ChatColorArgument(&quot;chatcolor&quot;))
    .executesPlayer((player, args) -&gt; {
        ChatColor color = (ChatColor) args.get(&quot;chatcolor&quot;);
        player.setDisplayName(color + player.getName());
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;namecolor&quot;)
    .withArguments(ChatColorArgument(&quot;chatColor&quot;))
    .executesPlayer(PlayerCommandExecutor { player, args -&gt;
        val color = args[&quot;chatColor&quot;] as ChatColor
        player.setDisplayName(&quot;$color${player.name}&quot;)
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;namecolor&quot;) {
    chatColorArgument(&quot;chatcolor&quot;)
    playerExecutor { player, args -&gt;
        val color = args[&quot;chatcolor&quot;] as ChatColor
        player.setDisplayName(&quot;$color${player.name}&quot;)
    }
}
</code></pre>
</div>
</div>
<hr />
<blockquote>
<p><strong>Developer's Note:</strong></p>
<p>The two following classes, <code>ChatComponentArgument</code> and <code>ChatArgument</code> depend on a <a href="https://www.spigotmc.org/">Spigot</a> based server. This means that these arguments will not work on a non-Spigot based server, such as CraftBukkit. If you use this class on a non-Spigot based server, it will throw a <code>SpigotNotFoundException</code></p>
</blockquote>
<h2 id="chat-component-argument"><a class="header" href="#chat-component-argument">Chat component argument</a></h2>
<p>The <code>ChatComponentArgument</code> class accepts raw chat-based JSON as valid input. Despite being regular JSON, it <em>must</em> conform to the standard declared <a href="https://minecraft.wiki/w/Raw_JSON_text_format">here</a>, which consists of JSON that has a limited subset of specific keys (In other words, you can have a JSON object that has the key <code>text</code>, but not one that has the key <code>blah</code>).</p>
<p>This is converted into Spigot's <code>BaseComponent[]</code>, which can be used for the following:</p>
<ul>
<li>
<p>Broadcasting messages to all players on the server using:</p>
<pre><code class="language-java">Bukkit.getServer().spigot().broadcast(BaseComponent[]);
</code></pre>
</li>
<li>
<p>Adding and setting pages to books using <code>BookMeta</code>:</p>
<pre><code class="language-java">BookMeta meta = // ...
meta.spigot().setPages(BaseComponent[]);
</code></pre>
</li>
<li>
<p>Sending messages to <code>Player</code> objects:</p>
<pre><code class="language-java">Player player = // ...
player.spigot().sendMessage(BaseComponent[]);
</code></pre>
</li>
<li>
<p>Sending messages to <code>CommandSender</code> objects:</p>
<pre><code class="language-java">CommandSender sender = // ...
sender.spigot().sendMessage(BaseComponent[]);
</code></pre>
</li>
</ul>
<div class="example">
<h3 id="example---book-made-from-raw-json"><a class="header" href="#example---book-made-from-raw-json">Example - Book made from raw JSON</a></h3>
<p>Say we want to generate a book using raw JSON. For this example, we'll use the following JSON (generated from <a href="https://minecraftjson.com/">minecraftjson.com</a>) to generate our book:</p>
<pre><code class="language-json">[&quot;&quot;, {
    &quot;text&quot;: &quot;Once upon a time, there was a guy call &quot;
}, {
    &quot;text&quot;: &quot;Skepter&quot;,
    &quot;color&quot;: &quot;light_purple&quot;,
    &quot;hoverEvent&quot;: {
        &quot;action&quot;: &quot;show_entity&quot;,
        &quot;value&quot;: &quot;Skepter&quot;
    }
}, {
    &quot;text&quot;: &quot; and he created the &quot;
}, {
    &quot;text&quot;: &quot;CommandAPI&quot;,
    &quot;underlined&quot;: true,
    &quot;clickEvent&quot;: {
        &quot;action&quot;: &quot;open_url&quot;,
        &quot;value&quot;: &quot;https://github.com/JorelAli/CommandAPI&quot;
    }
}]
</code></pre>
<p>Since we're writing a book, we must ensure that all quotes have been escaped. This can also be performed on the <a href="https://minecraftjson.com/">minecraftjson.com</a> website by selecting &quot;book&quot;:</p>
<pre><code class="language-json">[&quot;[\&quot;\&quot;,{\&quot;text\&quot;:\&quot;Once upon a time, there was a guy call \&quot;},{\&quot;text\&quot;:\&quot;Skepter\&quot;,\&quot;color\&quot;:\&quot;light_purple\&quot;,\&quot;hoverEvent\&quot;:{\&quot;action\&quot;:\&quot;show_entity\&quot;,\&quot;value\&quot;:\&quot;Skepter\&quot;}},{\&quot;text\&quot;:\&quot; and he created the \&quot;},{\&quot;text\&quot;:\&quot;CommandAPI\&quot;,\&quot;underlined\&quot;:true,\&quot;clickEvent\&quot;:{\&quot;action\&quot;:\&quot;open_url\&quot;,\&quot;value\&quot;:\&quot;https://github.com/JorelAli/CommandAPI\&quot;}}]&quot;]
</code></pre>
<p>Now let's define our command. Since book text is typically very large - too large to be entered into a chat, we'll make a command block compatible command by providing a player parameter:</p>
<pre><code class="language-mccmd">/makebook &lt;player&gt; &lt;contents&gt;
</code></pre>
<p>Now we can create our book command. We use the player as the main target by using their name for the author field, as well as their inventory to place the book. We finally construct our book using the <code>.setPages(BaseComponent[])</code> method:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;makebook&quot;)
    .withArguments(new PlayerArgument(&quot;player&quot;))
    .withArguments(new ChatComponentArgument(&quot;contents&quot;))
    .executes((sender, args) -&gt; {
        Player player = (Player) args.get(&quot;player&quot;);
        BaseComponent[] arr = (BaseComponent[]) args.get(&quot;contents&quot;);
        
        // Create book
        ItemStack is = new ItemStack(Material.WRITTEN_BOOK);
        BookMeta meta = (BookMeta) is.getItemMeta(); 
        meta.setTitle(&quot;Custom Book&quot;);
        meta.setAuthor(player.getName());
        meta.spigot().setPages(arr);
        is.setItemMeta(meta);
        
        // Give player the book
        player.getInventory().addItem(is);
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;makebook&quot;)
    .withArguments(PlayerArgument(&quot;player&quot;))
    .withArguments(ChatComponentArgument(&quot;contents&quot;))
    .executes(CommandExecutor { _, args -&gt;
        val player = args[&quot;player&quot;] as Player
        val arr = args[&quot;contents&quot;] as Array&lt;BaseComponent&gt;

        // Create book
        val item = ItemStack(Material.WRITTEN_BOOK)
        val meta = item.itemMeta as BookMeta
        meta.title = &quot;Custom Book&quot;
        meta.author = player.name
        meta.spigot().setPages(arr)
        item.itemMeta = meta

        // Give player the book
        player.inventory.addItem(item)
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;makebook&quot;) {
    playerArgument(&quot;player&quot;)
    chatComponentArgument(&quot;contents&quot;)
    anyExecutor { _, args -&gt;
        val player = args[&quot;player&quot;] as Player
        val array = args[&quot;contents&quot;] as Array&lt;BaseComponent&gt;

        // Create book
        val item = ItemStack(Material.WRITTEN_BOOK)
        val meta = item.itemMeta as BookMeta
        meta.title = &quot;Custom Book&quot;
        meta.author = player.name
        meta.spigot().setPages(array)
        item.itemMeta = meta

        // Give player the book
        player.inventory.addItem(item)
    }
}
</code></pre>
</div>
</div>
<hr />
<h2 id="chat-argument"><a class="header" href="#chat-argument">Chat argument</a></h2>
<blockquote>
<p><strong>Note:</strong></p>
<p>The <code>ChatArgument</code> class is an argument similar to the <a href="./argument_strings.html#greedy-string-argument"><code>GreedyStringArgument</code></a>, in the sense that it has no terminator and must be defined at the end of your <code>List</code> of arguments. For more information on this, please read the section on <a href="./argument_strings.html#greedy-string-argument">Greedy arguments</a>.</p>
</blockquote>
<p>The <code>ChatArgument</code> is identical to the <code>GreedyStringArgument</code>, with the added functionality of enabling <em>entity selectors</em>, such as <code>@e</code>, <code>@p</code> and so on. The <code>ChatArgument</code> also returns a <code>BaseComponent[]</code>, similar to the <code>ChatComponentArgument</code>.</p>
<div class="example">
<h3 id="example---sending-personalized-messages-to-players"><a class="header" href="#example---sending-personalized-messages-to-players">Example - Sending personalized messages to players</a></h3>
<p>Say we wanted to broadcast a &quot;personalized&quot; message to players on the server. By &quot;personalized&quot;, we mean a command which changes its output depending on who we are sending the output to. Simply put, we want a command of the following syntax:</p>
<pre><code class="language-mccmd">/pbroadcast &lt;message&gt;
</code></pre>
<p>Say we're on a server with 2 players: <em>Bob</em> and <em>Michael</em>. If I were to use the following command:</p>
<pre><code class="language-mccmd">/pbroadcast Hello @p
</code></pre>
<p><em>Bob</em> would receive the message &quot;Hello Bob&quot;, whereas <em>Michael</em> would receive the message &quot;Hello Michael&quot;. We can use the <code>ChatArgument</code> to create this &quot;personalized&quot; broadcast:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;pbroadcast&quot;)
    .withArguments(new ChatArgument(&quot;message&quot;))
    .executes((sender, args) -&gt; {
        BaseComponent[] message = (BaseComponent[]) args.get(&quot;message&quot;);
    
        // Broadcast the message to everyone on the server
        Bukkit.getServer().spigot().broadcast(message);
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;pbroadcast&quot;)
    .withArguments(ChatArgument(&quot;message&quot;))
    .executes(CommandExecutor { _, args -&gt;
        val message = args[&quot;message&quot;] as Array&lt;BaseComponent&gt;

        // Broadcast the message to everyone on the server
        Bukkit.getServer().spigot().broadcast(*message)
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;pbroadcast&quot;) {
    chatArgument(&quot;message&quot;)
    anyExecutor { _, args -&gt;
        val message = args[&quot;message&quot;] as Array&lt;BaseComponent&gt;

        // Broadcast the message to everyone on the server
        Bukkit.getServer().spigot().broadcast(*message)
    }
}
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="adventure-chat-arguments"><a class="header" href="#adventure-chat-arguments">Adventure chat arguments</a></h1>
<blockquote>
<p><strong>Developer's Note:</strong></p>
<p>The two following classes, <code>AdventureChatComponentArgument</code> and <code>AdventureChatArgument</code> depend on a Paper based server which has the Adventure library. If you use this class on a server without the Adventure library, it will throw a <code>PaperAdventureNotFoundException</code></p>
</blockquote>
<p>From Paper 1.16.5 build #473 onwards, Paper now includes <a href="https://github.com/KyoriPowered/adventure-platform">Kyori's Adventure API</a>. This library is a replacement of the BungeeCord chat API and has all of the same functionality as the BungeeCord chat API (and more!). The documentation for this API can be found <a href="https://docs.adventure.kyori.net/index.html">here</a>.</p>
<p>Since this functions very similar to the Spigot chat arguments, this page won't reiterate everything about how it works, we'll just outline some examples of how to use these arguments instead.</p>
<hr />
<h2 id="adventure-chat-color-argument"><a class="header" href="#adventure-chat-color-argument">Adventure chat color argument</a></h2>
<p><img src="./images/arguments/chatcolor.png" alt="Chatcolor argument in-game, displaying a list of Minecraft chat colors" /></p>
<p>The <code>AdventureChatColorArgument</code> class is used to represent a given chat color (e.g. red or green). This argument returns the <code>NamedTextColor</code> object. If <code>reset</code> is passed to this argument, this will return <code>NamedTextColor.WHITE</code>.</p>
<div class="example">
<h3 id="example---username-color-changing-plugin-1"><a class="header" href="#example---username-color-changing-plugin-1">Example - Username color changing plugin</a></h3>
<p>Say we want to create a plugin to change the color of a player's username. We want to create a command of the following form:</p>
<pre><code class="language-mccmd">/namecolor &lt;chatcolor&gt;
</code></pre>
<p>We then use the <code>ChatColorArgument</code> to change the player's name color:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;namecolor&quot;)
    .withArguments(new AdventureChatColorArgument(&quot;chatcolor&quot;))
    .executesPlayer((player, args) -&gt; {
        NamedTextColor color = (NamedTextColor) args.get(&quot;chatcolor&quot;);
        player.displayName(Component.text().color(color).append(Component.text(player.getName())).build());
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;namecolor&quot;)
    .withArguments(AdventureChatColorArgument(&quot;chatcolor&quot;))
    .executesPlayer(PlayerCommandExecutor { player, args -&gt;
        val color = args[&quot;chatcolor&quot;] as NamedTextColor
        player.displayName(Component.text().color(color).append(Component.text(player.name)).build())
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;namecolor&quot;) {
    chatColorArgument(&quot;chatcolor&quot;)
    playerExecutor { player, args -&gt;
        val color = args[&quot;chatcolor&quot;] as NamedTextColor
        player.displayName(Component.text().color(color).append(Component.text(player.name)).build())
    }
}
</code></pre>
</div>
</div>
<hr />
<h2 id="adventure-chat-component-argument"><a class="header" href="#adventure-chat-component-argument">Adventure chat component argument</a></h2>
<p>The <code>AdventureChatComponentArgument</code> class accepts raw chat-based JSON as valid input, as declared <a href="https://minecraft.wiki/w/Raw_JSON_text_format">here</a>. This is converted into Adventure's <code>Component</code> class.</p>
<div class="example">
<h3 id="example---opening-a-book-with-raw-json-content"><a class="header" href="#example---opening-a-book-with-raw-json-content">Example - Opening a book with raw JSON content</a></h3>
<p>In this example, we'll create a simple command which lets you show a book to a user. The syntax for our command is as follows:</p>
<pre><code class="language-mccmd">/showbook &lt;target&gt; &lt;title&gt; &lt;author&gt; &lt;contents&gt;
</code></pre>
<p>We can construct a book using the Adventure API's <code>Book.book(Component, Component, Component...)</code> method. In order to convert our strings into <code>Component</code> objects, we use the <code>Component.text(String)</code> method. Since Paper supports the Adventure API natively, we can then send this book to a player using the <code>openBook(Book)</code> method:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;showbook&quot;)
    .withArguments(new PlayerArgument(&quot;target&quot;))
    .withArguments(new TextArgument(&quot;title&quot;))
    .withArguments(new StringArgument(&quot;author&quot;))
    .withArguments(new AdventureChatComponentArgument(&quot;contents&quot;))
    .executes((sender, args) -&gt; {
        Player target = (Player) args.get(&quot;target&quot;);
        String title = (String) args.get(&quot;title&quot;);
        String author = (String) args.get(&quot;author&quot;);
        Component content = (Component) args.get(&quot;contents&quot;);
        
        // Create a book and show it to the user (Requires Paper)
        Book mybook = Book.book(Component.text(title), Component.text(author), content);
        target.openBook(mybook);
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;showbook&quot;)
    .withArguments(PlayerArgument(&quot;target&quot;))
    .withArguments(TextArgument(&quot;title&quot;))
    .withArguments(StringArgument(&quot;author&quot;))
    .withArguments(AdventureChatComponentArgument(&quot;contents&quot;))
    .executes(CommandExecutor { _, args -&gt;
        val target = args[&quot;target&quot;] as Player
        val title = args[&quot;title&quot;] as String
        val author = args[&quot;author&quot;] as String
        val content = args[&quot;contents&quot;] as Component

        // Create a book and show it to the user (Requires Paper)
        val mybook = Book.book(Component.text(title), Component.text(author), content)
        target.openBook(mybook)
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;showbook&quot;) {
    playerArgument(&quot;target&quot;)
    textArgument(&quot;title&quot;)
    stringArgument(&quot;author&quot;)
    adventureChatComponentArgument(&quot;contents&quot;)
    anyExecutor { _, args -&gt;
        val target = args[&quot;target&quot;] as Player
        val title = args[&quot;title&quot;] as String
        val author = args[&quot;author&quot;] as String
        val content = args[&quot;contents&quot;] as Component

        // Create a book and show it to the user (Requires Paper)
        val mybook = Book.book(Component.text(title), Component.text(author), content)
        target.openBook(mybook)
    }
}
</code></pre>
</div>
</div>
<hr />
<h2 id="adventure-chat-argument"><a class="header" href="#adventure-chat-argument">Adventure chat argument</a></h2>
<p>The <code>AdventureChatArgument</code> class is the equivalent Adventure API class for the <code>ChatArgument</code> - it represents infinitely long strings similar to the <code>GreedyStringArgument</code> and allows entity selectors such as <code>@e</code>, <code>@p</code> and so on. The <code>AdventureChatArgument</code> returns a <code>Component</code>, similar to the <code>AdventureChatComponentArgument</code>.</p>
<div class="example">
<h3 id="example---sending-personalized-messages-to-players-1"><a class="header" href="#example---sending-personalized-messages-to-players-1">Example - Sending personalized messages to players</a></h3>
<p>We'll take the same example from the <code>ChatArgument</code> class, but using the <code>AdventureChatArgument</code> instead - We want to create a personalized message broadcasted to all users using a chat component that allows entity selectors. For this command, we want the following syntax:</p>
<pre><code class="language-mccmd">/pbroadcast &lt;message&gt;
</code></pre>
<p>In order to broadcast an Adventure <code>Component</code> to all players on the server, we have to use Paper's <code>broadcast(Component, String)</code> method. This method requires a permission node which all players must have in order to receive the broadcasted message. By default, Bukkit-based servers (Spigot and Paper) use the <code>bukkit.broadcast.user</code> permission, which is described <a href="https://bukkit.fandom.com/wiki/CraftBukkit_Commands#Additional_Permissions">here</a>:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;pbroadcast&quot;)
    .withArguments(new AdventureChatArgument(&quot;message&quot;))
    .executes((sender, args) -&gt; {
        Component message = (Component) args.get(&quot;message&quot;);
        
        // Broadcast the message to everyone with broadcast permissions.
        Bukkit.getServer().broadcast(message, Server.BROADCAST_CHANNEL_USERS);
        Bukkit.getServer().broadcast(message);
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;pbroadcast&quot;)
    .withArguments(AdventureChatArgument(&quot;message&quot;))
    .executes(CommandExecutor { _, args -&gt;
        val message = args[&quot;message&quot;] as Component

        // Broadcast the message to everyone with broadcast permissions.
        Bukkit.getServer().broadcast(message, Server.BROADCAST_CHANNEL_USERS)
        Bukkit.getServer().broadcast(message)
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;pbroadcast&quot;) {
    adventureChatArgument(&quot;message&quot;)
    anyExecutor { _, args -&gt;
        val message = args[&quot;message&quot;] as Component

        // Broadcast the message to everyone with broadcast permissions.
        Bukkit.getServer().broadcast(message, Server.BROADCAST_CHANNEL_USERS)
        Bukkit.getServer().broadcast(message)
    }
}
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chat-preview"><a class="header" href="#chat-preview">Chat preview</a></h1>
<p><img src="./images/chatpreview.gif" alt="Chat preview" /></p>
<p>Chat preview is a feature introduced in Minecraft 1.19 that allows the server to display a preview of a chat message to the client before the client sends their message to the server. This chat preview feature is also compatible with <code>/say</code> and <code>/msg</code>, as well as the <code>ChatArgument</code> and <code>AdventureChatArgument</code> classes.</p>
<div class="warning">
<h2 id="minecraft-version-support"><a class="header" href="#minecraft-version-support">Minecraft version support</a></h2>
<p>The chat preview feature is only present in Minecraft versions 1.19, 1.19.1 and 1.19.2. <a href="https://minecraft.wiki/w/Java_Edition_1.19.3#General_2">Chat preview was removed in 1.19.3</a>, so this feature is unfortunately no longer usable in Minecraft 1.19.3 and beyond.</p>
</div>
<hr />
<h2 id="enabling-chat-preview"><a class="header" href="#enabling-chat-preview">Enabling chat preview</a></h2>
<p>To use chat preview, your server must have <code>previews-chat</code> set to <code>true</code> in the <code>server.properties</code> file:</p>
<pre><code class="language-properties">...
previews-chat=true
...
</code></pre>
<p>For players that want to use chat preview, they must have <code>Chat Preview</code> enabled in <code>Options &gt; Chat Settings...</code></p>
<hr />
<h2 id="specifying-a-chat-preview-function"><a class="header" href="#specifying-a-chat-preview-function">Specifying a chat preview function</a></h2>
<p>The <code>ChatArgument</code> and <code>AdventureChatArgument</code> classes include a method, <code>withPreview</code>:</p>
<pre><code class="language-java">public T withPreview(PreviewableFunction preview);
</code></pre>
<p>The method <code>withPreview(PreviewableFunction preview)</code> lets you generate a preview to send to the client. This method takes in the <code>PreviewableFunction</code> functional interface, which is a function that takes in a <code>PreviewInfo</code> and returns either a <code>BaseComponent[]</code> (for <code>ChatArgument</code>) or a <code>Component</code> (for <code>AdventureChatArgument</code>):</p>
<pre><code class="language-java">public T generatePreview(PreviewInfo info) throws WrapperCommandSyntaxException;
</code></pre>
<p>The <code>PreviewInfo</code> class is a record containing the following:</p>
<pre><code class="language-java">public record PreviewInfo&lt;T&gt; {
    Player player();
    String input();
    String fullInput();
    T parsedInput();
}
</code></pre>
<p>The following methods are as follows:</p>
<pre><code class="language-java">Player player();
</code></pre>
<p><code>player()</code> is the player that is currently typing a chat preview.</p>
<hr />
<pre><code class="language-java">String input();
</code></pre>
<p><code>input()</code> is the current input for the current <code>ChatArgument</code> or <code>AdventureChatArgument</code>. If a user is typing <code>/mycommand hellowor¦</code> and the command syntax is <code>/mycommand &lt;ChatArgument&gt;</code>, the result of <code>input()</code> would be <code>&quot;hellowor&quot;</code>.</p>
<hr />
<pre><code class="language-java">String fullInput();
</code></pre>
<p><code>fullInput()</code> is the full input that the player has typed, including the leading <code>/</code> symbol which is required to start a command. If a user is typing <code>/mycommand hellowor¦</code>, the result of <code>fullInput()</code> would be <code>&quot;/mycommand hellowor&quot;</code>.</p>
<hr />
<pre><code class="language-java">T parsedInput();
</code></pre>
<p><code>parsedInput()</code> is similar to <code>input()</code>, except it has been parsed by the CommandAPI's argument parser. This is a representation of what the argument in the executor would look like. For a <code>ChatArgument</code> the return type is <code>BaseComponent[]</code>, and for <code>AdventureChatArgument</code> the return type is <code>Component</code>.</p>
<hr />
<h2 id="using-the-chat-preview-function-as-the-arguments-value"><a class="header" href="#using-the-chat-preview-function-as-the-arguments-value">Using the chat preview function as the argument's value</a></h2>
<p>The <code>ChatArgument</code> and <code>AdventureChatArgument</code> classes also include a method, <code>usePreview</code>:</p>
<pre><code class="language-java">public T usePreview(boolean usePreview);
</code></pre>
<p>The <code>usePreview(boolean usePreview)</code> method lets you specify whether you would like the previewing function to be used as the argument's value during execution. If set to <code>true</code>, when the command's <code>.executes()</code> method is called, the argument value (e.g. <code>arg[0]</code>) will be the same as the content generated by the function provided to <code>withPreview()</code>.</p>
<hr />
<h2 id="chat-preview-examples"><a class="header" href="#chat-preview-examples">Chat preview examples</a></h2>
<div class="example">
<h3 id="example---using-chat-preview"><a class="header" href="#example---using-chat-preview">Example - Using chat preview</a></h3>
<p>Say we wanted to make our own <code>/broadcast</code> command that allowed the user to use <code>&amp;</code> chat colors. We can use chat preview to show users what the result of their <code>/broadcast</code> command would look like before running the command. We'll use the following command syntax:</p>
<pre><code class="language-mccmd">/broadcast &lt;message&gt;
</code></pre>
<p>Because the <code>ChatArgument</code> and <code>AdventureChatArgument</code> can support entity selectors (such as <code>@p</code>), it's best to use the <code>info.parsedInput()</code> method to handle parsed entity selectors. In our code, we use the <code>.withPreview()</code> method and take the parsed input and convert it to plain text. We then convert the plain text with <code>&amp;</code> characters into component text to be displayed to the user.</p>
<p>For execution, we do the same procedure, because the text that the user enters still has <code>&amp;</code> characters that need to be converted into a component.</p>
<div class="multi-pre">
<pre><code class="language-java Spigot_(Java)">new CommandAPICommand(&quot;broadcast&quot;)
    .withArguments(new ChatArgument(&quot;message&quot;).withPreview(info -&gt; {
        // Convert parsed BaseComponent[] to plain text
        String plainText = BaseComponent.toPlainText(info.parsedInput());

        // Translate the &amp; in plain text and generate a new BaseComponent[]
        return TextComponent.fromLegacyText(ChatColor.translateAlternateColorCodes('&amp;', plainText));
    }))
    .executesPlayer((player, args) -&gt; {
        // The user still entered legacy text. We need to properly convert this
        // to a BaseComponent[] by converting to plain text then to BaseComponent[]
        String plainText = BaseComponent.toPlainText((BaseComponent[]) args.get(&quot;message&quot;));
        Bukkit.spigot().broadcast(TextComponent.fromLegacyText(ChatColor.translateAlternateColorCodes('&amp;', plainText)));
    })
    .register();
</code></pre>
<pre><code class="language-java Paper_(Java)">new CommandAPICommand(&quot;broadcast&quot;)
    .withArguments(new AdventureChatArgument(&quot;message&quot;).withPreview(info -&gt; {
        // Convert parsed Component to plain text
        String plainText = PlainTextComponentSerializer.plainText().serialize(info.parsedInput());

        // Translate the &amp; in plain text and generate a new Component
        return LegacyComponentSerializer.legacyAmpersand().deserialize(plainText);
    }))
    .executesPlayer((player, args) -&gt; {
        // The user still entered legacy text. We need to properly convert this
        // to a Component by converting to plain text then to Component
        String plainText = PlainTextComponentSerializer.plainText().serialize((Component) args.get(&quot;broadcast&quot;));
        Bukkit.broadcast(LegacyComponentSerializer.legacyAmpersand().deserialize(plainText));
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Spigot_(Kotlin)">CommandAPICommand(&quot;broadcast&quot;)
    .withArguments(ChatArgument(&quot;message&quot;).withPreview { info -&gt;
        // Convert parsed BaseComponent[] to plain text
        val plainText: String = BaseComponent.toPlainText(*info.parsedInput() as Array&lt;BaseComponent&gt;)

        // Translate the &amp; in plain text and generate a new BaseComponent[]
        TextComponent.fromLegacyText(ChatColor.translateAlternateColorCodes('&amp;', plainText))
    } )
    .executesPlayer(PlayerCommandExecutor { _, args -&gt;
        // The user still entered legacy text. We need to properly convert this
        // to a BaseComponent[] by converting to plain text then to BaseComponent[]
        val plainText: String = BaseComponent.toPlainText(*args[&quot;message&quot;] as Array&lt;BaseComponent&gt;)
        val baseComponents: Array&lt;BaseComponent&gt; = TextComponent.fromLegacyText(ChatColor.translateAlternateColorCodes('&amp;', plainText))
        Bukkit.spigot().broadcast(*baseComponents)
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Paper_(Kotlin)">CommandAPICommand(&quot;broadcast&quot;)
    .withArguments(AdventureChatArgument(&quot;message&quot;).withPreview { info -&gt;
        // Convert parsed Component to plain text
        val plainText: String = PlainTextComponentSerializer.plainText().serialize(info.parsedInput() as Component)

        // Translate the &amp; in plain text and generate a new Component
        LegacyComponentSerializer.legacyAmpersand().deserialize(plainText)
    } )
    .executesPlayer(PlayerCommandExecutor { _, args -&gt;
        // The user still entered legacy text. We need to properly convert this
        // to a Component by converting to plain text then to Component
        val plainText: String = PlainTextComponentSerializer.plainText().serialize(args[&quot;message&quot;] as Component)
        Bukkit.broadcast(LegacyComponentSerializer.legacyAmpersand().deserialize(plainText))
    })
    .register()
</code></pre>
</div>
</div>
<div class="example">
<h3 id="example---using-chat-preview-with-usepreview"><a class="header" href="#example---using-chat-preview-with-usepreview">Example - Using chat preview with <code>usePreview()</code></a></h3>
<p>Extending on the example above where we created a <code>/broadcast</code> command with chat preview support, we can simplify the code by using <code>.usePreview(true)</code> to use the preview function as the value of our argument in our executor function. We'll use the same command syntax as the previous example:</p>
<pre><code class="language-mccmd">/broadcast &lt;message&gt;
</code></pre>
<p>By using <code>.usePreview(true)</code>, we don't have to re-translate <code>&amp;</code> formatting codes into their corresponding components because that has already been done by the preview function specified in <code>.withPreview()</code> method.</p>
<div class="multi-pre">
<pre><code class="language-java Spigot_(Java)">new CommandAPICommand(&quot;broadcast&quot;)
    .withArguments(new ChatArgument(&quot;message&quot;).usePreview(true).withPreview(info -&gt; {
        // Convert parsed BaseComponent[] to plain text
        String plainText = BaseComponent.toPlainText(info.parsedInput());

        // Translate the &amp; in plain text and generate a new BaseComponent[]
        return TextComponent.fromLegacyText(ChatColor.translateAlternateColorCodes('&amp;', plainText));
    }))
    .executesPlayer((player, args) -&gt; {
        Bukkit.spigot().broadcast((BaseComponent[]) args.get(&quot;message&quot;));
    })
    .register();
</code></pre>
<pre><code class="language-java Paper_(Java)">new CommandAPICommand(&quot;broadcast&quot;)
    .withArguments(new AdventureChatArgument(&quot;message&quot;).usePreview(true).withPreview(info -&gt; {
        // Convert parsed Component to plain text
        String plainText = PlainTextComponentSerializer.plainText().serialize(info.parsedInput());

        // Translate the &amp; in plain text and generate a new Component
        return LegacyComponentSerializer.legacyAmpersand().deserialize(plainText);
    }))
    .executesPlayer((player, args) -&gt; {
        Bukkit.broadcast((Component) args.get(&quot;message&quot;));
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Spigot_(Kotlin)">CommandAPICommand(&quot;broadcast&quot;)
    .withArguments(ChatArgument(&quot;message&quot;).usePreview(true).withPreview { info -&gt;
        // Convert parsed BaseComponent[] to plain text
        val plainText = BaseComponent.toPlainText(*info.parsedInput() as Array&lt;BaseComponent&gt;)

        // Translate the &amp; in plain text and generate a new BaseComponent[]
        TextComponent.fromLegacyText(ChatColor.translateAlternateColorCodes('&amp;', plainText))
    } )
    .executesPlayer(PlayerCommandExecutor { _, args -&gt;
        Bukkit.spigot().broadcast(*args[&quot;message&quot;] as Array&lt;BaseComponent&gt;)
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Paper_(Kotlin)">CommandAPICommand(&quot;broadcast&quot;)
    .withArguments(AdventureChatArgument(&quot;message&quot;).usePreview(true).withPreview { info -&gt;
        // Convert parsed Component to plain text
        val plainText = PlainTextComponentSerializer.plainText().serialize(info.parsedInput() as Component)

        // Translate the &amp; in plain text and generate a new Component
        LegacyComponentSerializer.legacyAmpersand().deserialize(plainText)
    } )
    .executesPlayer(PlayerCommandExecutor { _, args -&gt;
        Bukkit.broadcast(args[&quot;message&quot;] as Component)
    })
    .register()
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="entity--player-arguments"><a class="header" href="#entity--player-arguments">Entity &amp; player arguments</a></h1>
<h2 id="entity-selector-argument"><a class="header" href="#entity-selector-argument">Entity selector argument</a></h2>
<p><img src="./images/arguments/entityselector.png" alt="An image of an entity selector argument with a list of suggestions including entity selectors and a player name" /></p>
<p>Minecraft's <a href="https://minecraft.wiki/w/Commands#Target_selectors">target selectors</a> (e.g. <code>@a</code> or <code>@e</code>) are implemented using the subclasses of the <code>EntitySelectorArgument</code> class. This allows you to select specific entities based on certain attributes.</p>
<p>There are four <code>EntitySelectorArgument</code> subclasses that determine what type of data to return:</p>
<ul>
<li><code>EntitySelectorArgument.OneEntity</code> - A single entity, which returns a <code>Entity</code> object.</li>
<li><code>EntitySelectorArgument.ManyEntities</code>  - A collection of many entities, which returns a <code>Collection&lt;Entity&gt;</code> object.</li>
<li><code>EntitySelectorArgument.OnePlayer</code> - A single player, which returns a <code>Player</code> object.</li>
<li><code>EntitySelectorArgument.ManyPlayers</code> - A collection of players, which returns a <code>Collection&lt;Player&gt;</code> object.</li>
</ul>
<p>The return type is the type to be cast when retrieved from the <a href="./commandarguments.html"><code>CommandArguments args</code></a> in the command declaration.</p>
<div class="example">
<h3 id="example---remove-entities-command"><a class="header" href="#example---remove-entities-command">Example - Remove entities command</a></h3>
<p>Say we want a command to remove certain types of entities. Typically, this would be implemented using a simple command like:</p>
<pre><code class="language-mccmd">/remove &lt;player&gt;
/remove &lt;mob type&gt;
/remove &lt;radius&gt;
</code></pre>
<p>Instead, we can combine all of these into one by using the <code>EntitySelectorArgument</code>. We want to be able to target multiple entities at a time, so we want to use the <code>EntitySelectorArgument.ManyEntities</code> constructor. We can simply retrieve the <code>Collection&lt;Entity&gt;</code> from this argument and iteratively remove each entity:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;remove&quot;)
    // Using a collective entity selector to select multiple entities
    .withArguments(new EntitySelectorArgument.ManyEntities(&quot;entities&quot;))
    .executes((sender, args) -&gt; {
        // Parse the argument as a collection of entities (as stated above in the documentation)
        @SuppressWarnings(&quot;unchecked&quot;)
        Collection&lt;Entity&gt; entities = (Collection&lt;Entity&gt;) args.get(&quot;entities&quot;);
        
        sender.sendMessage(&quot;Removed &quot; + entities.size() + &quot; entities&quot;);
        for (Entity e : entities) {
            e.remove();
        }
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;remove&quot;)
    // Using a collective entity selector to select multiple entities
    .withArguments(EntitySelectorArgument.ManyEntities(&quot;entities&quot;))
    .executes(CommandExecutor { sender, args -&gt;
        // Parse the argument as a collection of entities (as stated above in the documentation)
        val entities = args[&quot;entities&quot;] as Collection&lt;Entity&gt;

        sender.sendMessage(&quot;Removed ${entities.size} entities&quot;)
        for (e in entities) {
            e.remove()
        }
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;remove&quot;) {
    // Using a collective entity selector to select multiple entities
    entitySelectorArgumentManyEntities(&quot;entities&quot;)
    anyExecutor { sender, args -&gt;
        // Parse the argument as a collection of entities (as stated above in the documentation)
        val entities = args[&quot;entities&quot;] as Collection&lt;Entity&gt;

        sender.sendMessage(&quot;Removed ${entities.size} entities&quot;)
        for (e in entities) {
            e.remove()
        }
    }
}
</code></pre>
</div>
<p>We could then use this to target specific entities, for example:</p>
<ul>
<li>
<p>To remove all cows:</p>
<pre><code class="language-mccmd">/remove @e[type=cow]
</code></pre>
</li>
<li>
<p>To remove the 10 furthest pigs from the command sender:</p>
<pre><code class="language-mccmd">/remove @e[type=pig,limit=10,sort=furthest]
</code></pre>
</li>
</ul>
</div>
<hr />
<h2 id="player-argument"><a class="header" href="#player-argument">Player argument</a></h2>
<p>The <code>PlayerArgument</code> class is very similar <em>(almost identical)</em> to <code>EntitySelectorArgument.OnePlayer</code>. It returns a <code>Player</code> object and requires the player to be online.</p>
<blockquote>
<p><strong>Developer's Note:</strong></p>
<p>The <code>PlayerArgument</code> internally uses the <code>GameProfile</code> class from Mojang's authlib, which means that this argument has a slight performance overhead compared to using <code>EntitySelectorArgument.OnePlayer</code></p>
</blockquote>
<div class="example">
<h3 id="example---playerargument-without-entity-selectors"><a class="header" href="#example---playerargument-without-entity-selectors">Example - PlayerArgument without entity selectors</a></h3>
<p>When registering a <code>PlayerArgument</code> you might notice that it includes <code>Entity Selectors</code> (<code>@a</code>, <code>@e</code>, <code>@r</code>, etc.). If you want to avoid those, you can use argument suggestions to only suggest the player names. For this example, let us create a /warp command:</p>
<pre><code class="language-mccmd">/warp &lt;player&gt;
</code></pre>
<p>To get a <code>PlayerArgument</code> which only suggests the actual names, we can define it like this:</p>
<div class="multi-pre">
<pre><code class="language-java Java">Argument&lt;?&gt; noSelectorSuggestions = new PlayerArgument(&quot;target&quot;)
    .replaceSafeSuggestions(SafeSuggestions.suggest(info -&gt;
        Bukkit.getOnlinePlayers().toArray(new Player[0])
    ));
</code></pre>
<pre><code class="language-kotlin Kotlin">val noSelectorSuggestions = PlayerArgument(&quot;target&quot;)
    .replaceSafeSuggestions(SafeSuggestions.suggest {
        Bukkit.getOnlinePlayers().toTypedArray()
    })
</code></pre>
</div>
<p>Now we can define the rest of the command and include our suggestion inside of it like this:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;warp&quot;)
    .withArguments(noSelectorSuggestions)
    .executesPlayer((player, args) -&gt; {
        Player target = (Player) args.get(&quot;target&quot;);
        player.teleport(target);
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;warp&quot;)
    .withArguments(noSelectorSuggestions)
    .executesPlayer(PlayerCommandExecutor { player, args -&gt;
        val target = args[&quot;target&quot;] as Player
        player.teleport(target)
    })
    .register()
</code></pre>
</div>
<p>And there we have it! One thing to note is that entity selectors are still a valid input, they are just not included in the suggestions.
<img src="./images/entityselectorplayerexample.gif" alt="WarpCommand" /></p>
</div>
<hr />
<h2 id="offlineplayer-argument"><a class="header" href="#offlineplayer-argument">OfflinePlayer argument</a></h2>
<p>The <code>OfflinePlayerArgument</code> class is identical to the <code>PlayerArgument</code> class, but instead of returning a <code>Player</code> object, it returns an <code>OfflinePlayer</code> object. Internally, this argument makes calls to Mojang servers (via Mojang's authlib), meaning it can be slightly slower than alternative methods (such as using a <code>StringArgument</code> and suggesting a list of existing offline players).</p>
<p>The <code>OfflinePlayerArgument</code> <em>should</em> be able to retrieve players that have never joined the server before.</p>
<hr />
<h2 id="entity-type-argument"><a class="header" href="#entity-type-argument">Entity type argument</a></h2>
<p><img src="./images/arguments/entitytype.png" alt="An image of an entity argument displaying a list of entity type suggestions" /></p>
<p>The <code>EntityTypeArgument</code> class is used to retrieve a type of entity as defined in the <a href="https://hub.spigotmc.org/javadocs/bukkit/org/bukkit/entity/EntityType.html"><code>EntityType</code></a> enum. In other words, this is an entity type, for example a pig or a zombie.</p>
<div class="example">
<h3 id="example---spawning-entities"><a class="header" href="#example---spawning-entities">Example - Spawning entities</a></h3>
<p>Say we want a command to spawn a specific type of entity, similar to the <code>/summon</code> command in Vanilla Minecraft, with the addition of specifying how many entities to spawn. We want to create a command of the following form:</p>
<pre><code class="language-mccmd">/spawnmob &lt;entity&gt; &lt;amount&gt;
</code></pre>
<p>Since we're trying to specify an entity type, we will use the <code>EntityTypeArgument</code> as our argument type for <code>&lt;entity&gt;</code>. We combine this with the <code>IntegerArgument</code> class with a specified range of \( 1 \le \textit{amount} \le 100 \):</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;spawnmob&quot;)
    .withArguments(new EntityTypeArgument(&quot;entity&quot;))
    .withArguments(new IntegerArgument(&quot;amount&quot;, 1, 100)) // Prevent spawning too many entities
    .executesPlayer((Player player, CommandArguments args) -&gt; {
        for (int i = 0; i &lt; (int) args.get(&quot;amount&quot;); i++) {
            player.getWorld().spawnEntity(player.getLocation(), (EntityType) args.get(&quot;entity&quot;));
        }
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;spawnmob&quot;)
    .withArguments(EntityTypeArgument(&quot;entity&quot;))
    .withArguments(IntegerArgument(&quot;amount&quot;, 1, 100)) // Prevent spawning too many entities
    .executesPlayer(PlayerCommandExecutor { player, args -&gt;
        for (i in 0 until args[&quot;amount&quot;] as Int) {
            player.world.spawnEntity(player.location, args[&quot;entity&quot;] as EntityType)
        }
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;spawnmob&quot;) {
    entityTypeArgument(&quot;entity&quot;)
    integerArgument(&quot;amount&quot;, 1, 100) // Prevent spawning too many entities
    playerExecutor { player, args -&gt;
        for (i in 0 until args[&quot;amount&quot;] as Int) {
            player.world.spawnEntity(player.location, args[&quot;entity&quot;] as EntityType)
        }
    }
}
</code></pre>
</div>
<p>Note how in this example above, we have to explicitly state <code>Player player, CommandArguments args</code>. This is due to a limitation of Java's type inference system which is discussed <a href="./commandregistration.html#setting-the-commands-executor">here</a>.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scoreboard-arguments"><a class="header" href="#scoreboard-arguments">Scoreboard arguments</a></h1>
<p>The scoreboard arguments that the CommandAPI provides allows you to interact with various scoreboard elements, such as objectives, teams and score holders.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scoreboard-arguments-1"><a class="header" href="#scoreboard-arguments-1">Scoreboard arguments</a></h1>
<p>The CommandAPI uses two classes to provide information about a scoreboard:</p>
<ul>
<li>The <code>ScoreHolderArgument</code> class represents <strong>score holder</strong> - a player's name or an entity's UUID that has scores in an objective. This is described in more detail <a href="https://minecraft.wiki/w/Scoreboard#Objectives">on the Minecraft Wiki</a>.</li>
<li>The <code>ScoreboardSlotArgument</code> class represents a <strong>display slot</strong> (sidebar, list or belowName) as well as the team color if the display is the sidebar. This is described in more detail <a href="https://minecraft.wiki/w/Scoreboard#Display_slots">on the Minecraft Wiki</a>.</li>
</ul>
<hr />
<h2 id="score-holder-argument"><a class="header" href="#score-holder-argument">Score holder argument</a></h2>
<p>The score holder argument can accept either a single entity or a collection of multiple entities. In order to specify which one to use, you must use the <code>ScoreHolderArgument.Single</code> or <code>ScoreHolderArgument.Multiple</code> constructor respectively:</p>
<pre><code class="language-java">new ScoreHolderArgument.Single(nodeName);
new ScoreHolderArgument.Multiple(nodeName);
</code></pre>
<p>Depending on which constructor is used, the cast type changes. If you use <code>ScoreHolderArgument.Single</code>, the argument must be casted to a <code>String</code>. Otherwise, if you use <code>ScoreHolderArgument.Multiple</code>, the argument must be casted to a <code>Collection&lt;String&gt;</code>.</p>
<div class="example">
<h3 id="example---rewarding-players-with-scoreboard-objectives"><a class="header" href="#example---rewarding-players-with-scoreboard-objectives">Example - Rewarding players with scoreboard objectives</a></h3>
<p>Say we want to reward all players that fit a certain criteria. We want a command with the following syntax:</p>
<pre><code class="language-mccmd">/reward &lt;players&gt;
</code></pre>
<p>Since we could have multiple players that fit a certain criterion, we want to use <code>ScoreHolderArgument.Multiple</code> constructor.</p>
<p>To give this example a bit more context, let's say we want to reward all players that have died less than 10 times in the server. To do this, we will use the following command:</p>
<pre><code class="language-mccmd">/reward @e[type=player,scores={deaths=..9}]
</code></pre>
<p>Note how we use <code>..9</code> to represent 9 or less deaths (since ranges are inclusive). Also note how we restrict our input to players via the command using <code>type=player</code>. We can now implement our command:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;reward&quot;)
    // We want multiple players, so we use ScoreHolderType.MULTIPLE in the constructor
    .withArguments(new ScoreHolderArgument.Multiple(&quot;players&quot;))
    .executes((sender, args) -&gt; {
        // Get player names by casting to Collection&lt;String&gt;
        @SuppressWarnings(&quot;unchecked&quot;)
        Collection&lt;String&gt; players = (Collection&lt;String&gt;) args.get(&quot;players&quot;);
        
        for (String playerName : players) {
            Bukkit.getPlayer(playerName).getInventory().addItem(new ItemStack(Material.DIAMOND, 3));
        }
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;reward&quot;)
    // We want multiple players, so we use the ScoreHolderArgument.Multiple constructor
    .withArguments(ScoreHolderArgument.Multiple(&quot;players&quot;))
    .executes(CommandExecutor { _, args -&gt;
        // Get player names by casting to Collection&lt;String&gt;
        val players = args[&quot;players&quot;] as Collection&lt;String&gt;

        for (playerName in players) {
            Bukkit.getPlayer(playerName)?.inventory!!.addItem(ItemStack(Material.DIAMOND, 3))
        }
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;reward&quot;) {
    // We want multiple players, so we use the scoreHolderArgumentMultiple method
    scoreHolderArgumentMultiple(&quot;player&quot;)
    anyExecutor { _, args -&gt;
        // Get player names by casting to Collection&lt;String&gt;
        val players = args[&quot;player&quot;] as Collection&lt;String&gt;

        for (playerName in players) {
            Bukkit.getPlayer(playerName)?.inventory!!.addItem(ItemStack(Material.DIAMOND, 3))
        }
    }
}
</code></pre>
</div>
</div>
<blockquote>
<p><strong>Developer's Note:</strong></p>
<p>In the example above, we have our user use the <code>@e[type=player]</code> entity selector to restrict the <code>Collection&lt;String&gt;</code> so it only returns player names, which allows us to use <code>Bukkit.getPlayer(playerName)</code>. In practice, we cannot guarantee that such a selector will be used, so we could update the code to accept both entities and players. For example, we can differentiate between players and entities by using the <code>UUID.fromString(String)</code> method:</p>
<pre><code class="language-java">Collection&lt;String&gt; entitiesAndPlayers = (Collection&lt;String&gt;) args.get(0);
for(String str : entitiesAndPlayers) {
    try {
        UUID uuid = UUID.fromString(str);
        // Is a UUID, so it must by an entity
        Bukkit.getEntity(uuid);
    } catch(IllegalArgumentException exception) {
        // Not a UUID, so it must be a player name
        Bukkit.getPlayer(str); 
    }
}
</code></pre>
</blockquote>
<hr />
<h2 id="scoreboard-slot-argument"><a class="header" href="#scoreboard-slot-argument">Scoreboard slot argument</a></h2>
<p><img src="./images/arguments/scoreboardslot.png" alt="A scoreboardslotargument showing a list of suggestions of valid Minecraft scoreboard slot positions" /></p>
<p>The <code>ScoreboardSlotArgument</code> represents where scoreboard information is displayed. Since the Bukkit scoreboard <code>DisplaySlot</code> is not able to represent the case where team colors are provided, the CommandAPI uses the <code>ScoreboardSlot</code> wrapper class as the representation of the <code>ScoreboardSlotArgument</code>.</p>
<h3 id="scoreboardslot-wrapper"><a class="header" href="#scoreboardslot-wrapper"><code>ScoreboardSlot</code> wrapper</a></h3>
<p>The <code>ScoreboardSlot</code> wrapper class has 3 main methods:</p>
<pre><code class="language-java">enum ScoreboardSlot {

    PLAYER_LIST,
    SIDEBAR, // Unused, use the other SIDEBAR_TEAM_### values below
    BELOW_NAME,
    SIDEBAR_TEAM_BLACK,
    SIDEBAR_TEAM_DARK_BLUE,
    SIDEBAR_TEAM_DARK_GREEN,
    SIDEBAR_TEAM_DARK_AQUA,
    SIDEBAR_TEAM_DARK_RED,
    SIDEBAR_TEAM_DARK_PURPLE,
    SIDEBAR_TEAM_GOLD,
    SIDEBAR_TEAM_GRAY,
    SIDEBAR_TEAM_DARK_GRAY,
    SIDEBAR_TEAM_BLUE,
    SIDEBAR_TEAM_GREEN,
    SIDEBAR_TEAM_AQUA,
    SIDEBAR_TEAM_RED,
    SIDEBAR_TEAM_LIGHT_PURPLE,
    SIDEBAR_TEAM_YELLOW,
    SIDEBAR_TEAM_WHITE;

    public DisplaySlot getDisplaySlot();
    public ChatColor getTeamColor();
    public boolean hasTeamColor();

    public NamespacedKey getKey();
}
</code></pre>
<p>The <code>getDisplaySlot()</code> method returns the display slot that was chosen. Sidebar scoreboard colors can be accessed via <code>ScoreboardSlot.SIDEBAR_TEAM_###</code>. You can also retrieve the color using the <code>getTeamColor()</code> method.</p>
<div class="example">
<h3 id="example---clearing-objectives-in-a-scoreboard-slot"><a class="header" href="#example---clearing-objectives-in-a-scoreboard-slot">Example - Clearing objectives in a scoreboard slot</a></h3>
<p>Say we want to clear all objectives in a specific scoreboard slot. In this example, we will use the main server scoreboard, which is accessed using <code>Bukkit.getScoreboardManager.getMainScoreboard()</code>. We want a command with the following syntax:</p>
<pre><code class="language-mccmd">/clearobjectives &lt;slot&gt;
</code></pre>
<p>We implement this simply by using the <code>ScoreboardSlotArgument</code> as our argument, and then we can clear the slot using the scoreboard <code>clearSlot(DisplaySlot)</code> method.</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;clearobjectives&quot;)
    .withArguments(new ScoreboardSlotArgument(&quot;slot&quot;))
    .executes((sender, args) -&gt; {
        Scoreboard scoreboard = Bukkit.getScoreboardManager().getMainScoreboard();
        DisplaySlot slot = ((ScoreboardSlot) args.get(&quot;slot&quot;)).getDisplaySlot();
        scoreboard.clearSlot(slot);
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;clearobjectives&quot;)
    .withArguments(ScoreboardSlotArgument(&quot;slot&quot;))
    .executes(CommandExecutor { _, args -&gt;
        val scoreboard = Bukkit.getScoreboardManager().mainScoreboard
        val slot = (args[&quot;slot&quot;] as ScoreboardSlot).displaySlot
        scoreboard.clearSlot(slot)
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;clearobjectives&quot;) {
    scoreboardSlotArgument(&quot;slot&quot;)
    anyExecutor { _, args -&gt;
        val scoreboard = Bukkit.getScoreboardManager().mainScoreboard
        val slot = (args[&quot;slot&quot;] as ScoreboardSlot).displaySlot
        scoreboard.clearSlot(slot)
    }
}
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="objective-arguments"><a class="header" href="#objective-arguments">Objective arguments</a></h1>
<p>In the CommandAPI, objectives are split into two classes:</p>
<ul>
<li>The <code>ObjectiveArgument</code> class, which represents objectives as a whole</li>
<li>The <code>ObjectiveCriteriaArgument</code> class, which represents objective criteria</li>
</ul>
<hr />
<h2 id="objective-argument"><a class="header" href="#objective-argument">Objective argument</a></h2>
<p>The objective argument refers to a single scoreboard objective.</p>
<div class="example">
<h3 id="example---move-objective-to-sidebar"><a class="header" href="#example---move-objective-to-sidebar">Example - Move objective to sidebar</a></h3>
<p>As an example, let's create a command to move an objective to a player's sidebar. To do this, we will use the following command syntax:</p>
<pre><code class="language-mccmd">/sidebar &lt;objective&gt;
</code></pre>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;sidebar&quot;)
    .withArguments(new ObjectiveArgument(&quot;objective&quot;))
    .executes((sender, args) -&gt; {
        Objective objective = (Objective) args.get(&quot;objective&quot;);
        
        // Set display slot
        objective.setDisplaySlot(DisplaySlot.SIDEBAR);
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;sidebar&quot;)
    .withArguments(ObjectiveArgument(&quot;objective&quot;))
    .executes(CommandExecutor { _, args -&gt;
        val objective = args[&quot;objective&quot;] as Objective

        // Set display slot
        objective.displaySlot = DisplaySlot.SIDEBAR
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;sidebar&quot;) {
    objectiveArgument(&quot;objective&quot;)
    anyExecutor { _, args -&gt;
        val objective = args[&quot;objective&quot;] as Objective

        // Set display slot
        objective.displaySlot = DisplaySlot.SIDEBAR
    }
}
</code></pre>
</div>
</div>
<hr />
<h2 id="objective-criteria-argument"><a class="header" href="#objective-criteria-argument">Objective criteria argument</a></h2>
<p>The <code>ObjectiveCriteriaArgument</code> is fairly straight forward - it represents the criteria for an objective. Similar to Bukkit, the objective criteria is simply represented as a <code>String</code>, so it must be casted to a <code>String</code> when being used.</p>
<div class="example">
<h3 id="example---unregister-all-objectives-by-criteria"><a class="header" href="#example---unregister-all-objectives-by-criteria">Example - Unregister all objectives by criteria</a></h3>
<p>Say we wanted to create a command to unregister all objectives based on a given criteria. Let's create a command with the following form:</p>
<pre><code class="language-mccmd">/unregisterall &lt;objective critera&gt;
</code></pre>
<p>To do this, we're going to take advantage of Bukkit's <code>Scoreboard.getObjectivesByCriteria(String)</code> method</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;unregisterall&quot;)
    .withArguments(new ObjectiveCriteriaArgument(&quot;objective criteria&quot;))
    .executes((sender, args) -&gt; {
        String objectiveCriteria = (String) args.get(&quot;objective criteria&quot;);
        Set&lt;Objective&gt; objectives = Bukkit.getScoreboardManager().getMainScoreboard().getObjectivesByCriteria(objectiveCriteria);
        
        // Unregister the objectives
        for (Objective objective : objectives) {
            objective.unregister();
        }
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;unregisterall&quot;)
    .withArguments(ObjectiveCriteriaArgument(&quot;objective criteria&quot;))
    .executes(CommandExecutor { _, args -&gt;
        val objectiveCriteria = args[&quot;objective criteria&quot;] as String
        val objectives = Bukkit.getScoreboardManager().mainScoreboard.getObjectivesByCriteria(objectiveCriteria)

        // Unregister the objectives
        for (objective in objectives) {
            objective.unregister()
        }
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;unregisterall&quot;) {
    objectiveCriteriaArgument(&quot;objective criteria&quot;)
    anyExecutor { _, args -&gt;
        val objectiveCriteria = args[&quot;objective criteria&quot;] as String
        val objectives = Bukkit.getScoreboardManager().mainScoreboard.getObjectivesByCriteria(objectiveCriteria)

        // Unregister the objectives
        for (objective in objectives) {
            objective.unregister()
        }
    }
}
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="team-arguments"><a class="header" href="#team-arguments">Team arguments</a></h1>
<p>The <code>TeamArgument</code> class interacts with the Minecraft scoreboard and represents a team.</p>
<div class="example">
<h3 id="example---toggling-friendly-fire-in-a-team"><a class="header" href="#example---toggling-friendly-fire-in-a-team">Example - Toggling friendly fire in a team</a></h3>
<p>Let's say we want to create a command to toggle the state of friendly fire in a team. We want a command of the following form</p>
<pre><code class="language-mccmd">/togglepvp &lt;team&gt;
</code></pre>
<p>To do this, given a team we want to use the <code>setAllowFriendlyFire(boolean)</code> function.</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;togglepvp&quot;)
    .withArguments(new TeamArgument(&quot;team&quot;))
    .executes((sender, args) -&gt; {
        Team team = (Team) args.get(&quot;team&quot;);
        
        // Toggle pvp
        team.setAllowFriendlyFire(team.allowFriendlyFire());
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;togglepvp&quot;)
    .withArguments(TeamArgument(&quot;team&quot;))
    .executes(CommandExecutor { _, args -&gt;
        val team = args[&quot;team&quot;] as Team

        // Toggle pvp
        team.setAllowFriendlyFire(team.allowFriendlyFire())
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;togglepvp&quot;) {
    teamArgument(&quot;team&quot;)
    anyExecutor { _, args -&gt;
        val team = args[&quot;team&quot;] as Team

        // Toggle pvp
        team.setAllowFriendlyFire(team.allowFriendlyFire())
    }
}
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="miscellaneous-arguments"><a class="header" href="#miscellaneous-arguments">Miscellaneous arguments</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="angle-arguments"><a class="header" href="#angle-arguments">Angle arguments</a></h1>
<p>The angle argument is used to represent the <em>yaw</em> (horizontal) angle in degrees. The value returned from this argument range from -180.0 (inclusive) to 180 (exclusive), with -180.0 being due north:</p>
<p>\begin{align}
-1&amp;80.0 \\
&amp;\hspace{0.1em}N \\
&amp;\uparrow \\
90.0\ W \leftarrow &amp;\hspace{0.75em}\rightarrow E\  -90.0 \\
&amp;\downarrow \\
&amp;\hspace{0.2em}S \\
&amp;0.0 \\
\end{align}</p>
<p>The <code>~</code> notation can be used to specify a rotation relative to the executor's yaw angle.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advancement-arguments"><a class="header" href="#advancement-arguments">Advancement arguments</a></h1>
<p><img src="./images/arguments/advancement.png" alt="An advancement argument suggesting a list of Minecraft advancements" /></p>
<p>The <code>AdvancementArgument</code> class represents in-game advancements. As expected, the <code>AdvancementArgument</code> can be casted to Bukkit's <code>Advancement</code> class.</p>
<div class="example">
<h3 id="example---awarding-a-player-an-advancement"><a class="header" href="#example---awarding-a-player-an-advancement">Example - Awarding a player an advancement</a></h3>
<p>Say we want to award a player an advancement. First, we need the syntax that our command will use:</p>
<pre><code class="language-mccmd">/award &lt;player&gt; &lt;advancement&gt;
</code></pre>
<p>Since we require a player, we will use the <code>PlayerArgument</code> for this example. Given a player, we can simply get the <code>AdvancementProgress</code> for that player, and then award the criteria required to fully complete the provided advancement.</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;award&quot;)
    .withArguments(new PlayerArgument(&quot;player&quot;))
    .withArguments(new AdvancementArgument(&quot;advancement&quot;))
    .executes((sender, args) -&gt; {
        Player target = (Player) args.get(&quot;player&quot;);
        Advancement advancement = (Advancement) args.get(&quot;advancement&quot;);
        
        // Award all criteria for the advancement
        AdvancementProgress progress = target.getAdvancementProgress(advancement);
        for (String criteria : advancement.getCriteria()) {
            progress.awardCriteria(criteria);
        }
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;award&quot;)
    .withArguments(PlayerArgument(&quot;player&quot;))
    .withArguments(AdvancementArgument(&quot;advancement&quot;))
    .executes(CommandExecutor { _, args -&gt;
        val target = args[&quot;player&quot;] as Player
        val advancement = args[&quot;advancement&quot;] as Advancement

        // Award all criteria for the advancement
        val progress = target.getAdvancementProgress(advancement)
        for (criteria in advancement.criteria) {
            progress.awardCriteria(criteria)
        }
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;award&quot;) {
    playerArgument(&quot;player&quot;)
    advancementArgument(&quot;advancement&quot;)
    anyExecutor { _, args -&gt;
        val target = args[&quot;player&quot;] as Player
        val advancement = args[&quot;advancement&quot;] as Advancement

        // Award all criteria for the advancement
        val progress = target.getAdvancementProgress(advancement)
        for (criteria in advancement.criteria) {
            progress.awardCriteria(criteria)
        }
    }
}
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="biome-arguments"><a class="header" href="#biome-arguments">Biome arguments</a></h1>
<p><img src="./images/arguments/biome.png" alt="A biome argument suggesting a list of Minecraft biomes" /></p>
<p>In Minecraft 1.16, they added the ability to refer to in-game biomes. The CommandAPI implements this using the <code>BiomeArgument</code>. As expected, this returns Bukkit's <code>Biome</code> enum when used.</p>
<div class="warning">
<p>When using the <code>Biome</code> object, the CommandAPI will return <code>null</code> if the specified <code>Biome</code> could not be found, for example if a player submitted a biome from a client-side resourcepack. The CommandAPI does <strong>not</strong> return <code>Biome.CUSTOM</code> from the <code>BiomeArgument</code>.</p>
</div>
<div class="example">
<h3 id="example---setting-the-biome-of-a-chunk"><a class="header" href="#example---setting-the-biome-of-a-chunk">Example - Setting the biome of a chunk</a></h3>
<p>Say you want to set the biome of the current chunk that a player is in. We can do this using the <code>World.setBiome(x, y, z, biome)</code> method for a given world. We will use this command syntax to set the biome of our current chunk:</p>
<pre><code class="language-mccmd">/setbiome &lt;biome&gt;
</code></pre>
<p>And we can set the biome of the current chunk as expected:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;setbiome&quot;)
    .withArguments(new BiomeArgument(&quot;biome&quot;))
    .executesPlayer((player, args) -&gt; {
        Biome biome = (Biome) args.get(&quot;biome&quot;);

        Chunk chunk = player.getLocation().getChunk();
        player.getWorld().setBiome(chunk.getX(), player.getLocation().getBlockY(), chunk.getZ(), biome);
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;setbiome&quot;)
    .withArguments(BiomeArgument(&quot;biome&quot;))
    .executesPlayer(PlayerCommandExecutor { player, args -&gt;
        val biome = args[&quot;biome&quot;] as Biome

        val chunk = player.location.chunk
        player.world.setBiome(chunk.x, player.location.blockY, chunk.z, biome)
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;setbiome&quot;) {
    biomeArgument(&quot;biome&quot;)
    playerExecutor { player, args -&gt;
        val biome = args[&quot;biome&quot;] as Biome

        val chunk = player.location.chunk
        player.world.setBiome(chunk.x, player.location.blockY, chunk.z, biome)
    }
}
</code></pre>
</div>
</div>
<p>The <code>BiomeArgument</code> also supports returning a <code>NamespacedKey</code> for custom biomes. This can be done by using the <code>BiomeArgument.NamespacedKey</code> constructor instead of the normal <code>BiomeArgument</code> constructor:</p>
<pre><code class="language-java">// Makes a BiomeArgument that returns a Biome
new BiomeArgument(&quot;biome&quot;);

// Makes a BiomeArgument that returns a NamespacedKey
new BiomeArgument.NamespacedKey(&quot;biome&quot;);
</code></pre>
<blockquote>
<p><strong>Developer's Note:</strong></p>
<p>Spigot's support for custom biomes is really limited! If you have an example that lets you use custom biomes with namespaced keys, please open a GitHub issue, or reach out to us on Discord!</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blockstate-arguments"><a class="header" href="#blockstate-arguments">BlockState arguments</a></h1>
<p><img src="./images/arguments/blockstate.png" alt="A block state argument with suggestions for Minecraft items" /></p>
<p>The <code>BlockStateArgument</code> is used to represent data about blocks in the world. These refer to any blocks that have data or states, such as dispensers, signs, doors and pistons. The <code>BlockStateArgument</code> creates a Bukkit <code>BlockData</code> object when used.</p>
<blockquote>
<p><strong>Developer's Note:</strong></p>
<p>Make sure to not confuse the cast type with <code>BlockState</code>. The naming of this argument refers to the internal Minecraft vanilla argument naming convention - <strong>this argument casts to <code>BlockData</code> and NOT <code>BlockState</code></strong>.</p>
</blockquote>
<div class="example">
<h3 id="example---setting-a-block"><a class="header" href="#example---setting-a-block">Example - Setting a block</a></h3>
<p>Say we want a simple command to set the block that you're looking at. We'll use the following command syntax:</p>
<pre><code class="language-mccmd">/set &lt;block&gt;
</code></pre>
<p>And then we can simply set our block using <code>setBlockData()</code>:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;set&quot;)
    .withArguments(new BlockStateArgument(&quot;block&quot;))
    .executesPlayer((player, args) -&gt; {
        BlockData blockdata = (BlockData) args.get(&quot;block&quot;);
        Block targetBlock = player.getTargetBlockExact(256);
        
        // Set the block, along with its data
        targetBlock.setType(blockdata.getMaterial());
        targetBlock.getState().setBlockData(blockdata);
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;set&quot;)
    .withArguments(BlockStateArgument(&quot;block&quot;))
    .executesPlayer(PlayerCommandExecutor { player, args -&gt;
        val blockdata = args[&quot;block&quot;] as BlockData
        val targetBlock = player.getTargetBlockExact(256)

        // Set the block, along with its data
        targetBlock?.type = blockdata.material
        targetBlock?.state?.blockData = blockdata
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;set&quot;) {
    blockStateArgument(&quot;block&quot;)
    playerExecutor { player, args -&gt;
        val blockdata = args[&quot;block&quot;] as BlockData
        val targetBlock = player.getTargetBlockExact(256)

        // Set the block, along with its data
        targetBlock?.type = blockdata.material
        targetBlock?.state?.blockData = blockdata
    }
}
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enchantment-argument"><a class="header" href="#enchantment-argument">Enchantment argument</a></h1>
<p><img src="./images/arguments/enchantment.png" alt="An enchantment argument suggesting a list of Minecraft enchantments" /></p>
<p>The <code>EnchantmentArgument</code> class lets users input a specific enchantment. As you would expect, the cast type is Bukkit's <code>Enchantment</code> class.</p>
<div class="example">
<h3 id="example---giving-a-player-an-enchantment-on-their-current-item"><a class="header" href="#example---giving-a-player-an-enchantment-on-their-current-item">Example - Giving a player an enchantment on their current item</a></h3>
<p>Say we want to give a player an enchantment on the item that the player is currently holding. We will use the following command syntax:</p>
<pre><code class="language-mccmd">/enchantitem &lt;enchantment&gt; &lt;level&gt;
</code></pre>
<p>Since most enchantment levels range between 1 and 5, we will also make use of the <code>IntegerArgument</code> to restrict the level of the enchantment by usng its range constructor.</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;enchantitem&quot;)
    .withArguments(new EnchantmentArgument(&quot;enchantment&quot;))
    .withArguments(new IntegerArgument(&quot;level&quot;, 1, 5))
    .executesPlayer((player, args) -&gt; {
        Enchantment enchantment = (Enchantment) args.get(&quot;enchantment&quot;);
        int level = (int) args.get(&quot;level&quot;);
        
        // Add the enchantment
        player.getInventory().getItemInMainHand().addEnchantment(enchantment, level);
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;enchantitem&quot;)
    .withArguments(EnchantmentArgument(&quot;enchantment&quot;))
    .withArguments(IntegerArgument(&quot;level&quot;, 1, 5))
    .executesPlayer(PlayerCommandExecutor { player, args -&gt;
        val enchantment = args[&quot;enchantment&quot;] as Enchantment
        val level = args[&quot;level&quot;] as Int

        // Add the enchantment
        player.inventory.itemInMainHand.addEnchantment(enchantment, level)
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;enchantitem&quot;) {
    enchantmentArgument(&quot;enchantment&quot;)
    integerArgument(&quot;level&quot;, 1, 5)
    playerExecutor { player, args -&gt;
        val enchantment = args[&quot;enchantment&quot;] as Enchantment
        val level = args[&quot;level&quot;] as Int

        // Add the enchantment
        player.inventory.itemInMainHand.addEnchantment(enchantment, level)
    }
}
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="itemstack-arguments"><a class="header" href="#itemstack-arguments">Itemstack arguments</a></h1>
<p><img src="./images/arguments/itemstack.png" alt="An item stack argument with suggestions for Minecraft items" /></p>
<p>The <code>ItemStackArgument</code> class represents in-game items. As expected, this should be casted to Bukkit's <code>ItemStack</code> object. The <code>ItemStack</code> which is returned by the <code>ItemStackArgument</code> always has a size of 1.</p>
<div class="example">
<h3 id="example---giving-a-player-an-itemstack"><a class="header" href="#example---giving-a-player-an-itemstack">Example - Giving a player an itemstack</a></h3>
<p>Say we want to create a command that gives you items. For this command, we will use the following syntax:</p>
<pre><code class="language-mccmd">/item &lt;itemstack&gt;
</code></pre>
<p>With this syntax, we can easily create our command:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;item&quot;)
    .withArguments(new ItemStackArgument(&quot;itemStack&quot;))
    .executesPlayer((player, args) -&gt; {
        player.getInventory().addItem((ItemStack) args.get(&quot;itemStack&quot;));
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;item&quot;)
    .withArguments(ItemStackArgument(&quot;itemStack&quot;))
    .executesPlayer(PlayerCommandExecutor { player, args -&gt;
        player.inventory.addItem(args[&quot;itemStack&quot;] as ItemStack)
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;item&quot;) {
    itemStackArgument(&quot;itemstack&quot;)
    playerExecutor { player, args -&gt;
        player.inventory.addItem(args[&quot;itemstack&quot;] as ItemStack)
    }
}
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loottable-argument"><a class="header" href="#loottable-argument">LootTable argument</a></h1>
<p><img src="./images/arguments/loottable.png" alt="A loot table argument showing a list of Minecraft loot tables as suggestions" /></p>
<p>The <code>LootTableArgument</code> class can be used to get a Bukkit <code>LootTable</code> object.</p>
<div class="example">
<h3 id="example---filling-a-chest-with-loot-table-contents"><a class="header" href="#example---filling-a-chest-with-loot-table-contents">Example - Filling a chest with loot table contents</a></h3>
<p>Say we wanted to write a command that populates a chest with some loot table contents. For this example, we'll use the following command:</p>
<pre><code class="language-mccmd">/giveloottable &lt;loottable&gt; &lt;location&gt;
</code></pre>
<p>We ensure that the location provided is a container (such as a chest or shulkerbox) and then update the contents of that container:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;giveloottable&quot;)
    .withArguments(new LootTableArgument(&quot;lootTable&quot;))
    .withArguments(new LocationArgument(&quot;location&quot;, LocationType.BLOCK_POSITION))
    .executes((sender, args) -&gt; {
        LootTable lootTable = (LootTable) args.get(&quot;lootTable&quot;);
        Location location = (Location) args.get(&quot;location&quot;);

        BlockState state = location.getBlock().getState();

        // Check if the input block is a container (e.g. chest)
        if (state instanceof Container container &amp;&amp; state instanceof Lootable lootable) {
            // Apply the loot table to the chest
            lootable.setLootTable(lootTable);
            container.update();
        }
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;giveloottable&quot;)
    .withArguments(LootTableArgument(&quot;lootTable&quot;))
    .withArguments(LocationArgument(&quot;location&quot;, LocationType.BLOCK_POSITION))
    .executes(CommandExecutor { _, args -&gt;
        val lootTable = args[&quot;lootTable&quot;] as LootTable
        val location = args[&quot;location&quot;] as Location

        val state = location.block.state

        // Check if the input block is a container (e.g. chest)
        if (state is Container &amp;&amp; state is Lootable) {
            // Apply the loot table to the chest
            state.lootTable = lootTable
            state.update()
        }
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;giveloottable&quot;) {
    lootTableArgument(&quot;loottable&quot;)
    locationArgument(&quot;location&quot;, LocationType.BLOCK_POSITION)
    anyExecutor { _, args -&gt;
        val lootTable = args[&quot;loottable&quot;] as LootTable
        val location = args[&quot;location&quot;] as Location

        val state = location.block.state

        // Check if the input block is a container (e.g. chest)
        if (state is Container &amp;&amp; state is Lootable) {
            // Apply the loot table to the chest
            state.lootTable = lootTable
            state.update()
        }
    }
}
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mathoperation-arguments"><a class="header" href="#mathoperation-arguments">MathOperation arguments</a></h1>
<p><img src="./images/arguments/mathop.png" alt="An image of the math operation argument, with suggestions &quot;%=&quot;, &quot;*=&quot;, &quot;+=&quot;, &quot;-=&quot;, &quot;/=&quot;, &quot;&lt;&quot;, &quot;=&quot;, &quot;&gt;&quot; and &quot;&gt;&lt;&quot;" /></p>
<p>The CommandAPI's <code>MathOperationArgument</code> is used to represent the Minecraft scoreboard arithmetic operation to alter scoreboard scores. Since there is no default representation in the Bukkit API, the CommandAPI provides the <code>MathOperation</code> class to represent each operation:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">Symbol (in Minecraft)</th><th>MathOperation enum value</th></tr></thead><tbody>
<tr><td style="text-align: center">\(+=\)</td><td><code>MathOperation.ADD</code></td></tr>
<tr><td style="text-align: center">\(-=\)</td><td><code>MathOperation.SUBTRACT</code></td></tr>
<tr><td style="text-align: center">\(*=\)</td><td><code>MathOperation.MULTIPLY</code></td></tr>
<tr><td style="text-align: center">\(/=\)</td><td><code>MathOperation.DIVIDE</code></td></tr>
<tr><td style="text-align: center">\(\%=\)</td><td><code>MathOperation.MOD</code></td></tr>
<tr><td style="text-align: center">\(=\)</td><td><code>MathOperation.ASSIGN</code></td></tr>
<tr><td style="text-align: center">\(&lt;\)</td><td><code>MathOperation.MIN</code></td></tr>
<tr><td style="text-align: center">\(&gt;\)</td><td><code>MathOperation.MAX</code></td></tr>
<tr><td style="text-align: center">\(&gt;&lt;\)</td><td><code>MathOperation.SWAP</code></td></tr>
</tbody></table>
</div>
<hr />
<p>The <code>MathOperation</code> also has two methods:</p>
<pre><code class="language-java">public int apply(int val1, int val2);
public float apply(float val1, float val2);
</code></pre>
<p>These methods are used to provide a basic implementation of these math operations on a given input. Given the values <code>val1</code> and <code>val2</code>, these are the operation that the <code>apply(val1, val2)</code> method performs:</p>
<div class="table-wrapper"><table><thead><tr><th>MathOperation enum value</th><th>Result</th></tr></thead><tbody>
<tr><td><code>MathOperation.ADD</code></td><td><code>val1 + val2</code></td></tr>
<tr><td><code>MathOperation.SUBTRACT</code></td><td><code>val1 - val2</code></td></tr>
<tr><td><code>MathOperation.MULTIPLY</code></td><td><code>val1 * val2</code></td></tr>
<tr><td><code>MathOperation.DIVIDE</code></td><td><code>val1 / val2</code></td></tr>
<tr><td><code>MathOperation.MOD</code></td><td><code>val1 % val2</code></td></tr>
<tr><td><code>MathOperation.ASSIGN</code></td><td><code>val2</code></td></tr>
<tr><td><code>MathOperation.MIN</code></td><td><code>Math.min(val1, val2)</code></td></tr>
<tr><td><code>MathOperation.MAX</code></td><td><code>Math.max(val1, val2)</code></td></tr>
<tr><td><code>MathOperation.SWAP</code></td><td><code>val2</code></td></tr>
</tbody></table>
</div>
<hr />
<div class="example">
<h3 id="example---changing-a-players-level"><a class="header" href="#example---changing-a-players-level">Example - Changing a player's level</a></h3>
<p>Say we wanted to create a player's level. Typically, this is implemented in the following manner:</p>
<pre><code class="language-mccmd">/xp set &lt;player&gt; &lt;level&gt;
/xp add &lt;player&gt; &lt;levels&gt;
</code></pre>
<p>Using the <code>MathOperationArgument</code>, we can extend the functionality of adding and setting a player's level by allowing the user to choose what operation they desire. To do this, we'll use the following syntax:</p>
<pre><code class="language-mccmd">/changelevel &lt;player&gt; &lt;operation&gt; &lt;value&gt;
</code></pre>
<p>As with any command, we declare our arguments, cast them properly and then we write our main code. In this example, we use the <code>apply(int, int)</code> method from our <code>MathOperation</code> to calculate the player's new level.</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;changelevel&quot;)
    .withArguments(new PlayerArgument(&quot;player&quot;))
    .withArguments(new MathOperationArgument(&quot;operation&quot;))
    .withArguments(new IntegerArgument(&quot;value&quot;))
    .executes((sender, args) -&gt; {
        Player target = (Player) args.get(&quot;player&quot;);
        MathOperation op = (MathOperation) args.get(&quot;operation&quot;);
        int value = (int) args.get(&quot;value&quot;);

        target.setLevel(op.apply(target.getLevel(), value));
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;changelevel&quot;)
    .withArguments(PlayerArgument(&quot;player&quot;))
    .withArguments(MathOperationArgument(&quot;operation&quot;))
    .withArguments(IntegerArgument(&quot;value&quot;))
    .executes(CommandExecutor { _, args -&gt;
        val target = args[&quot;player&quot;] as Player
        val op = args[&quot;operation&quot;] as MathOperation
        val value = args[&quot;value&quot;] as Int

        target.level = op.apply(target.level, value)
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;changelevel&quot;) {
    playerArgument(&quot;player&quot;)
    mathOperationArgument(&quot;operation&quot;)
    integerArgument(&quot;value&quot;)
    anyExecutor { _, args -&gt;
        val target = args[&quot;player&quot;] as Player
        val op = args[&quot;operation&quot;] as MathOperation
        val value = args[&quot;value&quot;] as Int

        target.level = op.apply(target.level, value)
    }
}
</code></pre>
</div>
<hr />
<p>There are various applications for the <code>changelevel</code> command based on what the user inputs. For example:</p>
<ul>
<li>
<p>To set the player <em>Notch</em> to level 10:</p>
<pre><code class="language-mccmd">/changelevel Notch = 10
</code></pre>
</li>
<li>
<p>To double the player <em>Notch's</em> level:</p>
<pre><code class="language-mccmd">/changelevel Notch *= 2
</code></pre>
</li>
<li>
<p>To set the player <em>Notch</em>'s level to 20, or keep it as their current level if it is higher than 20:</p>
<pre><code class="language-mccmd">/changelevel Notch &gt; 20
</code></pre>
</li>
</ul>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="namespacedkey-arguments"><a class="header" href="#namespacedkey-arguments">NamespacedKey arguments</a></h1>
<p>NamespacedKey arguments represent Minecraft's <a href="https://minecraft.wiki/w/Resource_location">resource locations</a>, or namespaced keys. This argument is casted to Bukkit's <code>NamespacedKey</code> object.</p>
<p>Namespaced keys are typically of the form <code>namespace:key</code>. If no namespace is provided, the default namespace (<code>minecraft</code>) will be used.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="particle-arguments"><a class="header" href="#particle-arguments">Particle arguments</a></h1>
<p><img src="./images/arguments/particle.png" alt="A particle argument suggesting a list of Minecraft particle effects" /></p>
<p>The <code>ParticleArgument</code> class represents Minecraft particles. This is casted to the CommandAPI's <code>ParticleData</code> class.</p>
<h2 id="the-particledata-class"><a class="header" href="#the-particledata-class">The <code>ParticleData</code> class</a></h2>
<p>The <code>ParticleData</code> class is a record that contains two values:</p>
<ul>
<li><code>Particle particle</code>, which is the Bukkit enum <code>Particle</code> representation of what particle was provided</li>
<li><code>T data</code>, which represents any additional particle data which was provided.</li>
</ul>
<pre><code class="language-java">public record ParticleData&lt;T&gt;(Particle particle, T data);
</code></pre>
<p>The <code>T data</code> can be used in Bukkit's <code>World.spawnParticle(Particle particle, Location location, int count, T data)</code> method.</p>
<h2 id="particle-data"><a class="header" href="#particle-data">Particle data</a></h2>
<p>Particle data depends on your version of Minecraft. In 1.20.5, Minecraft and Spigot updated their particle API and they are no longer compatible with each other. Information about how the CommandAPI uses particle data can be found using the links below:</p>
<ul>
<li><a href="./argument_particle_old.html">Particle data for Minecraft 1.16.5 - 1.20.4</a></li>
<li><a href="./argument_particle_new.html">Particle data for Minecraft 1.20.5+</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="particle-data-1165---1204"><a class="header" href="#particle-data-1165---1204">Particle data (1.16.5 - 1.20.4)</a></h1>
<p>The particle argument requires additional data for a particle depending on what the particle is. Information about this can be found <a href="https://minecraft.wiki/w/Argument_types#particle">on the Argument types page on the MinecraftWiki</a>. The following particles have additional data required to display them:</p>
<div class="table-wrapper"><table><thead><tr><th>Bukkit Particle</th><th>Minecraft particle</th><th>Arguments</th></tr></thead><tbody>
<tr><td><code>BLOCK_CRACK</code></td><td><code>block</code></td><td><code>block block_id</code><br><br><code>block block_id[block_state=value]</code></td></tr>
<tr><td><code>BLOCK_MARKER</code></td><td><code>block_marker</code></td><td><code>block_marker block_id</code><br><br><code>block_marker block_id[block_state=value]</code></td></tr>
<tr><td><code>REDSTONE</code></td><td><code>dust</code></td><td><code>dust red green blue size</code></td></tr>
<tr><td><code>DUST_COLOR_TRANSITION</code></td><td><code>dust_color_transition</code></td><td><code>dust_color_transition red1 green1 blue1 size red2 green2 blue2</code></td></tr>
<tr><td><code>FALLING_DUST</code></td><td><code>falling_dust</code></td><td><code>falling_dust block_id</code><br><br><code>falling_dust block_id[block_state=value]</code></td></tr>
<tr><td><code>ITEM_CRACK</code></td><td><code>item</code></td><td><code>item item_id</code><br><br><code>item item_id{NBT}</code></td></tr>
<tr><td><code>SCULK_CHARGE</code></td><td><code>sculk_charge</code></td><td><code>sculk_charge angle</code></td></tr>
<tr><td><code>SHRIEK</code></td><td><code>shriek</code></td><td><code>shriek delay</code></td></tr>
<tr><td><code>VIBRATION</code></td><td><code>vibration</code></td><td><code>vibration x y z ticks</code></td></tr>
</tbody></table>
</div>
<h2 id="particleargument-examples"><a class="header" href="#particleargument-examples">ParticleArgument examples</a></h2>
<p>Because certain particles (in the table above) require additional data, it is not recommended to spawn a particle without its corresponding data. This can result in particles not showing due to missing requirements.</p>
<div class="warning">
<h3 id="example---show-particles-at-a-players-location-without-data"><a class="header" href="#example---show-particles-at-a-players-location-without-data">Example - Show particles at a player's location (without data)</a></h3>
<p>Say we wanted to have a command that displayed particles at a player's location. We will use the following command syntax:</p>
<pre><code class="language-mccmd">/showparticle &lt;particle&gt;
</code></pre>
<p>With this, we can simply spawn the particle using the <code>World.spawnParticle(Particle, Location, int)</code> method:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;showparticle&quot;)
    .withArguments(new ParticleArgument(&quot;particle&quot;))
    .executesPlayer((player, args) -&gt; {
        ParticleData&lt;?&gt; particleData = (ParticleData&lt;?&gt;) args.get(&quot;particle&quot;);
        player.getWorld().spawnParticle(particleData.particle(), player.getLocation(), 1);
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;showparticle&quot;)
    .withArguments(ParticleArgument(&quot;particle&quot;))
    .executesPlayer(PlayerCommandExecutor { player, args -&gt;
        val particleData = args[&quot;particle&quot;] as ParticleData&lt;Any&gt;
        player.world.spawnParticle(particleData.particle(), player.location, 1)
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;showparticle&quot;) {
    particleArgument(&quot;particle&quot;)
    playerExecutor { player, args -&gt;
        val particleData = args[&quot;particle&quot;] as ParticleData&lt;Any&gt;
        player.world.spawnParticle(particleData.particle(), player.location, 1)
    }
}
</code></pre>
</div>
<p>Running this can result in errors due to missing requirements. If you provide a particle that has additional requirements, Bukkit will throw an error and the particle will not be displayed. Instead, the example below should be used.</p>
</div>
<div class="example">
<h3 id="example---show-particles--at-a-players-location-with-data"><a class="header" href="#example---show-particles--at-a-players-location-with-data">Example - Show particles  at a player's location (with data)</a></h3>
<p>We can fix the issues with the example above by providing the data of the argument using the <code>ParticleData</code> record:</p>
<pre><code class="language-mccmd">/showparticle &lt;particle&gt;
</code></pre>
<p>In this case, we'll use the <code>World.spawnParticle(Particle particle, Location location, int count, T data)</code> method which accepts some particle data:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;showparticle&quot;)
    .withArguments(new ParticleArgument(&quot;particle&quot;))
    .executesPlayer((player, args) -&gt; {
        ParticleData&lt;?&gt; particleData = (ParticleData&lt;?&gt;) args.get(&quot;particle&quot;);
        player.getWorld().spawnParticle(particleData.particle(), player.getLocation(), 1, particleData.data());
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;showparticle&quot;)
    .withArguments(ParticleArgument(&quot;particle&quot;))
    .executesPlayer(PlayerCommandExecutor { player, args -&gt;
        val particleData = args[&quot;particle&quot;] as ParticleData&lt;Any&gt;
        player.world.spawnParticle(particleData.particle(), player.location, 1, particleData.data())
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;showparticle&quot;) {
    particleArgument(&quot;particle&quot;)
    playerExecutor { player, args -&gt;
        val particleData = args[&quot;particle&quot;] as ParticleData&lt;Any&gt;
        player.world.spawnParticle(particleData.particle(), player.location, 1, particleData.data())
    }
}
</code></pre>
</div>
<p>This can be used with commands such as:</p>
<pre><code class="language-mccmd">/showparticle minecraft:dust_color_transition 0 0 0 20 1 0 0
/showparticle minecraft:block_marker diamond_block
</code></pre>
</div>
<h2 id="particle-data-implementation-notes"><a class="header" href="#particle-data-implementation-notes">Particle data implementation notes</a></h2>
<p>The <code>vibration</code> particle will return a particle data of the Bukkit <code>Vibration</code> class. In the <code>Vibration</code> class, you can access the destination location using the <code>Vibration.getDestination()</code> method, which returns a <code>Vibration.Destination</code> instance. The CommandAPI will <strong>always</strong> return a <code>Vibration.Destination.BlockDestination</code> instance, and will never return a <code>Vibration.Destination.EntityDestination</code> instance. An example of accessing the location can be found below:</p>
<pre><code class="language-java">ParticleData&lt;Vibration&gt; particleData; // The particle data you get from your argument
Location destination = ((BlockDestination) particleData.data().getDestination()).getLocation();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="particle-data-1205"><a class="header" href="#particle-data-1205">Particle data (1.20.5+)</a></h1>
<p>The particle argument requires additional data for a particle depending on what the particle is. The following particles have additional data required to display them:</p>
<!-- To whoever has to maintain this block, I am sorry! - Skepter -->
<table class="table-wrapper">
    <thead>
        <tr>
            <th>Bukkit Particle</th>
            <th>Argument syntax</th>
        </tr>
    </thead>
    <tr>
        <td><code>BLOCK</code></td>
        <td>
            <pre>block{block_state:{Name:<b>"block_name"</b>}}</pre>
            <ul style="padding-left: 1.5em;">
                <li><b><code>block_name</code></b> - name of a block, such as <code>diamond_block</code></li>
            </ul>
        </td>
    </tr>
    <tr>
        <td><code>BLOCK_MARKER</code></td>
        <td>
            <pre>block_marker{block_state:{Name:<b>"block_name"</b>}}</pre>
            <ul style="padding-left: 1.5em;">
                <li><b><code>block_name</code></b> - name of a block, such as <code>diamond_block</code></li>
            </ul>
        </td>
    </tr>
    <tr>
        <td><code>DUST</code></td>
        <td>
            <pre>dust{color:[<b>red</b>,<b>green</b>,<b>blue</b>],scale:<b>scale</b>}</pre>
            <ul style="padding-left: 1.5em;">
                <li><b><code>red</code></b> - number for red, between 0.0 and 1.0</li>
                <li><b><code>green</code></b> - number for green, between 0.0 and 1.0</li>
                <li><b><code>blue</code></b> - number for blue, between 0.0 and 1.0</li>
                <li><b><code>scale</code></b> - number for the size of the particle</li>
            </ul>
        </td>
    </tr>
    <tr>
        <td><code>DUST_COLOR_TRANSITION</code></td>
        <td>
            <pre>dust_color_transition{from_color:[<b>red</b>,<b>green</b>,<b>blue</b>],<br>scale:<b>scale</b>,to_color:[<b>red</b>,<b>green</b>,<b>blue</b>]}</pre>
            <ul style="padding-left: 1.5em;">
                <li><b><code>red</code></b> - number for red, between 0.0 and 1.0</li>
                <li><b><code>green</code></b> - number for green, between 0.0 and 1.0</li>
                <li><b><code>blue</code></b> - number for blue, between 0.0 and 1.0</li>
                <li><b><code>scale</code></b> - number for the size of the particle</li>
            </ul>
        </td>
    </tr>
    <tr>
        <td><code>DUST_PILLAR</code></td>
        <td>
            <pre>dust_pillar{block_state:{Name:<b>"block_name"</b>}}</pre>
            <ul style="padding-left: 1.5em;">
                <li><b><code>block_name</code></b> - name of a block, such as <code>diamond_block</code></li>
            </ul>
        </td>
    </tr>
    <tr>
        <td><code>ENTITY_EFFECT</code></td>
        <td>
            <pre>entity_effect{color:[<b>red</b>,<b>green</b>,<b>blue</b>,<b>alpha</b>]}</pre>
            <ul style="padding-left: 1.5em;">
                <li><b><code>red</code></b> - number for red, between 0.0 and 1.0</li>
                <li><b><code>green</code></b> - number for green, between 0.0 and 1.0</li>
                <li><b><code>blue</code></b> - number for blue, between 0.0 and 1.0</li>
                <li><b><code>alpha</code></b> - number for transparency, between 0.0 and 1.0</li>
            </ul>
        </td>
    </tr>
    <tr>
        <td><code>FALLING_DUST</code></td>
        <td>
            <pre>falling_dust{block_state:{Name:<b>"block_name"</b>}}</pre>
            <ul style="padding-left: 1.5em;">
                <li><b><code>block_name</code></b> - name of a block, such as <code>diamond_block</code></li>
            </ul>
        </td>
    </tr>
    <tr>
        <td><code>ITEM</code></td>
        <td>
            <pre>item{item:"<b>item</b>"}</pre>
            <ul style="padding-left: 1.5em;">
                <li><b><code>item</code></b> - name of an item, such as <code>apple</code></li>
            </ul>
        </td>
    </tr>
    <tr>
        <td><code>SCULK_CHARGE</code></td>
        <td>
            <pre>sculk_charge{roll:<b>angle</b>}</pre>
            <ul style="padding-left: 1.5em;">
                <li><b><code>angle</code></b> - decimal angle the particle displays at in radians</li>
            </ul>
        </td>
    </tr>
    <tr>
        <td><code>SHRIEK</code></td>
        <td>
            <pre>shriek{delay:<b>delay</b>}</pre>
            <ul style="padding-left: 1.5em;">
                <li><b><code>delay</code></b> - delay in ticks for when the shriek particle should appear</li>
            </ul>
        </td>
    </tr>
    <tr>
        <td><code>VIBRATION</code></td>
        <td>
            <pre>vibration{destination:{type:"block",pos:[<b>x</b>,<b>y</b>,<b>z</b>]},<br>arrival_in_ticks:<b>ticks</b>}</pre>
            <ul style="padding-left: 1.5em;">
                <li><b><code>x</code></b> - decimal x-coordinate to move towards</li>
                <li><b><code>y</code></b> - decimal y-coordinate to move towards</li>
                <li><b><code>z</code></b> - decimal z-coordinate to move towards</li>
                <li><b><code>ticks</code></b> - time in ticks to take to move towards its destination</li>
            </ul>
        </td>
    </tr>
</table>
<h2 id="particleargument-examples-1"><a class="header" href="#particleargument-examples-1">ParticleArgument examples</a></h2>
<p>Because certain particles (in the table above) require additional data, it is not recommended to spawn a particle without its corresponding data. This can result in particles not showing due to missing requirements.</p>
<div class="warning">
<h3 id="example---show-particles-at-a-players-location-without-data-1"><a class="header" href="#example---show-particles-at-a-players-location-without-data-1">Example - Show particles at a player's location (without data)</a></h3>
<p>Say we wanted to have a command that displayed particles at a player's location. We will use the following command syntax:</p>
<pre><code class="language-mccmd">/showparticle &lt;particle&gt;
</code></pre>
<p>With this, we can simply spawn the particle using the <code>World.spawnParticle(Particle, Location, int)</code> method:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;showparticle&quot;)
    .withArguments(new ParticleArgument(&quot;particle&quot;))
    .executesPlayer((player, args) -&gt; {
        ParticleData&lt;?&gt; particleData = (ParticleData&lt;?&gt;) args.get(&quot;particle&quot;);
        player.getWorld().spawnParticle(particleData.particle(), player.getLocation(), 1);
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;showparticle&quot;)
    .withArguments(ParticleArgument(&quot;particle&quot;))
    .executesPlayer(PlayerCommandExecutor { player, args -&gt;
        val particleData = args[&quot;particle&quot;] as ParticleData&lt;Any&gt;
        player.world.spawnParticle(particleData.particle(), player.location, 1)
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;showparticle&quot;) {
    particleArgument(&quot;particle&quot;)
    playerExecutor { player, args -&gt;
        val particleData = args[&quot;particle&quot;] as ParticleData&lt;Any&gt;
        player.world.spawnParticle(particleData.particle(), player.location, 1)
    }
}
</code></pre>
</div>
<p>Running this can result in errors due to missing requirements. If you provide a particle that has additional requirements, Bukkit will throw an error and the particle will not be displayed. Instead, the example below should be used.</p>
</div>
<div class="example">
<h3 id="example---show-particles--at-a-players-location-with-data-1"><a class="header" href="#example---show-particles--at-a-players-location-with-data-1">Example - Show particles  at a player's location (with data)</a></h3>
<p>We can fix the issues with the example above by providing the data of the argument using the <code>ParticleData</code> record:</p>
<pre><code class="language-mccmd">/showparticle &lt;particle&gt;
</code></pre>
<p>In this case, we'll use the <code>World.spawnParticle(Particle particle, Location location, int count, T data)</code> method which accepts some particle data:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;showparticle&quot;)
    .withArguments(new ParticleArgument(&quot;particle&quot;))
    .executesPlayer((player, args) -&gt; {
        ParticleData&lt;?&gt; particleData = (ParticleData&lt;?&gt;) args.get(&quot;particle&quot;);
        player.getWorld().spawnParticle(particleData.particle(), player.getLocation(), 1, particleData.data());
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;showparticle&quot;)
    .withArguments(ParticleArgument(&quot;particle&quot;))
    .executesPlayer(PlayerCommandExecutor { player, args -&gt;
        val particleData = args[&quot;particle&quot;] as ParticleData&lt;Any&gt;
        player.world.spawnParticle(particleData.particle(), player.location, 1, particleData.data())
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;showparticle&quot;) {
    particleArgument(&quot;particle&quot;)
    playerExecutor { player, args -&gt;
        val particleData = args[&quot;particle&quot;] as ParticleData&lt;Any&gt;
        player.world.spawnParticle(particleData.particle(), player.location, 1, particleData.data())
    }
}
</code></pre>
</div>
<p>This can be used with commands such as:</p>
<pre><code class="language-mccmd">/showparticle minecraft:dust_color_transition{from_color:[0.0,0.0,0.0],scale:20.0,to_color:[1.0,0.0,0.0]}
/showparticle minecraft:block_marker{block_state:{Name:&quot;diamond_block&quot;}}
</code></pre>
</div>
<h2 id="particle-data-implementation-notes-1"><a class="header" href="#particle-data-implementation-notes-1">Particle data implementation notes</a></h2>
<p>The <code>vibration</code> particle will return a particle data of the Bukkit <code>Vibration</code> class. In the <code>Vibration</code> class, you can access the destination location using the <code>Vibration.getDestination()</code> method, which returns a <code>Vibration.Destination</code> instance. The CommandAPI will <strong>always</strong> return a <code>Vibration.Destination.BlockDestination</code> instance, and will never return a <code>Vibration.Destination.EntityDestination</code> instance. An example of accessing the location can be found below:</p>
<pre><code class="language-java">ParticleData&lt;Vibration&gt; particleData; // The particle data you get from your argument
Location destination = ((BlockDestination) particleData.data().getDestination()).getLocation();
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="potion-effect-arguments"><a class="header" href="#potion-effect-arguments">Potion effect arguments</a></h1>
<p><img src="./images/arguments/potion.png" alt="An image of a potion argument with a list of potion effect suggestions" /></p>
<p>The <code>PotionEffectArgument</code> class represents Minecraft potion effects. When used, this argument is casted to Bukkit's <code>PotionEffectType</code> class, or alternatively a <code>NamespacedKey</code> object if the <code>PotionEffectArgument.NamespacedKey</code> argument is used to create a <code>PotionEffectArgument</code>.</p>
<div class="example">
<h3 id="example---giving-a-player-a-potion-effect"><a class="header" href="#example---giving-a-player-a-potion-effect">Example - Giving a player a potion effect</a></h3>
<p>Say we wanted to have a command that gives a player a potion effect. For this command, we'll use the following syntax:</p>
<pre><code class="language-mccmd">/potion &lt;target&gt; &lt;potion&gt; &lt;duration&gt; &lt;strength&gt;
</code></pre>
<p>In this example, we utilize some of the other arguments that we've described earlier, such as the <code>PlayerArgument</code> and <code>TimeArgument</code>. Since duration for the <code>PotionEffect</code> constructor is in ticks, this is perfectly fit for the <code>TimeArgument</code>, which is represented in ticks.</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;potion&quot;)
    .withArguments(new PlayerArgument(&quot;target&quot;))
    .withArguments(new PotionEffectArgument(&quot;potion&quot;))
    .withArguments(new TimeArgument(&quot;duration&quot;))
    .withArguments(new IntegerArgument(&quot;strength&quot;))
    .executes((sender, args) -&gt; {
        Player target = (Player) args.get(&quot;target&quot;);
        PotionEffectType potion = (PotionEffectType) args.get(&quot;potion&quot;);
        int duration = (int) args.get(&quot;duration&quot;);
        int strength = (int) args.get(&quot;strength&quot;);
        
        // Add the potion effect to the target player
        target.addPotionEffect(new PotionEffect(potion, duration, strength));
    })
    .register();
</code></pre>
<pre><code class="language-java Java_(NamespacedKey)">new CommandAPICommand(&quot;potion&quot;)
    .withArguments(new PlayerArgument(&quot;target&quot;))
    .withArguments(new PotionEffectArgument.NamespacedKey(&quot;potion&quot;))
    .withArguments(new TimeArgument(&quot;duration&quot;))
    .withArguments(new IntegerArgument(&quot;strength&quot;))
    .executes((sender, args) -&gt; {
        Player target = (Player) args.get(&quot;target&quot;);
        NamespacedKey potionKey = (NamespacedKey) args.get(&quot;potion&quot;);
        int duration = (int) args.get(&quot;duration&quot;);
        int strength = (int) args.get(&quot;strength&quot;);

        PotionEffectType potion = PotionEffectType.getByKey(potionKey);

        // Add the potion effect to the target player
        target.addPotionEffect(new PotionEffect(potion, duration, strength));
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;potion&quot;)
    .withArguments(PlayerArgument(&quot;target&quot;))
    .withArguments(PotionEffectArgument(&quot;potion&quot;))
    .withArguments(TimeArgument(&quot;duration&quot;))
    .withArguments(IntegerArgument(&quot;strength&quot;))
    .executes(CommandExecutor { _, args -&gt;
        val target = args[&quot;target&quot;] as Player
        val potion = args[&quot;potion&quot;] as PotionEffectType
        val duration = args[&quot;duration&quot;] as Int
        val strength = args[&quot;strength&quot;] as Int

        // Add the potion effect to the target player
        target.addPotionEffect(PotionEffect(potion, duration, strength))
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_(NamespacedKey)">CommandAPICommand(&quot;potion&quot;)
    .withArguments(PlayerArgument(&quot;target&quot;))
    .withArguments(PotionEffectArgument.NamespacedKey(&quot;potion&quot;))
    .withArguments(TimeArgument(&quot;duration&quot;))
    .withArguments(IntegerArgument(&quot;strength&quot;))
    .executes(CommandExecutor { _, args -&gt;
        val target = args[&quot;target&quot;] as Player
        val potionKey = args[&quot;potion&quot;] as NamespacedKey
        val duration = args[&quot;duration&quot;] as Int
        val strength = args[&quot;strength&quot;] as Int

        val potion = PotionEffectType.getByKey(potionKey)!!

        // Add the potion effect to the target player
        target.addPotionEffect(PotionEffect(potion, duration, strength))
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;potion&quot;) {
    playerArgument(&quot;target&quot;)
    potionEffectArgument(&quot;potion&quot;)
    timeArgument(&quot;duration&quot;)
    integerArgument(&quot;strength&quot;)
    anyExecutor { _, args -&gt;
        val target = args[&quot;target&quot;] as Player
        val potion = args[&quot;potion&quot;] as PotionEffectType
        val duration = args[&quot;duration&quot;] as Int
        val strength = args[&quot;strength&quot;] as Int

        // Add the potion effect to the target player
        target.addPotionEffect(PotionEffect(potion, duration, strength))
    }
}
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL_(NamespacedKey)">commandAPICommand(&quot;potion&quot;) {
    playerArgument(&quot;target&quot;)
    potionEffectArgument(&quot;potion&quot;, true)
    timeArgument(&quot;duration&quot;)
    integerArgument(&quot;strength&quot;)
    anyExecutor { _, args -&gt;
        val target = args[&quot;target&quot;] as Player
        val potionKey = args[&quot;potion&quot;] as NamespacedKey
        val duration = args[&quot;duration&quot;] as Int
        val strength = args[&quot;strength&quot;] as Int

        val potion = PotionEffectType.getByKey(potionKey)!!

        // Add the potion effect to the target player
        target.addPotionEffect(PotionEffect(potion, duration, strength))
    }
}
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="recipe-arguments"><a class="header" href="#recipe-arguments">Recipe arguments</a></h1>
<p><img src="./images/arguments/recipe.png" alt="A recipe argument command with the suggestions for Minecraft items" /></p>
<p>The <code>RecipeArgument</code> class lets you retrieve Bukkit's <code>ComplexRecipe</code> object.</p>
<div class="example">
<h3 id="example---giving-a-player-the-result-of-a-recipe"><a class="header" href="#example---giving-a-player-the-result-of-a-recipe">Example - Giving a player the result of a recipe</a></h3>
<p>Say we want to give yourself the result of a specific recipe. Since Bukkit's <code>Recipe</code> class contains the <code>getResult()</code> method, we will use that in our example. We want to create the following command:</p>
<pre><code class="language-mccmd">/giverecipe &lt;recipe&gt;
</code></pre>
<p>As such, we easily implement it by specifying the <code>RecipeArgument</code>, casting it and adding it to the player's inventory:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;giverecipe&quot;)
    .withArguments(new RecipeArgument(&quot;recipe&quot;))
    .executesPlayer((player, args) -&gt; {
        ComplexRecipe recipe = (ComplexRecipe) args.get(&quot;recipe&quot;);
        player.getInventory().addItem(recipe.getResult());
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;giverecipe&quot;)
    .withArguments(RecipeArgument(&quot;recipe&quot;))
    .executesPlayer(PlayerCommandExecutor { player, args -&gt;
        val recipe = args[&quot;recipe&quot;] as ComplexRecipe
        player.inventory.addItem(recipe.result)
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;giverecipe&quot;) {
    recipeArgument(&quot;recipe&quot;)
    playerExecutor { player, args -&gt;
        val recipe = args[&quot;recipe&quot;] as ComplexRecipe
        player.inventory.addItem(recipe.result)
    }
}
</code></pre>
</div>
</div>
<div class="example">
<h3 id="example---unlocking-a-recipe-for-a-player"><a class="header" href="#example---unlocking-a-recipe-for-a-player">Example - Unlocking a recipe for a player</a></h3>
<p>In this example, we'll use the <code>ComplexRecipe</code>'s <code>getKey()</code> method to write an example to to unlock a recipe for a player. For this command, we'll use the following syntax:</p>
<pre><code class="language-mccmd">/unlockrecipe &lt;player&gt; &lt;recipe&gt;
</code></pre>
<p>This is then implemented trivially as follows:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;unlockrecipe&quot;)
    .withArguments(new PlayerArgument(&quot;player&quot;))
    .withArguments(new RecipeArgument(&quot;recipe&quot;))
    .executes((sender, args) -&gt; {
        Player target = (Player) args.get(&quot;player&quot;);
        ComplexRecipe recipe = (ComplexRecipe) args.get(&quot;recipe&quot;);

        target.discoverRecipe(recipe.getKey());
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;unlockrecipe&quot;)
    .withArguments(PlayerArgument(&quot;player&quot;))
    .withArguments(RecipeArgument(&quot;recipe&quot;))
    .executes(CommandExecutor { _, args -&gt;
        val target = args[&quot;player&quot;] as Player
        val recipe = args[&quot;recipe&quot;] as ComplexRecipe

        target.discoverRecipe(recipe.key)
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;unlockrecipe&quot;) {
    playerArgument(&quot;player&quot;)
    recipeArgument(&quot;recipe&quot;)
    anyExecutor { _, args -&gt;
        val target = args[&quot;player&quot;] as Player
        val recipe = args[&quot;recipe&quot;] as ComplexRecipe

        target.discoverRecipe(recipe.key)
    }
}
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sound-arguments"><a class="header" href="#sound-arguments">Sound arguments</a></h1>
<p><img src="./images/arguments/sound.png" alt="A sound argument command with a list of Minecraft sounds as suggestions" /></p>
<p>The <code>SoundArgument</code> class allows a command sender to retrieve the Bukkit <code>Sound</code> or <code>NamespacedKey</code> object to represent in-game sound effects (such as mob sounds or ambient sound effects), as well as in-game music.</p>
<p>The <code>SoundArgument</code> can return a <code>Sound</code> or <code>NamespacedKey</code> object. To return a <code>Sound</code> object, simply use the <code>SoundArgument</code> as normal. To return a <code>NamespacedKey</code> object, use the <code>SoundArgument.NamespacedKey</code> constructor instead:</p>
<pre><code class="language-java">// Makes a SoundArgument that returns a Sound
new SoundArgument(&quot;sound&quot;);

// Makes a SoundArgument that returns a NamespacedKey
new SoundArgument.NamespacedKey(&quot;sound&quot;);
</code></pre>
<div class="warning">
<p>When using the <code>Sound</code> object, the CommandAPI will return <code>null</code> if the specified <code>Sound</code> could not be found. For this reason, it's recommended to use the <code>NamespacedKey</code> object for optimal compatibility with client-side resourcepacks.</p>
</div>
<div class="example">
<h3 id="example---playing-sound-to-yourself"><a class="header" href="#example---playing-sound-to-yourself">Example - Playing sound to yourself</a></h3>
<p>Say we want a simple command that plays a specific sound at your location. To do this, we will make the following command:</p>
<pre><code class="language-mccmd">/sound &lt;sound&gt;
</code></pre>
<p>This command simply plays the provided sound to the current player:</p>
<div class="multi-pre">
<pre><code class="language-java Java_(Sound)">new CommandAPICommand(&quot;sound&quot;)
    .withArguments(new SoundArgument(&quot;sound&quot;))
    .executesPlayer((player, args) -&gt; {
        player.getWorld().playSound(player.getLocation(), (Sound) args.get(&quot;sound&quot;), 100.0f, 1.0f);
    })
    .register();
</code></pre>
<pre><code class="language-java Java_(NamespacedKey)">new CommandAPICommand(&quot;sound&quot;)
    .withArguments(new SoundArgument.NamespacedKey(&quot;sound&quot;))
    .executesPlayer((player, args) -&gt; {
        player.getWorld().playSound(player.getLocation(), ((NamespacedKey) args.get(&quot;sound&quot;)).asString(), 100.0f, 1.0f);
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin_(Sound)">CommandAPICommand(&quot;sound&quot;)
    .withArguments(SoundArgument(&quot;sound&quot;))
    .executesPlayer(PlayerCommandExecutor { player, args -&gt;
        player.world.playSound(player.location, args[&quot;sound&quot;] as Sound, 100.0f, 1.0f)
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_(NamespacedKey)">CommandAPICommand(&quot;sound&quot;)
    .withArguments(SoundArgument.NamespacedKey(&quot;sound&quot;))
    .executesPlayer(PlayerCommandExecutor { player, args -&gt;
        player.world.playSound(player.location, (args[&quot;sound&quot;] as NamespacedKey).asString(), 100.0f, 1.0f)
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL_(Sound)">commandAPICommand(&quot;sound&quot;) {
    soundArgument(&quot;sound&quot;)
    playerExecutor { player, args -&gt;
        player.world.playSound(player.location, args[&quot;sound&quot;] as Sound, 100.0f, 1.0f)
    }
}
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL_(NamespacedKey)">commandAPICommand(&quot;sound&quot;) {
    soundArgument(&quot;sound&quot;, true)
    playerExecutor { player, args -&gt;
        player.world.playSound(player.location, (args[&quot;sound&quot;] as NamespacedKey).asString(), 100.0f, 1.0f)
    }
}
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="time-arguments"><a class="header" href="#time-arguments">Time arguments</a></h1>
<p><img src="./images/arguments/time.png" alt="A time argument with Minecraft suggestions 'd', 's' and 't'" /></p>
<p>The <code>TimeArgument</code> class represents in-game time, <em>in the number of in-game ticks</em>. This allows command senders to specify a certain number of ticks in a simpler way, by including the characters <code>d</code> to specify the numbers of days, <code>s</code> to specify the number of seconds or <code>t</code> to specify a number of ticks.</p>
<p>The CommandAPI converts the inputs provided by the command sender into a number of ticks as an integer.</p>
<blockquote>
<p><strong>Developer's Note:</strong></p>
<p>The <code>TimeArgument</code> provides inputs such as <code>2d</code> (2 in-game days), <code>10s</code> (10 seconds) and <code>20t</code> (20 ticks), but does <strong>not</strong> let you combine them, such as <code>2d10s</code>.</p>
</blockquote>
<div class="example">
<h3 id="example---displaying-a-server-wide-announcement"><a class="header" href="#example---displaying-a-server-wide-announcement">Example - Displaying a server-wide announcement</a></h3>
<p>Say we have a command <code>bigmsg</code> that displays a title message to all players for a certain duration:</p>
<pre><code class="language-mccmd">/bigmsg &lt;duration&gt; &lt;message&gt;
</code></pre>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;bigmsg&quot;)
    .withArguments(new TimeArgument(&quot;duration&quot;))
    .withArguments(new GreedyStringArgument(&quot;message&quot;))
    .executes((sender, args) -&gt; {
        // Duration in ticks
        int duration = (int) args.get(&quot;duration&quot;);
        String message = (String) args.get(&quot;message&quot;);

        for (Player player : Bukkit.getOnlinePlayers()) {
            // Display the message to all players, with the default fade in/out times (10 and 20).
            player.sendTitle(message, &quot;&quot;, 10, duration, 20);
        }
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;bigmsg&quot;)
    .withArguments(TimeArgument(&quot;duration&quot;))
    .withArguments(GreedyStringArgument(&quot;message&quot;))
    .executes(CommandExecutor { _, args -&gt;
        // Duration in ticks
        val duration = args[&quot;duration&quot;] as Int
        val message = args[&quot;message&quot;] as String

        for (player in Bukkit.getOnlinePlayers()) {
            // Display the message to all players, with the default fade in/out times (10 and 20).
            player.sendTitle(message, &quot;&quot;, 10, duration, 20)
        }
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;bigmsg&quot;) {
    timeArgument(&quot;duration&quot;)
    greedyStringArgument(&quot;message&quot;)
    anyExecutor { _, args -&gt;
        // Duration in ticks
        val duration = args[&quot;duration&quot;] as Int
        val message = args[&quot;message&quot;] as String

        for (player in Bukkit.getOnlinePlayers()) {
            // Display the message to all players, with the default fade in/out times (10 and 20).
            player.sendTitle(message, &quot;&quot;, 10, duration, 20)
        }
    }
}
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uuid-arguments"><a class="header" href="#uuid-arguments">UUID arguments</a></h1>
<p>The UUID argument is used to uniquely identify players, entities and attribute modifiers. As a result, its cast type is Java's <code>UUID</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="world-arguments"><a class="header" href="#world-arguments">World arguments</a></h1>
<p><img src="./images/arguments/worldargument.png" alt="A picture of world arguments in action" /></p>
<p>The <code>WorldArgument</code> class allows a command sender to refer to a loaded Bukkit <code>World</code>.</p>
<div class="example">
<h3 id="example---unloading-world"><a class="header" href="#example---unloading-world">Example - Unloading world</a></h3>
<p>Say we want to unload a world on our Minecraft server. We want to create a command with the following syntax:</p>
<pre><code class="language-mccmd">/unloadworld &lt;world&gt;
</code></pre>
<p>Using the world from the <code>WorldArgument</code>, we can then unload the world safely using <code>Bukkit.getServer().unloadWorld()</code> and passing <code>true</code> (to save chunks):</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;unloadworld&quot;)
    .withArguments(new WorldArgument(&quot;world&quot;))
    .executes((sender, args) -&gt; {
        World world = (World) args.get(&quot;world&quot;);

        // Unload the world (and save the world's chunks)
        Bukkit.getServer().unloadWorld(world, true);
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;unloadworld&quot;)
    .withArguments(WorldArgument(&quot;world&quot;))
    .executes(CommandExecutor { sender, args -&gt;
        val world = args[&quot;world&quot;] as World

        // Unload the world (and save the world's chunks)
        Bukkit.getServer().unloadWorld(world, true)
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;unloadworld&quot;) {
    worldArgument(&quot;world&quot;)
    anyExecutor { sender, args -&gt;
        val world = args[&quot;world&quot;] as World

        // Unload the world (and save the world's chunks)
        Bukkit.getServer().unloadWorld(world, true)
    }
}
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="predicate-arguments"><a class="header" href="#predicate-arguments">Predicate arguments</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="block-predicate-arguments"><a class="header" href="#block-predicate-arguments">Block predicate arguments</a></h1>
<p>The <code>BlockPredicateArgument</code> is used to represent a &quot;test&quot; for Minecraft blocks. This can consist of tags, such as the ones listed <a href="https://minecraft.wiki/w/Tag#Blocks">here on the MinecraftWiki</a>, or individual blocks. If a block matches the tag or block, then the predicate is satisfied.</p>
<p>For example, if we were to use the predicate <code>#leaves</code>, then the following blocks will be satisfied by that predicate: <code>jungle_leaves</code>, <code>oak_leaves</code>, <code>spruce_leaves</code>, <code>dark_oak_leaves</code>, <code>acacia_leaves</code>, <code>birch_leaves</code>.</p>
<p>When used, this argument must be casted to a <code>Predicate&lt;Block&gt;</code>. As with other similar arguments with parameterized types, you can ignore Java's unchecked cast type safety warning.</p>
<div class="example">
<h3 id="example---replacing-specific-blocks-in-a-radius"><a class="header" href="#example---replacing-specific-blocks-in-a-radius">Example - Replacing specific blocks in a radius</a></h3>
<p>Say you want to replace blocks in a given radius. To do this, we'll use the following command structure:</p>
<pre><code class="language-mccmd">/replace &lt;radius&gt; &lt;fromBlock&gt; &lt;toBlock&gt;
</code></pre>
<p>Of course, we could simply use a <code>BlockStateArgument</code> or even an <code>ItemStackArgument</code> as our <code>&lt;fromBlock&gt;</code> in order to get the material to replace, but the block predicate argument provides a test for a given block, which if satisfied, allows certain code to be executed.</p>
<p>First, we declare our arguments. We want to use the <code>BlockPredicateArgument</code> since it also allows us to use Minecraft tags to identify blocks, as well as individual blocks. We then use <code>BlockStateArgument</code> to set the block to a given type. The <code>BlockStateArgument</code> also allows the user to provide any block data (e.g. contents of a chest or a stair's orientation).</p>
<div class="multi-pre">
<pre><code class="language-java Java">Argument&lt;?&gt;[] arguments = new Argument&lt;?&gt;[] {
    new IntegerArgument(&quot;radius&quot;),
    new BlockPredicateArgument(&quot;fromBlock&quot;),
    new BlockStateArgument(&quot;toBlock&quot;),
};
</code></pre>
<pre><code class="language-kotlin Kotlin">val arguments = arrayOf&lt;Argument&lt;*&gt;&gt;(
    IntegerArgument(&quot;radius&quot;),
    BlockPredicateArgument(&quot;fromBlock&quot;),
    BlockStateArgument(&quot;toBlock&quot;),
)
</code></pre>
</div>
<p>We then register our <code>/replace</code> command. First, we parse the arguments making sure to cast to <code>Predicate&lt;Block&gt;</code> and <code>BlockData</code> (and not <code>BlockState</code>). After that, we use a few simple for loops to find the blocks within a radius sphere from the player.</p>
<p>In our most nested loop, we can then check if the block meets the requirements of our predicate. This is simply performed using <code>predicate.test(block)</code>, and if satisfied, we can set the block's type.</p>
<p>Lastly, we register our command as normal using the <code>register()</code> method.</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;replace&quot;)
    .withArguments(arguments)
    .executesPlayer((player, args) -&gt; {
        
        // Parse the arguments
        int radius = (int) args.get(&quot;radius&quot;);
        @SuppressWarnings(&quot;unchecked&quot;)
        Predicate&lt;Block&gt; predicate = (Predicate&lt;Block&gt;) args.get(&quot;fromBlock&quot;);
        BlockData blockData = (BlockData) args.get(&quot;toBlock&quot;);
        
        // Find a (solid) sphere of blocks around the player with a given radius
        Location center = player.getLocation();
        for (int x = -radius; x &lt;= radius; x++) {
            for (int y = -radius; y &lt;= radius; y++) {
                for (int z = -radius; z &lt;= radius; z++) {
                    if (Math.sqrt(((x * x) + (y * y) + (z * z))) &lt;= radius) {
                        Block block = center.getWorld().getBlockAt(x + center.getBlockX(), y + center.getBlockY(), z + center.getBlockZ());
                        
                        // If that block matches a block from the predicate, set it
                        if (predicate.test(block)) {
                            block.setType(blockData.getMaterial());
                            block.setBlockData(blockData);
                        }
                    }
                }
            }
        }
        return;
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;replace&quot;)
    .withArguments(*arguments)
    .executesPlayer(PlayerCommandExecutor { player, args -&gt;

        // Parse the arguments
        val radius = args[&quot;radius&quot;] as Int
        val predicate = args[&quot;fromBlock&quot;] as Predicate&lt;Block&gt;
        val blockData = args[&quot;toBlock&quot;] as BlockData

        // Find a (solid) sphere of blocks around the player with a given radius
        val center = player.location // for (i in 1 until 11) { }
        for (x in -radius until radius + 1) {
            for (y in -radius until radius + 1) {
                for (z in -radius until radius + 1) {
                    if (Math.sqrt((x * x + y * y + z * z).toDouble()) &lt;= radius) {
                        val block = center.world.getBlockAt(x + center.blockX, y + center.blockY, z + center.blockZ)

                        // If that block matches a block from the predicate, set it
                        if (predicate.test(block)) {
                            block.type = blockData.material
                            block.blockData = blockData
                        }
                    }
                }
            }
        }
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;replace&quot;) {
    arguments(*arguments)
    playerExecutor { player, args -&gt;
        // Parse the arguments
        val radius = args[&quot;radius&quot;] as Int
        val predicate = args[&quot;fromBlock&quot;] as Predicate&lt;Block&gt;
        val blockData = args[&quot;toBlock&quot;] as BlockData

        // Find a (solid) sphere of blocks around the player with a given radius
        val center = player.location // for (i in 1 until 11) { }
        for (x in -radius until radius + 1) {
            for (y in -radius until radius + 1) {
                for (z in -radius until radius + 1) {
                    if (Math.sqrt((x * x + y * y + z * z).toDouble()) &lt;= radius) {
                        val block = center.world.getBlockAt(x + center.blockX, y + center.blockY, z + center.blockZ)

                        // If that block matches a block from the predicate, set it
                        if (predicate.test(block)) {
                            block.type = blockData.material
                            block.blockData = blockData
                        }
                    }
                }
            }
        }
    }
}
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="itemstack-predicate-arguments"><a class="header" href="#itemstack-predicate-arguments">ItemStack predicate arguments</a></h1>
<p>Similar to the <code>BlockPredicateArgument</code>, the <code>ItemStackPredicateArgument</code> is a way of performing predicate checks on <code>ItemStack</code> objects. These can represent tags, such as the ones declared <a href="https://minecraft.wiki/w/Tag#Items">here on the MinecraftWiki</a>, or individual items. The cast type for this argument is <code>Predicate&lt;ItemStack&gt;</code>.</p>
<div class="example">
<h3 id="example---removing-items-in-inventories-based-on-predicates"><a class="header" href="#example---removing-items-in-inventories-based-on-predicates">Example - Removing items in inventories based on predicates</a></h3>
<p>Say we wanted to remove items in your inventory <em>(I know, the <code>/clear</code> command does this, but this is the only example I could come up with)</em>. To do this, we'll use the following command syntax:</p>
<pre><code class="language-mccmd">/rem &lt;item&gt;
</code></pre>
<p>We implement this with a simple for loop over the player's inventory and remove items that satisfy the predicate.</p>
<div class="multi-pre">
<pre><code class="language-java Java">// Register our command
new CommandAPICommand(&quot;rem&quot;)
    .withArguments(new ItemStackPredicateArgument(&quot;items&quot;))
    .executesPlayer((player, args) -&gt; {
        
        // Get our predicate
        @SuppressWarnings(&quot;unchecked&quot;)
        Predicate&lt;ItemStack&gt; predicate = (Predicate&lt;ItemStack&gt;) args.get(&quot;items&quot;);
        
        for (ItemStack item : player.getInventory()) {
            if (predicate.test(item)) {
                player.getInventory().remove(item);
            }
        }
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">// Register our command
CommandAPICommand(&quot;rem&quot;)
    .withArguments(ItemStackPredicateArgument(&quot;items&quot;))
    .executesPlayer(PlayerCommandExecutor { player, args -&gt;

        // Get our predicate
        val predicate = args[&quot;items&quot;] as Predicate&lt;ItemStack&gt;

        for (item in player.inventory) {
            if (predicate.test(item)) {
                player.inventory.remove(item)
            }
        }
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">// Register our command
commandAPICommand(&quot;rem&quot;) {
    itemStackPredicateArgument(&quot;items&quot;)
    playerExecutor { player, args -&gt;
        // Get our predicate
        val predicate = args[&quot;items&quot;] as Predicate&lt;ItemStack&gt;

        for (item in player.inventory) {
            if (predicate.test(item)) {
                player.inventory.remove(item)
            }
        }
    }
}
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nbt-arguments"><a class="header" href="#nbt-arguments">NBT arguments</a></h1>
<p>The CommandAPI includes support for NBT compound arguments using an NBT API. The usage for the <code>NBTCompoundArgument</code> depends on whether you are using the CommandAPI plugin (using a <code>CommandAPI.jar</code> file in your <code>plugins/</code> folder), or are shading the CommandAPI (including the compiled CommandAPI code in your own plugin).</p>
<hr />
<h2 id="plugin-usage-setup"><a class="header" href="#plugin-usage-setup">Plugin usage setup</a></h2>
<p>By default, the CommandAPI plugin includes a copy of the <a href="https://www.spigotmc.org/resources/nbt-api.7939/">NBT API by tr7zw</a> in <code>dev.jorel.commandapi.nbtapi</code>. No additional set up is required and it can be used directly out the box.</p>
<h2 id="shading-usage-setup"><a class="header" href="#shading-usage-setup">Shading usage setup</a></h2>
<p>In order to use the <code>NBTCompoundArgument</code>, you will have to use an NBT API that can create an NBT Compound object from an <code>Object</code> (ideally a <code>net.minecraft.nbt.NBTTagCompound</code> object). Examples of NBT APIs that can do this are <em>(these are not sponsored in any way)</em>:</p>
<ul>
<li><a href="https://www.spigotmc.org/resources/nbt-api.7939/">NBT API</a>, via the <a href="https://tr7zw.github.io/Item-NBT-API/v2-api/de/tr7zw/changeme/nbtapi/NBTContainer.html#NBTContainer-java.lang.Object-"><code>new NBTContainer(Object)</code></a> constructor</li>
</ul>
<h3 id="hooking-into-an-nbt-api"><a class="header" href="#hooking-into-an-nbt-api">Hooking into an NBT API</a></h3>
<p>Before the <code>NBTCompoundArgument</code> can be used, the CommandAPI needs to know what implementation of an NBT Compound object you're going to use. This is specified in the <code>onLoad()</code> sequence, where your CommandAPI's config is set up, by using the following method:</p>
<pre><code class="language-java">&lt;T&gt; CommandAPIConfig initializeNBTAPI(Class&lt;T&gt; nbtContainerClass, Function&lt;Object, T&gt; nbtContainerConstructor);
</code></pre>
<p>The <code>initializeNBTAPI(Class&lt;T&gt;, Function&lt;Object, T&gt;)</code> takes in two arguments:</p>
<ul>
<li>
<p><code>Class&lt;T&gt;</code> - The class that will be your NBT Compound implementation. This is also the type that the CommandAPI will return when the <code>NBTCompoundArgument</code> is used.</p>
</li>
<li>
<p><code>Function&lt;Object, T&gt;</code> - A function that takes in an object and returns the specified NBT Compound implementation. This could be a constructor or a static method, for example.</p>
</li>
</ul>
<div class="example">
<h3 id="example---hooking-into-the-nbt-api"><a class="header" href="#example---hooking-into-the-nbt-api">Example - Hooking into the NBT API</a></h3>
<p>Say we want to use the <a href="https://www.spigotmc.org/resources/nbt-api.7939/">NBT API</a> as our implementation of NBT compounds. First, we have to shade the NBT API into our project (view the official documentation for how to do this for <a href="https://github.com/tr7zw/Item-NBT-API/wiki/Using-Maven#option-2-shading-the-nbt-api-into-your-plugin">Maven</a> or <a href="https://github.com/tr7zw/Item-NBT-API/wiki/Using-Gradle#option-2-shading-the-nbt-api-into-your-plugin">Gradle</a>).</p>
<p>Now, we can configure the CommandAPI using the <code>CommandAPI.onLoad()</code> method to use the <code>NBTContainer</code> class, and the <a href="https://tr7zw.github.io/Item-NBT-API/v2-api/de/tr7zw/changeme/nbtapi/NBTContainer.html#NBTContainer-java.lang.Object-"><code>NBTContainer</code> constructor that takes in an <code>Object</code></a>:</p>
<div class="multi-pre">
<pre><code class="language-java Java">@Override
public void onLoad() {
    CommandAPI.onLoad(new CommandAPIBukkitConfig(this)
        .initializeNBTAPI(NBTContainer.class, NBTContainer::new)
    );
}
</code></pre>
<pre><code class="language-kotlin Kotlin">override fun onLoad() {
    CommandAPI.onLoad(CommandAPIBukkitConfig(this)
        .initializeNBTAPI(NBTContainer::class.java, ::NBTContainer)
    )
}
</code></pre>
</div>
<blockquote>
<p><em>Confused with the <code>::new</code> syntax? Read more about method references to a constructor <a href="https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html">here</a>.</em></p>
</blockquote>
<p>We're now able to use the <code>NBTContainer</code> as our implemented type for the <code>NBTCompoundArgument</code>!</p>
</div>
<hr />
<div class="example">
<h3 id="example---"><a class="header" href="#example---">Example - ???</a></h3>
<p>Since the underlying implementation of the <code>NBTCompoundArgument</code> can change (e.g. <code>NBTContainer</code> if you're using the NBT API), the type of your NBT compound implementation has to be declared in angle brackets.</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;award&quot;)
    .withArguments(new NBTCompoundArgument&lt;NBTContainer&gt;(&quot;nbt&quot;))
    .executes((sender, args) -&gt; {
        NBTContainer nbt = (NBTContainer) args.get(&quot;nbt&quot;);
        
        // Do something with &quot;nbt&quot; here...
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;award&quot;)
    .withArguments(NBTCompoundArgument&lt;NBTContainer&gt;(&quot;nbt&quot;))
    .executes(CommandExecutor { _, args -&gt;
        val nbt = args[&quot;nbt&quot;] as NBTContainer

        // Do something with &quot;nbt&quot; here...
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;award&quot;) {
    nbtCompoundArgument&lt;NBTContainer&gt;(&quot;nbt&quot;)
    anyExecutor { _, args -&gt;
        val nbt = args[&quot;nbt&quot;] as NBTContainer

        // Do something with &quot;nbt&quot; here...
    }
}
</code></pre>
</div>
</div>
<blockquote>
<p><strong>Developer's Note:</strong></p>
<p>If you believe you can supply a suitable example for this page, feel free to send an example <a href="https://github.com/JorelAli/CommandAPI/issues/new/choose">on the CommandAPI issues page!</a></p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="literal-arguments-1"><a class="header" href="#literal-arguments-1">Literal arguments</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="literal-arguments-2"><a class="header" href="#literal-arguments-2">Literal arguments</a></h1>
<p>Literal arguments are used to represent &quot;forced options&quot; for a command. For instance, take Minecraft's <code>/gamemode</code> command. The syntax consists of the following:</p>
<pre><code class="language-mccmd">/gamemode &lt;mode&gt;
/gamemode &lt;mode&gt; &lt;player&gt;
</code></pre>
<p>It consists of a gamemode, followed by an optional player argument. The list of gamemodes are as follows:</p>
<pre><code class="language-mccmd">/gamemode survival 
/gamemode creative
/gamemode adventure
/gamemode spectator
</code></pre>
<p>Unlike regular commands (as those implemented by Bukkit for example), these four options are &quot;hardcoded&quot; - they're not &quot;suggestions&quot;. The user can <em>only</em> enter one of these four examples, no other values are allowed.</p>
<div class="warning">
<p><strong>Developer's Note:</strong></p>
<p>There is a simpler alternative to the <code>LiteralArgument</code> class! Instead of having to deal with arguments not being present in the array of arguments, consider using the much more intuitive <code>MultiLiteralArgument</code>, which is described in more detail <a href="./argument_multiliteral.html">here</a>!</p>
</div>
<hr />
<h2 id="literal-arguments-vs-regular-arguments"><a class="header" href="#literal-arguments-vs-regular-arguments">Literal arguments vs regular arguments</a></h2>
<p>Unlike regular arguments that are shown in this chapter, the literal argument is <em>technically</em> not an argument. Due to this fact, literal arguments are <a href="./listed.html">unlisted</a> by default. In other words, <strong>the literal argument is not present in the <a href="./commandarguments.html"><code>CommandArguments args</code></a> for the command declaration.</strong></p>
<div class="example">
<h3 id="example---literal-arguments-and-regular-arguments"><a class="header" href="#example---literal-arguments-and-regular-arguments">Example - Literal arguments and regular arguments</a></h3>
<p>To illustrate the behavior of literal arguments, we create a command of the following form:</p>
<pre><code class="language-mccmd">/mycommand &lt;literal&gt; &lt;text&gt;
</code></pre>
<p>As an example, let's declare the literal &quot;hello&quot; as a valid literal for this command. When we retrieve the result from <code>args.get(0)</code>, it returns the value of the <code>TextArgument</code>, as opposed to the literal &quot;hello&quot;:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;mycommand&quot;)
    .withArguments(new LiteralArgument(&quot;hello&quot;))
    .withArguments(new TextArgument(&quot;text&quot;))
    .executes((sender, args) -&gt; {
        // This gives the variable &quot;text&quot; the contents of the TextArgument, and not the literal &quot;hello&quot;
        String text = (String) args.get(0);
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;mycommand&quot;)
    .withArguments(LiteralArgument(&quot;hello&quot;))
    .withArguments(TextArgument(&quot;text&quot;))
    .executes(CommandExecutor { _, args -&gt;
        // This gives the variable &quot;text&quot; the contents of the TextArgument, and not the literal &quot;hello&quot;
        val text = args[0] as String
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;mycommand&quot;) {
    literalArgument(&quot;hello&quot;)
    textArgument(&quot;text&quot;)
    anyExecutor { _, args -&gt;
        // This gives the variable &quot;text&quot; the contents of the TextArgument, and not the literal &quot;hello&quot;
        val text = args[0] as String
    }
}
</code></pre>
</div>
<p>The <code>LiteralArgument</code> class also provides the <code>LiteralArgument.of()</code> and <code>LiteralArgument.literal()</code> helper methods which can be used as an alternative way to declare literal arguments:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;mycommand&quot;)
    .withArguments(LiteralArgument.of(&quot;hello&quot;))
    .withArguments(new TextArgument(&quot;text&quot;))
    .executes((sender, args) -&gt; {
        // This gives the variable &quot;text&quot; the contents of the TextArgument, and not the literal &quot;hello&quot;
        String text = (String) args.get(0);
    })
    .register();

new CommandAPICommand(&quot;mycommand&quot;)
    .withArguments(LiteralArgument.literal(&quot;hello&quot;))
    .withArguments(new TextArgument(&quot;text&quot;))
    .executes((sender, args) -&gt; {
        // This gives the variable &quot;text&quot; the contents of the TextArgument, and not the literal &quot;hello&quot;
        String text = (String) args.get(0);
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;mycommand&quot;)
    .withArguments(LiteralArgument.of(&quot;hello&quot;))
    .withArguments(TextArgument(&quot;text&quot;))
    .executes(CommandExecutor { _, args -&gt;
        val text = args[0] as String
    })
    .register()

CommandAPICommand(&quot;mycommand&quot;)
    .withArguments(LiteralArgument.literal(&quot;hello&quot;))
    .withArguments(TextArgument(&quot;text&quot;))
    .executes(CommandExecutor { _, args -&gt;
        val text = args[0] as String
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;mycommand&quot;) {
    argument(LiteralArgument.of(&quot;hello&quot;))
    textArgument(&quot;text&quot;)
    anyExecutor { _, args -&gt;
        val text = args[0] as String
    }
}

commandAPICommand(&quot;mycommand&quot;) {
    argument(LiteralArgument.literal(&quot;hello&quot;))
    textArgument(&quot;text&quot;)
    anyExecutor { _, args -&gt;
        val text = args[0] as String
    }
}
</code></pre>
</div>
<p>If I were to run the following command:</p>
<pre><code class="language-mccmd">/mycommand hello goodbye
</code></pre>
<p>The value of <code>text</code> in the code above would be &quot;goodbye&quot;.</p>
</div>
<div class="example">
<h3 id="example---gamemode-command-using-literal-arguments"><a class="header" href="#example---gamemode-command-using-literal-arguments">Example - Gamemode command using literal arguments</a></h3>
<p>This is a demonstration of how you could create a command similar to Minecraft's <code>/gamemode</code> command by using literal arguments. To do this, we are effectively registering 4 separate commands, each called <code>/gamemode</code>, but with different literal arguments.</p>
<div class="multi-pre">
<pre><code class="language-java Java">// Create a map of gamemode names to their respective objects
HashMap&lt;String, GameMode&gt; gamemodes = new HashMap&lt;&gt;();
gamemodes.put(&quot;adventure&quot;, GameMode.ADVENTURE);
gamemodes.put(&quot;creative&quot;, GameMode.CREATIVE);
gamemodes.put(&quot;spectator&quot;, GameMode.SPECTATOR);
gamemodes.put(&quot;survival&quot;, GameMode.SURVIVAL);

// Iterate over the map
for(Entry&lt;String, GameMode&gt; entry : gamemodes.entrySet()) {

    // Register the command as usual
    new CommandAPICommand(&quot;changegamemode&quot;)
        .withArguments(new LiteralArgument(entry.getKey()))
        .executesPlayer((player, args) -&gt; {
            // Retrieve the object from the map via the key and NOT the args[]
            player.setGameMode(entry.getValue());
        })
        .register();
}
</code></pre>
<pre><code class="language-kotlin Kotlin">// Create a map of gamemode names to their respective objects
val gamemodes = mapOf(
    &quot;adventure&quot; to GameMode.ADVENTURE,
    &quot;creative&quot; to GameMode.CREATIVE,
    &quot;spectator&quot; to GameMode.SPECTATOR,
    &quot;survival&quot; to GameMode.SURVIVAL
)

// Iterate over the map
for ((key, _) in gamemodes) {

    // Register the command as usual
    CommandAPICommand(&quot;changegamemode&quot;)
        .withArguments(LiteralArgument(key))
        .executesPlayer(PlayerCommandExecutor { player, _ -&gt;
            // Retrieve the object from the map via the key and NOT the args[]
            player.gameMode = gamemodes[key]!!
        })
        .register()
}
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">// Create a map of gamemode names to their respective objects
val gamemodes = mapOf(
    &quot;adventure&quot; to GameMode.ADVENTURE,
    &quot;creative&quot; to GameMode.CREATIVE,
    &quot;spectator&quot; to GameMode.SPECTATOR,
    &quot;survival&quot; to GameMode.SURVIVAL
)

// Iterate over the map
for ((key, _) in gamemodes) {

    // Register the command as usual
    commandAPICommand(&quot;changegamemode&quot;) {
        literalArgument(key)
        playerExecutor { player, args -&gt;
            // Retrieve the object from the map via the key and NOT the args[]
            player.gameMode = gamemodes[key]!!
        }
    }

}
</code></pre>
</div>
<p>Note how, since we don't have access to the literal from <code>args</code>, we must access the provided gamemode from elsewhere.</p>
</div>
<hr />
<h2 id="literal-argument-warnings"><a class="header" href="#literal-argument-warnings">Literal argument warnings</a></h2>
<p>Literal arguments require a string in the constructor. If the literal is an empty String or is null, the CommandAPI will throw a <code>BadLiteralException</code>.</p>
<p>Because literal arguments are <em>&quot;hardcoded&quot;</em>, each literal is effectively mapped to a single command. This is shown when using the configuration option <code>create-dispatcher-json: true</code> which shows the JSON result of registered commands. For instance, take the <code>/defaultgamemode</code> command:</p>
<pre><code class="language-json">&quot;defaultgamemode&quot;: {
    &quot;type&quot;: &quot;literal&quot;,
    &quot;children&quot;: {
        &quot;adventure&quot;: {
            &quot;type&quot;: &quot;literal&quot;,
            &quot;executable&quot;: true
        },
        &quot;creative&quot;: {
            &quot;type&quot;: &quot;literal&quot;,
            &quot;executable&quot;: true
        },
        &quot;spectator&quot;: {
            &quot;type&quot;: &quot;literal&quot;,
            &quot;executable&quot;: true
        },
        &quot;survival&quot;: {
            &quot;type&quot;: &quot;literal&quot;,
            &quot;executable&quot;: true
        }
    }
},
</code></pre>
<p>Each option produces a new &quot;command&quot; in the tree of commands. This means that having exceptionally large lists of literals, or nested literals (e.g. <code>/command &lt;literal1&gt; &lt;literal2&gt;</code>) can cause very large trees which cannot be sent to the clients <em>(it can cause clients to crash)</em>.</p>
<blockquote>
<p><strong>Developer's Note:</strong></p>
<p>Take care when using literal arguments. If your list of arguments is exceptionally large, or contains many nested arguments, the server may be unable to send the command information to the client. If many command argument choices are required, consider using a <code>StringArgument</code> and using <code>.replaceSuggestions()</code> to create your own list of required arguments.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multi-literal-arguments"><a class="header" href="#multi-literal-arguments">Multi literal arguments</a></h1>
<p>So far, we've described normal arguments and literal arguments. We've described the nuances with literal arguments and how they're not really &quot;arguments&quot;, so they don't appear in the <a href="./commandarguments.html"><code>CommandArguments args</code></a> for commands.</p>
<p>Now forget all of that. Multi literal arguments are the same as literal arguments but they <em>do</em> appear in the <a href="./commandarguments.html"><code>CommandArguments args</code></a> for commands (i.e. they are <a href="./listed.html">listed</a>). Multi literal arguments are just a way better alternative to literal arguments. The multi literal argument constructor allows you to provide a <code>String nodeName</code> and a <code>String... literals</code> of possible values which you can use for your command declaration.</p>
<p>The multi literal argument has all of the same benefits of a regular literal argument - they are hardcoded options that the user must enter - they don't allow other values.</p>
<div class="warning">
<p><strong>Developer's Note:</strong></p>
<p>For 9.1.0, all previously existing <code>MultiLiteralArgument</code> constructors have been deprecated! They will be removed in a future version.</p>
<p>The new constructor looks like this:</p>
<pre><code class="language-java">public MultiLiteralArgument(String nodeName, String... literals)
</code></pre>
</div>
<div class="example">
<h3 id="example---using-multi-literals-to-make-the-gamemode-command"><a class="header" href="#example---using-multi-literals-to-make-the-gamemode-command">Example - Using multi literals to make the gamemode command</a></h3>
<p>In this example, we'll show how to use multi literals to declare Minecraft's <code>/gamemode</code> command. As you can see from the example code below, the argument declaration and command declaration is the same as if you were declaring any normal argument or command.</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;gamemode&quot;)
    .withArguments(new MultiLiteralArgument(&quot;gamemodes&quot;, &quot;adventure&quot;, &quot;creative&quot;, &quot;spectator&quot;, &quot;survival&quot;))
    .executesPlayer((player, args) -&gt; {
        // The literal string that the player enters IS available in the args[]
        switch ((String) args.get(&quot;gamemodes&quot;)) {
            case &quot;adventure&quot;:
                player.setGameMode(GameMode.ADVENTURE);
                break;
            case &quot;creative&quot;:
                player.setGameMode(GameMode.CREATIVE);
                break;
            case &quot;spectator&quot;:
                player.setGameMode(GameMode.SPECTATOR);
                break;
            case &quot;survival&quot;:
                player.setGameMode(GameMode.SURVIVAL);
                break;
            default:
                player.sendMessage(&quot;Invalid gamemode: &quot; + args.get(&quot;gamemodes&quot;));
                break;
        }
    }) 
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;gamemode&quot;)
    .withArguments(MultiLiteralArgument(&quot;gamemodes&quot;, &quot;adventure&quot;, &quot;creative&quot;, &quot;spectator&quot;, &quot;survival&quot;))
    .executesPlayer(PlayerCommandExecutor { player, args -&gt;
        // The literal string that the player enters IS available in the args[]
        when (args[&quot;gamemodes&quot;] as String) {
            &quot;adventure&quot; -&gt; player.gameMode = GameMode.ADVENTURE
            &quot;creative&quot; -&gt; player.gameMode = GameMode.CREATIVE
            &quot;spectator&quot; -&gt; player.gameMode = GameMode.SPECTATOR
            &quot;survival&quot; -&gt; player.gameMode = GameMode.SURVIVAL
        }
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;gamemode&quot;) {
    multiLiteralArgument(nodeName = &quot;gamemodes&quot;, &quot;adventure&quot;, &quot;creative&quot;, &quot;spectator&quot;, &quot;survival&quot;) // Adding this for now, needed because ambiguous methods exist
    playerExecutor { player, args -&gt;
        // The literal string that the player enters IS available in the args[]
        when (args[&quot;gamemodes&quot;] as String) {
            &quot;adventure&quot; -&gt; player.gameMode = GameMode.ADVENTURE
            &quot;creative&quot; -&gt; player.gameMode = GameMode.CREATIVE
            &quot;spectator&quot; -&gt; player.gameMode = GameMode.SPECTATOR
            &quot;survival&quot; -&gt; player.gameMode = GameMode.SURVIVAL
        }
    }
}
</code></pre>
</div>
<p>An important thing to note is that we don't have to implement a <code>default</code> case for the above <code>switch</code> statements, because the CommandAPI will only permit valid options of a <code>MultiLiteralArgument</code> to reach the executor. If the user enters an invalid option, the command doesn't run.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="list-arguments"><a class="header" href="#list-arguments">List arguments</a></h1>
<p><img src="./images/arguments/listargument.png" alt="A list argument with the command &quot;/multigive @p stone grass_block dirt&quot; and Minecraft suggestions with a list of Minecraft items" /></p>
<p>List arguments allows users to provide a list of values. This argument can take on two forms:</p>
<ul>
<li>Using an underlying <code>GreedyStringArgument</code>, so the greedy string argument rule applies - <strong>this argument can only be used at the end of an argument list</strong>.</li>
<li>Using an underlying <code>TextArgument</code>, so this argument can be used anywhere in an argument list, but its contents must be surrounded with quotes (<code>&quot;</code>).</li>
</ul>
<hr />
<h2 id="the-listargumentbuilder"><a class="header" href="#the-listargumentbuilder">The <code>ListArgumentBuilder</code></a></h2>
<p>Unlike other arguments, because this argument can be interpreted in various different ways, this argument can only be created using a <code>ListArgumentBuilder</code>, instead of directly accessing the <code>ListArgument</code> constructor. The <code>ListArgumentBuilder</code> loosely follows the following format:</p>
<p>\begin{align}
&amp;\quad\texttt{Create a ListArgumentBuilder} \\
\rightarrow&amp;\quad\texttt{(Provide the list delimiter)} \\
\rightarrow&amp;\quad\texttt{Provide the list to pull suggestions from} \\
\rightarrow&amp;\quad\texttt{Provide the mapper of the list items to a string} \\
\rightarrow&amp;\quad\texttt{Build the ListArgument}
\end{align}</p>
<h3 id="construction"><a class="header" href="#construction">Construction</a></h3>
<p>First, you have to create a <code>ListArgumentBuilder</code> parameterized over the type that the list will generate. For example, if you want to create a list of Strings, you would use <code>new ListArgumentBuilder&lt;String&gt;</code>.</p>
<ul>
<li>The <code>nodeName</code> parameter represents the name of the node to use for the argument.</li>
<li>The optional <code>delimiter</code> argument specifies the delimiter (separator) to use between entries. If a delimiter is not provided, a space <code>&quot; &quot;</code> will be used as the delimiter.</li>
</ul>
<pre><code class="language-java">public ListArgumentBuilder&lt;T&gt;(String nodeName);
public ListArgumentBuilder&lt;T&gt;(String nodeName, String delimiter);
</code></pre>
<p>$$\downarrow$$</p>
<blockquote>
<h3 id="allowing-duplicates-optional"><a class="header" href="#allowing-duplicates-optional">Allowing duplicates (Optional)</a></h3>
<p>If you want your users to enter duplicate entries in your list, you can use the <code>allowDuplicates</code> method to set whether duplicates are allowed. By default, duplicates are disabled.</p>
<p>When duplicates are enabled, items that have been entered before can be displayed again in the list of suggestions:</p>
<pre><code class="language-java">ListArgumentBuilder.allowDuplicates(true);
</code></pre>
<p><img src="./images/arguments/listargument_with_duplicates.gif" alt="List arguments with duplicates enabled" /></p>
<p>When duplicates are disabled, items that have already been entered will not appear in the list of suggestions:</p>
<pre><code class="language-java">ListArgumentBuilder.allowDuplicates(false);
</code></pre>
<p><img src="./images/arguments/listargument_without_duplicates.gif" alt="List arguments with duplicates disabled" /></p>
</blockquote>
<p>$$\downarrow$$</p>
<h3 id="providing-the-list"><a class="header" href="#providing-the-list">Providing the list</a></h3>
<p>The <code>ListArgument</code> requires a list that the list argument can pull suggestions and validation from. The <code>ListArgument</code> does not support values which are not present in the provided list. There are three methods that can be used to provide a list for the <code>ListArgument</code>:</p>
<ul>
<li>
<p>Providing an immutable list (a list that doesn't change) using the <code>Collection&lt;T&gt;</code> parameter:</p>
<pre><code class="language-java">public ListArgumentBuilder withList(Collection&lt;T&gt; list);
</code></pre>
</li>
<li>
<p>Providing a list that is determined when suggestions are being displayed to the user and before the command has been executed using the <code>Supplier&lt;Collection&lt;T&gt;&gt;</code> parameter:</p>
<pre><code class="language-java">public ListArgumentBuilder withList(Supplier&lt;Collection&lt;T&gt;&gt; list);
</code></pre>
</li>
<li>
<p>Providing a list that is determined when suggestions are being displayed to the user and before the command has been executed, that also depends on the <code>SuggestionInfo</code> present when running the command, using the <code>Function&lt;SuggestionInfo&lt;CommandSender&gt;, Collection&lt;T&gt;&gt;</code> parameter:</p>
<pre><code class="language-java">public ListArgumentBuilder withList(Function&lt;SuggestionInfo&lt;CommandSender&gt;, Collection&lt;T&gt;&gt; list);
</code></pre>
</li>
</ul>
<p>$$\downarrow$$</p>
<h3 id="providing-a-list-mapping-function"><a class="header" href="#providing-a-list-mapping-function">Providing a list mapping function</a></h3>
<p>In order to display suggestions, the <code>ListArgument</code> needs to know how to convert a list entry to a string. For example, a <code>Location</code> may be converted into <code>&quot;x,y,z&quot;</code>. The <code>ListArgumentBuilder</code> provides three methods for providing a mapping function:</p>
<ul>
<li>
<p>The <code>withStringMapper()</code> method converts the object to a string using the object's <code>.toString()</code> method. If the object is null, this method will populate it with the string <code>&quot;null&quot;</code>:</p>
<pre><code class="language-java">public ListArgumentBuilder withStringMapper();
</code></pre>
</li>
<li>
<p>The <code>withMapper()</code> method requires a function that maps the object to a string:</p>
<pre><code class="language-java">public ListArgumentBuilder withMapper(Function&lt;T, String&gt; mapper);
</code></pre>
</li>
<li>
<p>The <code>withStringTooltipMapper()</code> method requires a function that maps the object to an <code>IStringTooltip</code>. This allows you to also provide hover tooltips for the current item:</p>
<pre><code class="language-java">public ListArgumentBuilder withStringTooltipMapper(Function&lt;T, IStringTooltip&gt; mapper);
</code></pre>
</li>
</ul>
<p>$$\downarrow$$</p>
<h3 id="building-the-listargumentbuilder"><a class="header" href="#building-the-listargumentbuilder">Building the <code>ListArgumentBuilder</code></a></h3>
<p>To finish building the <code>ListArgument</code>, call the <code>buildGreedy()</code> or <code>buildText()</code> method. The <code>buildGreedy()</code> method will treat the list argument as a greedy string, which means you can only use this list argument at the end of the list of arguments you are declaring for the command. If you use the <code>buildText()</code> instead, you can use the list argument anywhere (and multiple times), but the list must be surrounded with quotation characters (<code>&quot;</code>).</p>
<pre><code class="language-java">public ListArgument&lt;T&gt; buildGreedy();
public ListArgument&lt;T&gt; buildText();
</code></pre>
<hr />
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<div class="example">
<h3 id="example---multi-give-command"><a class="header" href="#example---multi-give-command">Example - Multi-give command</a></h3>
<p>Say you wanted to give yourself multiple items in a single command. For this command, we'll use the following syntax, which lets you provide the number of items to give, and a list of materials:</p>
<pre><code class="language-mccmd">/multigive &lt;amount&gt; &lt;materials&gt;
</code></pre>
<p>To do this, we create a command with an <code>IntegerArgument</code> to specify the amount (between 1 and 64), and a <code>ListArgument</code> that accepts a list of <code>Material</code> objects. We use the <code>ListArgumentBuilder</code> to provide a list of materials as well as a mapping function that converts the material's name to a lowercase string. By default, we use a space delimiter (separator) for arguments in the list.</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;multigive&quot;)
    .withArguments(new IntegerArgument(&quot;amount&quot;, 1, 64))
    .withArguments(new ListArgumentBuilder&lt;Material&gt;(&quot;materials&quot;)
        .withList(List.of(Material.values()))
        .withMapper(material -&gt; material.name().toLowerCase())
        .buildGreedy()
    )
    .executesPlayer((player, args) -&gt; {
        int amount = (int) args.get(&quot;amount&quot;);
        List&lt;Material&gt; theList = (List&lt;Material&gt;) args.get(&quot;materials&quot;);
        
        for (Material item : theList) {
            player.getInventory().addItem(new ItemStack(item, amount));
        }
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;multigive&quot;)
    .withArguments(IntegerArgument(&quot;amount&quot;, 1, 64))
    .withArguments(ListArgumentBuilder&lt;Material&gt;(&quot;materials&quot;)
        .withList(Material.values().toList())
        .withMapper { material -&gt; material.name.lowercase() }
        .buildGreedy()
    )
    .executesPlayer(PlayerCommandExecutor { player, args -&gt;
        val amount = args[&quot;amount&quot;] as Int
        val theList = args[&quot;materials&quot;] as List&lt;Material&gt;

        for (item in theList) {
            player.inventory.addItem(ItemStack(item, amount))
        }
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;multigive&quot;) {
    integerArgument(&quot;amount&quot;, 1, 64)
    argument(ListArgumentBuilder&lt;Material&gt;(&quot;materials&quot;)
        .withList(Material.values().toList())
        .withMapper { material -&gt; material.name.lowercase() }
        .buildGreedy()
    )
    playerExecutor { player, args -&gt;
        val amount = args[&quot;amount&quot;] as Int
        val theList = args[&quot;materials&quot;] as List&lt;Material&gt;

        for (item in theList) {
            player.inventory.addItem(ItemStack(item, amount))
        }
    }
}
</code></pre>
</div>
<p><img src="./images/arguments/listargument_multigive.gif" alt="A /multigive argument gif where a user types &quot;/multigive 64 stone dirt cobblestone grass_block&quot; and suggestions appear automatically. Running the command gives the player 64 stone, dirt, cobblestone and grass_block items in their hotbar" /></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="map-arguments"><a class="header" href="#map-arguments">Map arguments</a></h1>
<p>A <code>MapArgument</code> can be used to provide a map of values. This argument uses an underlying <code>GreedyStringArgument</code> which means that this argument can only be used at the end of the argument list.
It returns a <code>LinkedHashMap</code> object.</p>
<hr />
<h2 id="the-mapargumentbuilder"><a class="header" href="#the-mapargumentbuilder">The <code>MapArgumentBuilder</code></a></h2>
<p>Similar to the <code>ListArgument</code>, this argument also uses a builder class to construct it.</p>
<p>\begin{align}
&amp;\quad\texttt{Create a MapArgumentBuilder and possibly provide the delimiter or separator} \\
\rightarrow&amp;\quad\texttt{Provide the mapper from a string to an object of the provided key type} \\
\rightarrow&amp;\quad\texttt{Provide the mapper from a string to an object of the provided value type} \\
\rightarrow&amp;\quad\texttt{Provide the list with keys to pull suggestions from} \\
\rightarrow&amp;\quad\texttt{Provide the list with values to pull suggestions from} \\
\rightarrow&amp;\quad\texttt{Build the MapArgument}
\end{align}</p>
<h3 id="building-a-mapargument"><a class="header" href="#building-a-mapargument">Building a <code>MapArgument</code></a></h3>
<p>To start building the argument, you first have to construct a <code>MapArgumentBuilder</code> parameterized over the types the key and the value are supposed to have.
If you wanted to construct a <code>MapArgument</code> that returns a <code>LinkedHashMap&lt;String, Integer&gt;</code> you would construct the <code>MapArgumentBuilder</code> like this:</p>
<pre><code class="language-java">new MapArgumentBuilder&lt;String, Integer&gt;
</code></pre>
<p>The <code>MapArgumentBuilder</code> has three possible constructors:</p>
<pre><code class="language-java">public MapArgumentBuilder&lt;K, V&gt;(String nodeName);
public MapArgumentBuilder&lt;K, V&gt;(String nodeName, char delimiter);
public MapArgumentBuilder&lt;K, V&gt;(String nodeName, char delimiter, String separator)
</code></pre>
<ul>
<li><code>nodeName</code>: This parameter determines the node name of the <code>MapArgument</code></li>
<li><code>delimiter</code>: This parameter determines the delimiter. This separates a key from a value (<code>key:value</code>). When not provided, it defaults to a colon (<code>:</code>)</li>
<li><code>separator</code>: This parameter determines the separator. This separates one key-value pair from another (<code>key:value key:value</code>). When not provided, it defaults to a space <!-- markdownlint-disable-line MD038 -->(<code> </code>)</li>
</ul>
<p>$$\downarrow$$</p>
<h3 id="providing-mapper-functions"><a class="header" href="#providing-mapper-functions">Providing mapper functions</a></h3>
<p>The mapper functions are used to parse the argument when entered. Because a <code>GreedyStringArgument</code>
returns a <code>String</code>, we need a way to convert a <code>String</code> into an object specified by the type parameters.</p>
<p>When providing mappers, you first need to provide the key mapper:</p>
<pre><code class="language-java">public MapArgumentBuilder withKeyMapper(StringParser&lt;K&gt;);
</code></pre>
<p>You then have to provide the value mapper:</p>
<pre><code class="language-java">public MapArgumentBuilder withValueMapper(StringParser&lt;V&gt;);
</code></pre>
<p><code>StringParser</code> is a functional interface with the following definition:</p>
<pre><code class="language-java">@FunctionalInterface
public interface StringParser&lt;T&gt; {
    /**
     * A method that turns a String into an object of type T.
     *
     * @param s The String to parse
     * @return The resulting parsed object
     * @throws WrapperCommandSyntaxException If there is a problem with the syntax of the String that prevents it from being turned into an object of type T.
     */
    T parse(String s) throws WrapperCommandSyntaxException;
}
</code></pre>
<p>This signature allows you to throw exceptions using the <code>CommandAPI.fail...</code> methods if the given String cannot be parsed (see <a href="./commandfailures.html">Handling command failures</a>).</p>
<p>$$\downarrow$$</p>
<h3 id="providing-suggestions"><a class="header" href="#providing-suggestions">Providing suggestions</a></h3>
<p>When providing suggestions you have the choice whether players are allowed to enter any key/value pair or only key/value pairs specified by the <code>MapArgument</code>.
To accomplish this the <code>MapArgumentBuilder</code> provides different methods.</p>
<p>Similar to the mappers, you first have to provide the key suggestions:</p>
<div class="multi-pre">
<pre><code class="language-java Only_certain_keys_(recommended)">public MapArgumentBuilder withKeyList(List&lt;String&gt; keyList);
</code></pre>
<pre><code class="language-java Any_key">public MapArgumentBuilder withoutKeyList();
</code></pre>
</div>
<p>Next, you have to provide the value suggestions. In addition to the two possibilities presented for the key suggestions, here you also have the possibility to define
whether a value can be written multiple times.</p>
<div class="multi-pre">
<pre><code class="language-java Only_certain_values_(recommended)">public MapArgumentBuilder withValueList(List&lt;String&gt; valueList);

public MapArgumentBuilder withValueList(List&lt;String&gt; valueList, boolean allowValueDuplicates);
</code></pre>
<pre><code class="language-java Any_value">public MapArgumentBuilder withoutValueList();

public MapArgumentBuilder withoutValueList(boolean allowDuplicates)
</code></pre>
</div>
<p>If you choose to allow a value to be written multiple times you have to set <code>allowValueDuplicates</code> to <code>true</code>. By default, it is set to <code>false</code> and
does not allow values to be written multiple times.</p>
<p>$$\downarrow$$</p>
<h3 id="building-the-mapargument"><a class="header" href="#building-the-mapargument">Building the <code>MapArgument</code></a></h3>
<p>To finish building the <code>MapArgument</code>, you have to call the <code>build()</code> method. This will return a new <code>MapArgument</code> object.</p>
<pre><code class="language-java">public MapArgument&lt;K, V&gt; build();
</code></pre>
<hr />
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<div class="example">
<h3 id="example---sendmessage-command"><a class="header" href="#example---sendmessage-command">Example - /sendmessage command</a></h3>
<p>Let's say we want to create a command that we can execute to send multiple players messages without typing the command more than once. For that, we create a command with the following syntax:</p>
<pre><code class="language-mccmd">/sendmessage &lt;message&gt;
</code></pre>
<p>To implement that, we create a command that uses a <code>MapArgument</code> and use <code>Player</code> objects as keys and <code>String</code> objects as values:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;sendmessage&quot;)
    // Parameter 'delimiter' is missing, delimiter will be a colon
    // Parameter 'separator' is missing, separator will be a space
    .withArguments(new MapArgumentBuilder&lt;Player, String&gt;(&quot;message&quot;)

        // Providing a key mapper to convert a String into a Player
        .withKeyMapper(Bukkit::getPlayer)

        // Providing a value mapper to leave the message how it was sent
        .withValueMapper(s -&gt; s)

        // Providing a list of player names to be used as keys
        .withKeyList(Bukkit.getOnlinePlayers().stream().map(Player::getName).toList())

        // Don't provide a list of values so messages can be chosen without restrictions
        // Allow duplicates in case the same message should be sent to different players
        .withoutValueList(true)

        // Build the MapArgument
        .build()
    )
    .executesPlayer((player, args) -&gt; {
        // The MapArgument returns a LinkedHashMap
        LinkedHashMap&lt;Player, String&gt; map = (LinkedHashMap&lt;Player, String&gt;) args.get(&quot;message&quot;);

        // Sending the messages to the players
        for (Entry&lt;Player, String&gt; messageRecipients : map.entrySet()) {
            messageRecipients.getKey().sendMessage(messageRecipients.getValue());
        }
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;sendmessage&quot;)
    // Parameter 'delimiter' is missing, delimiter will be a colon
    // Parameter 'separator' is missing, separator will be a space
    .withArguments(MapArgumentBuilder&lt;Player, String&gt;(&quot;message&quot;)

        // Providing a key mapper to convert a String into a Player
        .withKeyMapper { s: String -&gt; Bukkit.getPlayer(s) }

        // Providing a value mapper to leave the message how it was sent
        .withValueMapper { s: String -&gt; s }

        // Providing a list of player names to be used as keys
        .withKeyList(Bukkit.getOnlinePlayers().map { player: Player -&gt; player.name }.toList())

        // Don't provide a list of values so messages can be chosen without restrictions
        // Allow duplicates in case the same message should be sent to different players
        .withoutValueList(true)

        // Build the MapArgument
        .build()
    )
    .executesPlayer(PlayerCommandExecutor { _, args -&gt;
        // The MapArgument returns a LinkedHashMap
        val map: LinkedHashMap&lt;Player, String&gt; = args[&quot;message&quot;] as LinkedHashMap&lt;Player, String&gt;

        // Sending the messages to the players
        for (messageRecipient in map.keys) {
            messageRecipient.sendMessage(map[messageRecipient]!!)
        }
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;sendmessage&quot;) {
    // Parameter 'delimiter' is missing, delimiter will be a colon
    // Parameter 'separator' is missing, separator will be a space
    argument(MapArgumentBuilder&lt;Player, String&gt;(&quot;message&quot;)

        // Providing a key mapper to convert a String into a Player
        .withKeyMapper { s: String -&gt; Bukkit.getPlayer(s) }

        // Providing a value mapper to leave the message how it was sent
        .withValueMapper { s: String -&gt; s }

        // Providing a list of player names to be used as keys
        .withKeyList(Bukkit.getOnlinePlayers().map { player: Player -&gt; player.name }.toList())

        // Don't provide a list of values so messages can be chosen without restrictions
        // Allow duplicates in case the same message should be sent to different players
        .withoutValueList(true)

        // Build the MapArgument
        .build()
    )
    playerExecutor { _, args -&gt;
        // The MapArgument returns a LinkedHashMap
        val map: LinkedHashMap&lt;Player, String&gt; = args[&quot;message&quot;] as LinkedHashMap&lt;Player, String&gt;

        // Sending the messages to the players
        for (messageRecipient in map.keys) {
            messageRecipient.sendMessage(map[messageRecipient]!!)
        }
    }
}
</code></pre>
</div>
<div class="warning">
<p><strong>Developer's Note:</strong></p>
<p>The <code>MapArgument</code> is very strict and doesn't have room for any errors. A key must always be followed by the delimiter, then a value. One value and the next key must always be separated by the separator. Both keys and values also have the option to be surrounded by quotes.</p>
<p>For example, let's say you are on a server with two players, <code>Player1</code> and <code>Player2</code>. We want to send both of them the message <code>Hello, &lt;playerName&gt;!</code>
To do that, we use the previously declared <code>sendmessage</code> command like this:</p>
<pre><code class="language-mccmd">/sendmessage Player1:&quot;Hello, Player1!&quot; Player2:&quot;Hello, Player2!&quot;
</code></pre>
<p>A colon is used as the delimiter and a space as the separator because those are the defaults, and neither was specified in the <code>MapArgumentBuilder</code> constructor. Since the separator was a space, the messages were surrounded by quotes to avoid the spaces inside them from being misinterpreted as the start of the next key-value pair.</p>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-arguments"><a class="header" href="#command-arguments">Command arguments</a></h1>
<p><img src="./images/commandargument.gif" alt="Command arguments" /></p>
<p>Command arguments allows users to provide an executable server command. The <code>CommandArgument</code> class lets you specify:</p>
<ul>
<li>Arbitrary commands - any command that the user has permissions to run can be provided.</li>
<li>Restricted commands - only specific commands can be provided.</li>
</ul>
<p>Using the <code>CommandArgument</code> will return a <code>CommandResult</code>, which contains a Bukkit <code>Command</code> instance representing the command to be executed, and a <code>String[]</code> of command arguments.</p>
<hr />
<h2 id="command-results"><a class="header" href="#command-results">Command results</a></h2>
<p>The <code>CommandResult</code> record contains the following methods:</p>
<pre><code class="language-java">public record CommandResult {
    Command command();
    String[] args();

    boolean execute(CommandSender target);
}
</code></pre>
<p>These methods can be used to retrieve information about the command that was provided by the user:</p>
<pre><code class="language-java">Command command();
</code></pre>
<p><code>command()</code> returns the Bukkit <code>Command</code> instance that the user provided. For example, if a player provided <code>/mycommand hello world</code>, then <code>command()</code> will represent the <code>/mycommand</code> command.</p>
<hr />
<pre><code class="language-java">String[] args();
</code></pre>
<p><code>args()</code> returns an array of string argument inputs that were provided to the command. For example, if a player provided <code>/mycommand hello world</code>, then <code>args()</code> will be the following:</p>
<pre><code class="language-java">[ &quot;hello&quot;, &quot;world&quot; ]
</code></pre>
<hr />
<pre><code class="language-java">boolean execute(CommandSender target);
</code></pre>
<p><code>execute(CommandSender)</code> runs the Bukkit <code>Command</code> using the arguments contained in the <code>CommandResult</code> as the given <code>CommandSender</code>. It returns true if the command dispatch succeeded, and false if it failed. Using this method is equivalent to running the following:</p>
<pre><code class="language-java">result.command().execute(target, result.command().getLabel(), result.args());
</code></pre>
<hr />
<h2 id="arbitrary-commands"><a class="header" href="#arbitrary-commands">Arbitrary commands</a></h2>
<p>Arbitrary commands let the user enter any command that they have permission to execute. To use arbitrary commands, you just need to use the <code>CommandArgument</code> normally.</p>
<div class="example">
<h3 id="example---a-sudo-command"><a class="header" href="#example---a-sudo-command">Example - A /sudo command</a></h3>
<p>We want to create a <code>/sudo</code> command which lets you execute a command as another online player.</p>
<p><img src="./images/sudocommand.gif" alt="Sudo command example" /></p>
<p>To do this, we want to use the following command syntax:</p>
<pre><code class="language-mccmd">/sudo &lt;target&gt; &lt;command&gt;
</code></pre>
<p>In this example, we want to be able to run any arbitrary command, so we will simply use the <code>CommandArgument</code> on its own (without using suggestions). Using the <code>CommandArgument</code> generates a <code>CommandResult</code> and we can use the <code>.command()</code> and <code>.args()</code> methods above to access the command and arguments. We can make use of the <code>Command.execute()</code> method to execute our command and use the target player as the command sender.</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;sudo&quot;)
    .withArguments(new PlayerArgument(&quot;target&quot;))
    .withArguments(new CommandArgument(&quot;command&quot;))
    .executes((sender, args) -&gt; {
        Player target = (Player) args.get(&quot;target&quot;);
        CommandResult command = (CommandResult) args.get(&quot;command&quot;);

        command.execute(target);
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;sudo&quot;)
    .withArguments(PlayerArgument(&quot;target&quot;))
    .withArguments(CommandArgument(&quot;command&quot;))
    .executes(CommandExecutor { _, args -&gt;
        val target = args[&quot;target&quot;] as Player
        val command = args[&quot;command&quot;] as CommandResult

        command.execute(target)
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;sudo&quot;) {
    playerArgument(&quot;target&quot;)
    commandArgument(&quot;command&quot;)
    anyExecutor { _, args -&gt;
        val target = args[&quot;target&quot;] as Player
        val command = args[&quot;command&quot;] as CommandResult

        command.execute(target)
    }
}
</code></pre>
</div>
</div>
<hr />
<h2 id="restricted-commands"><a class="header" href="#restricted-commands">Restricted commands</a></h2>
<p>Restricted commands allows you to restrict what commands a user is allowed to submit in the <code>CommandArgument</code>. Commands can be restricted by replacing the <code>CommandArgument</code>'s suggestions using the <code>replaceSuggestions()</code> method. For better fine-tuning of what commands a user can submit, commands can also be restricted by using <em>suggestion branches</em>.</p>
<!-- TODO: Give an example using .replaceSuggestions(). -->
<div class="example">
<h3 id="example---restricting-commands-using-suggestion-branches"><a class="header" href="#example---restricting-commands-using-suggestion-branches">Example - Restricting commands using suggestion branches</a></h3>
<p>To demonstrate restricting commands, let's create a command argument that allows players to enter one of the following commands:</p>
<pre><code class="language-mccmd">/tp &lt;player&gt; &lt;target&gt;
/give &lt;player&gt; &lt;item&gt; &lt;amount&gt;
</code></pre>
<p>Let's also add a restriction that the player can only use diamonds or dirt for the <code>/give</code> command, and they can only specify an amount if they selected dirt. Overall, our command argument should allow players to follow this path:</p>
<div style="position: relative; left: -50px;">
<p>\begin{gather}
\texttt{(start)}\\
\swarrow\hspace{2cm}\searrow\\
\swarrow\hspace{3.4cm}\searrow\\
\texttt{tp}\hspace{4cm}\texttt{give}\\
\swarrow\hspace{6cm}\searrow\\
\texttt{player}\hspace{6cm}\texttt{player}\\
\swarrow\hspace{7cm}\swarrow\hspace{2cm}\searrow\\
\texttt{target}\hspace{5cm}\texttt{diamond}\hspace{3cm}\texttt{dirt}\\
\hspace{6.7cm}\texttt{minecraft:diamond}\hspace{3cm}\texttt{minecraft:dirt}\\
\hspace{7.5cm}\hspace{4cm}\downarrow\\
\hspace{7.5cm}\hspace{4cm}\texttt{(amount)}\\
\end{gather}</p>
</div>
<p>In our diagram above, we have two main branches: <code>/tp</code> and <code>/give</code>. The <code>/tp</code> branch has <code>player</code> followed by <code>target</code>, and the <code>/give</code> branch has <code>player</code> and then that branches off into two new sections.</p>
<p>We can implement our <code>/tp</code> branch using the <code>SuggestionsBranch.suggest()</code> method, then provide argument suggestions for our options. In this case, we have <code>tp</code> and then a list of online players. We include the list of online players twice, because we need suggestions for <code>&lt;player&gt;</code> as well as <code>&lt;target&gt;</code>:</p>
<div class="multi-pre">
<pre><code class="language-java Java">SuggestionsBranch.suggest(
    ArgumentSuggestions.strings(&quot;tp&quot;),
    ArgumentSuggestions.strings(info -&gt; Bukkit.getOnlinePlayers().stream().map(Player::getName).toArray(String[]::new)),
    ArgumentSuggestions.strings(info -&gt; Bukkit.getOnlinePlayers().stream().map(Player::getName).toArray(String[]::new))
)
</code></pre>
<pre><code class="language-kotlin Kotlin">SuggestionsBranch.suggest&lt;CommandSender&gt;(
    ArgumentSuggestions.strings(&quot;tp&quot;),
    ArgumentSuggestions.strings { _ -&gt; Bukkit.getOnlinePlayers().map{ it.name }.toTypedArray() },
    ArgumentSuggestions.strings { _ -&gt; Bukkit.getOnlinePlayers().map{ it.name }.toTypedArray() }
)
</code></pre>
</div>
<p>For the <code>/give</code> branch, we can use a similar thing, but we need to tell the CommandArgument that the <code>/give</code> command branches into &quot;diamond&quot; and &quot;dirt&quot; suggestions. We can do this by using the <code>.branch()</code> method to add a new nested list of suggestions:</p>
<div class="multi-pre">
<pre><code class="language-java Java">SuggestionsBranch.suggest(
    ArgumentSuggestions.strings(&quot;give&quot;),
    ArgumentSuggestions.strings(info -&gt; Bukkit.getOnlinePlayers().stream().map(Player::getName).toArray(String[]::new))
).branch(
    SuggestionsBranch.suggest(
        ArgumentSuggestions.strings(&quot;diamond&quot;, &quot;minecraft:diamond&quot;),
        ArgumentSuggestions.empty()
    ),
    SuggestionsBranch.suggest(
        ArgumentSuggestions.strings(&quot;dirt&quot;, &quot;minecraft:dirt&quot;),
        null,
        ArgumentSuggestions.empty()
    )
)
</code></pre>
<pre><code class="language-kotlin Kotlin">SuggestionsBranch.suggest&lt;CommandSender&gt;(
    ArgumentSuggestions.strings(&quot;give&quot;),
    ArgumentSuggestions.strings { _ -&gt; Bukkit.getOnlinePlayers().map{ it.name }.toTypedArray() }
).branch(
    SuggestionsBranch.suggest(
        ArgumentSuggestions.strings(&quot;diamond&quot;, &quot;minecraft:diamond&quot;),
        ArgumentSuggestions.empty()
    ),
    SuggestionsBranch.suggest(
        ArgumentSuggestions.strings(&quot;dirt&quot;, &quot;minecraft:dirt&quot;),
        null,
        ArgumentSuggestions.empty()
    )
)
</code></pre>
</div>
<p>Adding everything together, we get this fully completed CommandArgument:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandArgument(&quot;command&quot;)
    .branchSuggestions(
        SuggestionsBranch.&lt;CommandSender&gt;suggest(
            ArgumentSuggestions.strings(&quot;give&quot;),
            ArgumentSuggestions.strings(info -&gt; Bukkit.getOnlinePlayers().stream().map(Player::getName).toArray(String[]::new))
        ).branch(
            SuggestionsBranch.suggest(
                ArgumentSuggestions.strings(&quot;diamond&quot;, &quot;minecraft:diamond&quot;),
                ArgumentSuggestions.empty()
            ),
            SuggestionsBranch.suggest(
                ArgumentSuggestions.strings(&quot;dirt&quot;, &quot;minecraft:dirt&quot;),
                null,
                ArgumentSuggestions.empty()
            )
        ),
        SuggestionsBranch.suggest(
            ArgumentSuggestions.strings(&quot;tp&quot;),
            ArgumentSuggestions.strings(info -&gt; Bukkit.getOnlinePlayers().stream().map(Player::getName).toArray(String[]::new)),
            ArgumentSuggestions.strings(info -&gt; Bukkit.getOnlinePlayers().stream().map(Player::getName).toArray(String[]::new))
        )
    );
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandArgument(&quot;command&quot;)
    .branchSuggestions(
        SuggestionsBranch.suggest&lt;CommandSender&gt;(
            ArgumentSuggestions.strings(&quot;give&quot;),
            ArgumentSuggestions.strings { _ -&gt; Bukkit.getOnlinePlayers().map{ it.name }.toTypedArray() }
        ).branch(
            SuggestionsBranch.suggest(
                ArgumentSuggestions.strings(&quot;diamond&quot;, &quot;minecraft:diamond&quot;),
                ArgumentSuggestions.empty()
            ),
            SuggestionsBranch.suggest(
                ArgumentSuggestions.strings(&quot;dirt&quot;, &quot;minecraft:dirt&quot;),
                null,
                ArgumentSuggestions.empty()
            )
        ),
        SuggestionsBranch.suggest(
            ArgumentSuggestions.strings(&quot;tp&quot;),
            ArgumentSuggestions.strings { _ -&gt; Bukkit.getOnlinePlayers().map{ it.name }.toTypedArray() },
            ArgumentSuggestions.strings { _ -&gt; Bukkit.getOnlinePlayers().map{ it.name }.toTypedArray() }
        )
    )
</code></pre>
</div>
</div>
<h3 id="null-and-empty-suggestions"><a class="header" href="#null-and-empty-suggestions">Null and empty suggestions</a></h3>
<p>In the above example about restricted commands, we used <code>null</code> and <code>ArgumentSuggestions.empty()</code> in our <code>SuggestionsBranch.suggest()</code> method. These special suggestions have specific effects when used in suggestions for the <code>CommandArgument</code>.</p>
<h4 id="null-suggestions"><a class="header" href="#null-suggestions">Null suggestions</a></h4>
<p>Null suggestions ensure that the suggestions at the current position will not be overridden. In the case of the <code>CommandArgument</code>, this means that the default command suggestions will be provided. For example, if we have the following <code>null</code> entry in our suggestions, users are allowed to enter a value if they choose to do so, meaning that the examples below are all valid:</p>
<pre><code class="language-java">SuggestionsBranch.suggest(
    ArgumentSuggestions.strings(&quot;give&quot;),
    null,
    ArgumentSuggestions.empty()
)
</code></pre>
<pre><code class="language-mccmd">/give dirt
/give diamond
/give apple
</code></pre>
<p>Ending the command argument with nothing is also equivalent to using <code>null</code>, for example the following suggestion branch allows any of the following commands:</p>
<pre><code class="language-java">SuggestionsBranch.suggest(
    ArgumentSuggestions.strings(&quot;give&quot;),
    ArgumentSuggestions.strings(&quot;dirt&quot;, &quot;minecraft:dirt&quot;)
)
</code></pre>
<pre><code class="language-mccmd">/give dirt
/give dirt 10
/give dirt 10 name:Hello
</code></pre>
<h4 id="empty-suggestions"><a class="header" href="#empty-suggestions">Empty suggestions</a></h4>
<p>Empty suggestions that are provided using <code>ArgumentSuggestions.empty()</code> tell the <code>CommandArgument</code> to stop accepting further suggestions. This &quot;ends&quot; the command. Using the following example, this allows the user to enter <code>/give diamond</code> and only <code>/give diamond</code> - users cannot enter any other commands.</p>
<pre><code class="language-java">SuggestionsBranch.suggest(
    ArgumentSuggestions.strings(&quot;give&quot;),
    ArgumentSuggestions.strings(&quot;diamond&quot;, &quot;minecraft:diamond&quot;),
    ArgumentSuggestions.empty()
)
</code></pre>
<p>These commands are valid:</p>
<pre><code class="language-mccmd">/give diamond
/give minecraft:diamond
</code></pre>
<p>These commands are not valid:</p>
<pre><code class="language-mccmd">/give
/give diamond 10
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-arguments"><a class="header" href="#custom-arguments">Custom arguments</a></h1>
<p>Custom arguments are a quality-of-life feature that the CommandAPI offers which allows you to perform pre-processing on an argument in the argument instance rather than in your <code>executes()</code> method for a command. They are designed to be used for multiple commands - you can define the argument once and can use it wherever you want when declaring commands.</p>
<hr />
<p>The <code>CustomArgument&lt;T, B&gt;</code> has the following constructor:</p>
<pre><code class="language-java">public CustomArgument(Argument&lt;B&gt; base, CustomArgumentInfoParser&lt;T, B&gt; parser);
</code></pre>
<p>This constructor takes in two parameters:</p>
<ul>
<li>
<p>A &quot;base argument&quot;, which is the argument that it'll use as the underlying parser. For example, if this is a <code>StringArgument</code>, it'll use the StringArgument's parsing rules ( alphanumeric characters (A-Z, a-z and 0-9), and the underscore character) and if this is a <code>LocationArgument</code>, it'll take three numerical values.</p>
</li>
<li>
<p>A &quot;parser&quot;, which lets you process the argument based on its input. This is described in more detail below.</p>
</li>
</ul>
<h3 id="type-params"><a class="header" href="#type-params">Type params</a></h3>
<p>The custom argument requires two type parameters, <code>&lt;T&gt;</code> and <code>&lt;B&gt;</code>:</p>
<ul>
<li>
<p><code>&lt;T&gt;</code> refers to the type that this argument will return when parsing the arguments for a command. For instance, if you have a <code>CustomArgument&lt;Player, ...&gt;</code>, then when parsing the arguments for the command, you would cast it to a <code>Player</code> object.</p>
</li>
<li>
<p><code>&lt;B&gt;</code> refers to the type that the base argument will return. This can be found in the <a href="./arguments.html#argument-casting">Argument Casting</a> section. For example, if the base argument is a <code>StringArgument</code>, you'd have <code>CustomArgument&lt;..., String&gt;</code>.</p>
</li>
</ul>
<hr />
<h2 id="the-customargumentinfoparser-class"><a class="header" href="#the-customargumentinfoparser-class">The CustomArgumentInfoParser class</a></h2>
<p>To create a parser for a <code>CustomArgument</code>, you need to provide a <code>CustomArgumentInfoParser</code> function to the constructor. The <code>CustomArgumentInfoParser</code> class is a functional interface which accepts <code>CustomArgumentInfo</code> and returns <code>T</code>, an object of your choosing:</p>
<pre><code class="language-java">@FunctionalInterface
public interface CustomArgumentInfoParser&lt;T, B&gt; {

    public T apply(CustomArgumentInfo&lt;B&gt; info) throws CustomArgumentException;

}
</code></pre>
<p>The <code>CustomArgumentInfo</code> record is very similar to the <code>SuggestionInfo</code> record for declaring argument suggestions. This record contains the following methods:</p>
<pre><code class="language-java">public record CustomArgumentInfo&lt;B&gt; {
    CommandSender sender();
    CommandArguments previousArgs(); 
    String input();
    B currentInput();
}
</code></pre>
<p>These fields are as follows:</p>
<ul>
<li>
<pre><code class="language-java">CommandSender sender();
</code></pre>
<p><code>sender()</code> represents the command sender that is typing the command. This is normally a <code>Player</code>, but can also be a console command sender if using a Paper server.</p>
</li>
<li>
<pre><code class="language-java">CommandArguments previousArgs();
</code></pre>
<p><code>previousArgs()</code> represents the previously declared arguments, which are parsed and interpreted as if they were being used to execute the command.</p>
</li>
<li>
<pre><code class="language-java">String input();
</code></pre>
<p><code>input()</code> represents the current input <em>for the custom argument</em> that the user has typed. For example, if a user is typing <code>/mycommand hello</code> and the first argument is a CustomArgument, the <code>input()</code> would return <code>&quot;hello&quot;</code>.</p>
</li>
<li>
<pre><code class="language-java">B currentInput();
</code></pre>
<p><code>currentInput()</code> represents the current input, as parsed by the base argument. For example, if your base argument was an <code>IntegerArgument</code>, the return type of <code>currentInput()</code> would be an <code>int</code>.</p>
</li>
</ul>
<hr />
<div class="example">
<h3 id="example---world-argument"><a class="header" href="#example---world-argument">Example - World argument</a></h3>
<p>Say we want to create an argument to represents the list of available worlds on the server. We want to have an argument which always returns a Bukkit <code>World</code> object as the result. Here, we create a method <code>worldArgument()</code> that returns our custom argument that returns a <code>World</code>. First, we retrieve our <code>String[]</code> of world names to be used for our suggestions. We then write our custom argument that creates a <code>World</code> object from the input (in this case, we simply convert the input to a <code>World</code> using <code>Bukkit.getWorld(String)</code>). We perform error handling before returning our result:</p>
<div class="multi-pre">
<pre><code class="language-java Java">// Function that returns our custom argument
public Argument&lt;World&gt; customWorldArgument(String nodeName) {

    // Construct our CustomArgument that takes in a String input and returns a World object
    return new CustomArgument&lt;World, String&gt;(new StringArgument(nodeName), info -&gt; {
        // Parse the world from our input
        World world = Bukkit.getWorld(info.input());

        if (world == null) {
            throw CustomArgumentException.fromMessageBuilder(new MessageBuilder(&quot;Unknown world: &quot;).appendArgInput());
        } else {
            return world;
        }
    }).replaceSuggestions(ArgumentSuggestions.strings(info -&gt;
        // List of world names on the server
        Bukkit.getWorlds().stream().map(World::getName).toArray(String[]::new))
    );
}
</code></pre>
<pre><code class="language-kotlin Kotlin">// Function that returns our custom argument
fun worldArgument(nodeName: String): Argument&lt;World&gt; {

    // Construct our CustomArgument that takes in a String input and returns a World object
    return CustomArgument&lt;World, String&gt;(StringArgument(nodeName)) { info -&gt;
        // Parse the world from our input
        val world = Bukkit.getWorld(info.input())

        if (world == null) {
            throw CustomArgumentException.fromMessageBuilder(MessageBuilder(&quot;Unknown world: &quot;).appendArgInput())
        } else {
            world
        }
    }.replaceSuggestions(ArgumentSuggestions.strings { _ -&gt;
        // List of world names on the server
        Bukkit.getWorlds().map{ it.name }.toTypedArray()
    })
}
</code></pre>
</div>
<p>In our error handling step, we check if the world is equal to null (since the <code>Bukkit.getWorld(String)</code> is <code>@Nullable</code>). To handle this case, we throw a <code>CustomArgumentException</code> with an error from a <code>MessageBuilder</code>. The <code>CustomArgumentException</code> has various static factory methods tailored to your desired printing method, so a message builder isn't required each time:</p>
<pre><code class="language-java">CustomArgumentException fromBaseComponents(BaseComponent[] errorMessage);
CustomArgumentException fromString(String errorMessage);
CustomArgumentException fromAdventureComponent(Component errorMessage);
CustomArgumentException fromMessageBuilder(MessageBuilder errorMessage);
</code></pre>
<hr />
<p>We can use our custom argument like any other argument. Say we wanted to write a command to teleport to a specific world. We will create a command of the following syntax:</p>
<pre><code class="language-mccmd">/tpworld &lt;world&gt;
</code></pre>
<p>Since we have defined the method <code>worldArgument()</code> which automatically generates our argument, we can use it as follows:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;tpworld&quot;)
    .withArguments(customWorldArgument(&quot;world&quot;))
    .executesPlayer((player, args) -&gt; {
        player.teleport(((World) args.get(&quot;world&quot;)).getSpawnLocation());
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;tpworld&quot;)
    .withArguments(worldArgument(&quot;world&quot;))
    .executesPlayer(PlayerCommandExecutor { player, args -&gt;
        player.teleport((args[&quot;world&quot;] as World).spawnLocation)
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;tpworld&quot;) {
    worldArgument(&quot;world&quot;) // This method is actually also built into the Kotlin DSL
    playerExecutor { player, args -&gt;
        player.teleport((args[&quot;world&quot;] as World).spawnLocation)
    }
}
</code></pre>
</div>
<hr />
<p>By using a <code>CustomArgument</code> (as opposed to a simple <code>StringArgument</code> and replacing its suggestions), we are able to provide a much more powerful form of error handling (automatically handled inside the argument), and we can reuse this argument for other commands.</p>
</div>
<hr />
<h2 id="message-builders"><a class="header" href="#message-builders">Message Builders</a></h2>
<p>The <code>MessageBuilder</code> class is a class to easily create messages to describe errors when a sender sends a command which does not meet the expected syntax for an argument. It acts in a similar way to a <code>StringBuilder</code>, where you can append content to the end of a String.</p>
<p>The following methods are as follows:</p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody>
<tr><td><code>appendArgInput()</code></td><td>Appends the argument that failed that the sender submitted to the end of the builder. E.g. <code>/foo bar</code> will append <code>bar</code></td></tr>
<tr><td><code>appendFullInput()</code></td><td>Appends the full command that a sender submitted to the end of the builder. E.g. <code>/foo bar</code> will append <code>foo bar</code></td></tr>
<tr><td><code>appendHere()</code></td><td>Appends the text <code>&lt;--[HERE]</code> to the end of the builder</td></tr>
<tr><td><code>append(Object)</code></td><td>Appends an object to the end of the builder</td></tr>
</tbody></table>
</div><div class="example">
<h3 id="example---message-builder-for-invalid-objective-argument"><a class="header" href="#example---message-builder-for-invalid-objective-argument">Example - Message builder for invalid objective argument</a></h3>
<p>To create a <code>MessageBuilder</code>, simply call its constructor and use whatever methods as you see fit. Unlike a <code>StringBuilder</code>, you don't have to &quot;build&quot; it when you're done - the CommandAPI does that automatically:</p>
<pre><code class="language-java">new MessageBuilder(&quot;Unknown world: /&quot;).appendFullInput().appendHere();
</code></pre>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>The CommandAPI has support to use Minecraft's <a href="https://minecraft.wiki/w/Function_(Java_Edition)">functions</a> within your plugins. This is handled by using a class provided by the CommandAPI called <code>FunctionWrapper</code>, which allows you to execute functions. The CommandAPI also provides support to let you run your own commands within Minecraft function files.</p>
<hr />
<h2 id="functions-in-116"><a class="header" href="#functions-in-116">Functions in 1.16+</a></h2>
<blockquote>
<p><strong>Developer's Note:</strong></p>
<p>Minecraft 1.16+ change the way that datapacks are loaded on the server, so that they load before plugins are enabled. This means that non-vanilla commands that are declared in functions and tags will be detected as invalid, causing the server to throw a lot of errors at the very start.</p>
<p>The CommandAPI reloads datapacks once the server has finished loading using all declared commands, therefore <strong>the error messages at the start of the server can be ignored</strong>.</p>
</blockquote>
<hr />
<h2 id="using-custom-commands-in-functions"><a class="header" href="#using-custom-commands-in-functions">Using custom commands in functions</a></h2>
<p>In order to use a command from your plugin in a <code>.mcfunction</code> file, you must register your command in your plugin's <code>onLoad()</code> method, instead of the <code>onEnable()</code> method. Failure to do so will not allow the command to be registered for Minecraft functions, causing the function file to fail to load during the server startup phase.</p>
<blockquote>
<p><strong>Developer's Note:</strong></p>
<p>In short, if you want to register a command which can be used in Minecraft functions, register it in your plugin's <code>onLoad()</code> method.</p>
</blockquote>
<div class="example">
<h3 id="example---registering-command-for-use-in-a-function"><a class="header" href="#example---registering-command-for-use-in-a-function">Example - Registering command for use in a function</a></h3>
<p>Say we have a command <code>/killall</code> that simply kills all entities in all worlds on the server. If we were to register this in our <code>onLoad()</code> method, this would allow us to use the <code>/killall</code> command in Minecraft functions and tags.</p>
<div class="multi-pre">
<pre><code class="language-java Java">public class Main extends JavaPlugin {

    @Override
    public void onLoad() {
        // Commands which will be used in Minecraft functions are registered here

        new CommandAPICommand(&quot;killall&quot;)
            .executes((sender, args) -&gt; {
                // Kills all enemies in all worlds
                Bukkit.getWorlds().forEach(w -&gt; w.getLivingEntities().forEach(e -&gt; e.setHealth(0)));
            })
            .register();
    }
    
    @Override
    public void onEnable() {
        // Register all other commands here
    } 
}
</code></pre>
<pre><code class="language-kotlin Kotlin">class Main : JavaPlugin() {

    override fun onLoad() {
        // Commands which will be used in Minecraft functions are registered here

        CommandAPICommand(&quot;killall&quot;)
            .executes(CommandExecutor { _, _ -&gt;
                // Kills all enemies in all worlds
                Bukkit.getWorlds().forEach { world -&gt; world.livingEntities.forEach { entity -&gt; entity.health = 0.0 } }
            })
            .register()
    }

    override fun onEnable() {
        // Register all other commands here
    }

}
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-functions--tags"><a class="header" href="#setting-up-functions--tags">Setting up functions &amp; tags</a></h1>
<blockquote>
<p><strong>Developer's Note:</strong></p>
<p>Most developers can completely skip this section. This is for those that are unfamiliar with functions and tags and is less about how the CommandAPI works.</p>
</blockquote>
<p>This section explains how functions are declared and set up for use in a Minecraft server. This is ideal for server owners who've never set up functions, or developers <em>(like the Command API's creator)</em> that has no idea how to set this sort of thing up.</p>
<hr />
<h2 id="creating-functions"><a class="header" href="#creating-functions">Creating functions</a></h2>
<p>Functions are text files <em>(with the <code>.mcfunction</code> extension)</em> which contains lists of functions which are executed one after another. Each line of the file is a valid Minecraft command. Say we have <code>text.mcfunction</code>:</p>
<pre><code class="language-mccmd">killall
say Killed all living entities on the server
</code></pre>
<p>This will run the custom command killall <em>(as declared in <a href="./functions.html#example---registering-command-for-use-in-a-function"><strong>Example - Registering command for use in a function</strong></a>)</em>, and then broadcast a message to all players stating that all entities were killed.</p>
<hr />
<h2 id="creating-tags"><a class="header" href="#creating-tags">Creating tags</a></h2>
<p>Tags are json files which contain a list of functions. Tags let you run multiple functions at a time. Say we have a tag called <code>mytag.json</code>:</p>
<pre><code class="language-json">{
    &quot;values&quot;: [
        &quot;mycustomnamespace:test&quot;,
        &quot;mycustomnamespace:test2&quot;
    ]
}
</code></pre>
<p>This will run the function <code>test</code> and the function <code>test2</code>, which are in the namespace <code>mycustomnamespace</code>.</p>
<hr />
<h2 id="namespaces--where-to-place-everything"><a class="header" href="#namespaces--where-to-place-everything">Namespaces &amp; where to place everything</a></h2>
<p>The following hierarchy explains where functions and tags go. In this diagram, the two functions <code>test</code> and <code>test2</code> are in a directory called <code>functions</code>. There is also a tag called <code>mytag</code> which is placed in the <code>tags</code> directory under <code>functions</code>. These are all under the <em>namespace</em> called <code>mycustomnamespace</code></p>
<pre><code class="language-txt">server/
├── world/
│   ├── advancements/
│   ├── data/
│   ├── datapacks/
│   │   └── bukkit/
│   │       ├── pack.mcmeta
│   │       └── data/
│   │           └── mycustomnamespace/
│   │               ├── functions/
│   │               │   ├── test.mcfunction
│   │               │   └── test2.mcfunction
│   │               └── tags/
│   │                   └── functions/
│   │                       └── mytag.json
│   └── ...
├── world_nether/
├── world_the_end/
├── ...
└── spigot.jar
</code></pre>
<p>To execute the <code>test</code> function, you would run the following command:</p>
<pre><code class="language-mccmd">/function mycustomnamespace:test
</code></pre>
<p>To execute the <code>mytag</code> tag, you would run the following command:</p>
<pre><code class="language-mccmd">/function #mycustomnamespace:mytag
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-simplefunctionwrapper-class"><a class="header" href="#the-simplefunctionwrapper-class">The SimpleFunctionWrapper class</a></h1>
<p>To represent Minecraft functions and tags, the CommandAPI uses the <code>SimpleFunctionWrapper</code> class. Simply put, this class represents <em>one</em> Minecraft function, which are defined in <code>.mcfunction</code> files.</p>
<blockquote>
<p><strong>Developer's Note</strong></p>
<p>The <code>SimpleFunctionWrapper</code> class represents a Minecraft function. In order to represent a Minecraft &quot;tag&quot;, which is a collection of Minecraft functions, the CommandAPI simply uses a <code>SimpleFunctionWrapper[]</code>.</p>
</blockquote>
<h2 id="simplefunctionwrapper-methods"><a class="header" href="#simplefunctionwrapper-methods">SimpleFunctionWrapper methods</a></h2>
<p>The <code>SimpleFunctionWrapper</code> class has the following methods:</p>
<pre><code class="language-java">class SimpleFunctionWrapper implements Keyed {
    
    // Methods that creates SimpleFunctionWrapper instances
    static SimpleFunctionWrapper getFunction(NamespacedKey key);
    static SimpleFunctionWrapper[] getTag(NamespacedKey key);

    // Methods that query the Minecraft server
    static Set&lt;NamespacedKey&gt; getFunctions();
    static Set&lt;NamespacedKey&gt; getTags();
    
    // Methods for using the SimpleFunctionWrapper
    int run(CommandSender sender);
    
    // Utility functions
    String[] getCommands();
    NamespacedKey getKey();
}
</code></pre>
<h3 id="gettagnamespacedkey-and-getfunctionnamespacedkey"><a class="header" href="#gettagnamespacedkey-and-getfunctionnamespacedkey">getTag(NamespacedKey) and getFunction(NamespacedKey)</a></h3>
<p>The <code>getFunction(NamespacedKey)</code> function is used to get a function that has been declared in a datapack and is loaded on the server.</p>
<p>The <code>getTag(NamespacedKey)</code> function is used to get a Tag that has been declared in a datapack and is loaded on the server. This returns a <code>SimpleFunctionWrapper[]</code>, since a tag is simply an ordered collection of functions. When using this method, the <code>#</code> symbol which is typically used at the start of the tag's name <em>is not needed</em>.</p>
<h3 id="getfunctions-and-gettags"><a class="header" href="#getfunctions-and-gettags">getFunctions() and getTags()</a></h3>
<p>The methods <code>getFunctions()</code> and <code>getTags()</code> simply return a set of <code>NamespacedKey</code> objects which are the names of functions or tags that have been declared by all datapacks on the server.</p>
<h3 id="runcommandsender"><a class="header" href="#runcommandsender">run(CommandSender)</a></h3>
<div class="warning">
<h3 id="runcommandsender-support-in-1203"><a class="header" href="#runcommandsender-support-in-1203">run(CommandSender) support in 1.20.3+</a></h3>
<p>As of CommandAPI 9.3.0 (compatible with Minecraft versions 1.20.3 and 1.20.4), calling <code>run(CommandSender)</code> will always return a value of <code>1</code>, regardless of whether the command succeeds, fails, or returns a result.</p>
</div>
<p>This method simply runs the current <code>SimpleFunctionWrapper</code> as the provided command sender. The method will return a numerical result value, stating whether it succeeds or returns a result. This is documented in more detail <a href="./normalexecutors.html">here</a> and <a href="./resultingcommandexecutors.html">here</a>. For example:</p>
<h3 id="getcommands"><a class="header" href="#getcommands">getCommands()</a></h3>
<div class="warning">
<h3 id="getcommands-support-in-1203"><a class="header" href="#getcommands-support-in-1203">getCommands() support in 1.20.3+</a></h3>
<p>As of CommandAPI 9.3.0 (compatible with Minecraft versions 1.20.3 and 1.20.4), calling <code>getCommands()</code> will always return an empty <code>String[]</code>. At the time of writing, it is not possible to extract the function command list in 1.20.3+.</p>
</div>
<p>The <code>getCommands()</code> method returns a <code>String[]</code> that contains the list of commands that the Minecraft function &quot;holds&quot;. In other words, running this Minecraft function is as simple as iterating through its commands and running them in order. The commands that this <code>String[]</code> holds are the raw strings that this function represents - in other words, it can include things such as <code>@p</code> and <code>~ ~ ~</code> instead of &quot;filled in&quot; values.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-functionwrapper"><a class="header" href="#the-functionwrapper">The FunctionWrapper</a></h1>
<p>The CommandAPI includes the <code>FunctionWrapper</code> class which is a wrapper for Minecraft's functions. It allows you to execute the commands that are represented by the respective <code>.mcfunction</code> file.</p>
<p>The <code>FunctionWrapper</code> class is an extension of the <code>SimpleFunctionWrapper</code> class. It is a <code>SimpleFunctionWrapper</code> which has been constructed from an existing command sender when a command is used. This means that the command sender has already been &quot;baked into&quot; the <code>FunctionWrapper</code> object, allowing you to run it without having to provide a command sender.</p>
<h2 id="functionwrapper-methods"><a class="header" href="#functionwrapper-methods">FunctionWrapper methods</a></h2>
<p>The <code>FunctionWrapper</code> class has the following methods:</p>
<pre><code class="language-java">class FunctionWrapper extends SimpleFunctionWrapper {

    // Methods specific to this class
    int run();
    int runAs(Entity e);

    // Methods inherited from SimpleFunctionWrapper
    static SimpleFunctionWrapper getFunction(NamespacedKey key);
    static SimpleFunctionWrapper[] getTag(NamespacedKey key);
    static Set&lt;NamespacedKey&gt; getFunctions();
    static Set&lt;NamespacedKey&gt; getTags();
    int run(CommandSender sender);
    String[] getCommands();
    NamespacedKey getKey();
}
</code></pre>
<p>These methods allow you to interact with the Minecraft function that this class wraps.</p>
<h3 id="run"><a class="header" href="#run"><code>run()</code></a></h3>
<div class="warning">
<h3 id="run-support-in-1203"><a class="header" href="#run-support-in-1203">run() support in 1.20.3+</a></h3>
<p>As of CommandAPI 9.3.0 (compatible with Minecraft versions 1.20.3 and 1.20.4), calling <code>run()</code> will always return a value of <code>1</code>, regardless of whether the command succeeds, fails, or returns a result.</p>
</div>
<p>The <code>run()</code> method runs the function. The command executor that runs this function is the command executor that was used to retrieve it. For example, if a player in-game populated this argument, then the player will be filled in for <code>@p</code> and the player's location would be used for things such as <code>~ ~ ~</code>:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;runfunc&quot;)
    .withArguments(new FunctionArgument(&quot;function&quot;))
    .executes((sender, args) -&gt; {
        FunctionWrapper[] functions = (FunctionWrapper[]) args.get(&quot;function&quot;);
        for (FunctionWrapper function : functions) {
            function.run(); // The command executor in this case is 'sender'
        }
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;runfunc&quot;)
    .withArguments(FunctionArgument(&quot;function&quot;))
    .executes(CommandExecutor { _, args -&gt;
        val functions = args[&quot;function&quot;] as Array&lt;FunctionWrapper&gt;
        for (function in functions) {
            function.run() // The command executor in this case is 'sender'
        }
    })
    .register()
</code></pre>
</div>
<h3 id="runasentity"><a class="header" href="#runasentity"><code>runAs(Entity)</code></a></h3>
<div class="warning">
<h3 id="runasentity-support-in-1203"><a class="header" href="#runasentity-support-in-1203">runAs(Entity) support in 1.20.3+</a></h3>
<p>As of CommandAPI 9.3.0 (compatible with Minecraft versions 1.20.3 and 1.20.4), calling <code>runAs(Entity)</code> will always return a value of <code>1</code>, regardless of whether the command succeeds, fails, or returns a result.</p>
</div>
<p>The <code>runAs(Entity)</code> is the same as the <code>run()</code> method, but it allows you to change the command executor to another entity.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="function-arguments"><a class="header" href="#function-arguments">Function arguments</a></h1>
<p><img src="./images/arguments/functions.png" alt="An image of a function argument showing a list of Minecraft functions and tags that are available to run" /></p>
<p>The <code>FunctionArgument</code> class is used to represent a function or a tag in Minecraft. When retrieving an instance of the argument, it will return a <code>FunctionWrapper[]</code>, where each <code>FunctionWrapper</code> consists of a Minecraft function.</p>
<p>Therefore, if a user supplies a single function, the <code>FunctionWrapper[]</code> will be of size 1, and if the user supplies a tag which can consist of multiple functions, the <code>FunctionWrapper[]</code> will consist of the array of functions as declared by that tag.</p>
<div class="example">
<h3 id="example---minecrafts-function-command"><a class="header" href="#example---minecrafts-function-command">Example - Minecraft's /function command</a></h3>
<p>Since it's a little difficult to demonstrate a custom use for the <code>FunctionArgument</code>, we will show how you can implement Vanilla Minecraft's <code>/function</code> command. In this example, we want a command that uses the following syntax:</p>
<pre><code class="language-mccmd">/runfunction &lt;function&gt;
</code></pre>
<p>When provided with a function, it will execute that function. If instead a tag is provided, it will execute that tag (i.e. execute all functions declared in that tag).</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;runfunction&quot;)
    .withArguments(new FunctionArgument(&quot;function&quot;))
    .executes((sender, args) -&gt; {
        FunctionWrapper[] functions = (FunctionWrapper[]) args.get(&quot;function&quot;);

        // Run all functions in our FunctionWrapper[]
        for (FunctionWrapper function : functions) {
            function.run();
        }
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;runfunction&quot;)
    .withArguments(FunctionArgument(&quot;function&quot;))
    .executes(CommandExecutor { _, args -&gt;
        val functions = args[&quot;function&quot;] as Array&lt;FunctionWrapper&gt;

        // Run all functions in our FunctionWrapper[]
        for (function in functions) {
            function.run()
        }
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;runfunction&quot;) {
    functionArgument(&quot;function&quot;)
    anyExecutor { _, args -&gt;
        val functions = args[&quot;function&quot;] as Array&lt;FunctionWrapper&gt;

        // Run all functions in our FunctionWrapper[]
        for (function in functions) {
            function.run()
        }
    }
}
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="permissions"><a class="header" href="#permissions">Permissions</a></h1>
<p>Permissions let you control which players are allowed to execute which commands. This is handled using the <code>CommandPermission</code> class, which has the following uses:</p>
<div class="table-wrapper"><table><thead><tr><th>Permission</th><th>What it does</th></tr></thead><tbody>
<tr><td><code>CommandPermission.OP</code></td><td>Requires OP to execute the command</td></tr>
<tr><td><code>CommandPermission.NONE</code></td><td>Anyone can execute the command</td></tr>
<tr><td><code>CommandPermission.fromString(&quot;my.permission&quot;)</code></td><td>Requires a specific permission node to execute the command</td></tr>
</tbody></table>
</div>
<p>In addition to the <code>CommandPermission</code> class, there are two different ways to assign permissions (compared to the simple <code>CommandSender.hasPermission()</code> method that is provided by Bukkit), by using the <code>withPermission</code> method for arguments or for commands.</p>
<p>The <code>withPermission</code> method can take two values:</p>
<ul>
<li>A <code>CommandPermission</code>, which represents a permission such as <code>OP</code> or <code>NONE</code></li>
<li>A <code>String</code>, which will be converted automatically to a <code>CommandPermission</code> using <code>CommandPermission.fromString()</code></li>
</ul>
<hr />
<h2 id="adding-permissions-to-commands"><a class="header" href="#adding-permissions-to-commands">Adding permissions to commands</a></h2>
<p>To add a permission to a command, you can use the <code>withPermission(CommandPermission)</code> or <code>withPermission(String)</code> method <em>when declaring a command</em>.</p>
<div class="example">
<h3 id="example---god-command-with-permissions"><a class="header" href="#example---god-command-with-permissions">Example - /god command with permissions</a></h3>
<p>Say we created a command <code>/god</code> that sets a player as being invulnerable. Since this is a pretty non-survival command, we want to restrict who can run this command. As such, we want our player to have the permission <code>command.god</code> in order to run this command. To do this, we simply use the <code>withPermission(CommandPermission)</code> method from our command builder:</p>
<div class="multi-pre">
<pre><code class="language-java Java">// Register the /god command with the permission node &quot;command.god&quot;
new CommandAPICommand(&quot;god&quot;)
    .withPermission(CommandPermission.fromString(&quot;command.god&quot;))
    .executesPlayer((player, args) -&gt; {
        player.setInvulnerable(true);
        player.sendMessage(&quot;God mode enabled&quot;);
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">// Register the /god command with the permission node &quot;command.god&quot;
CommandAPICommand(&quot;god&quot;)
    .withPermission(CommandPermission.fromString(&quot;command.god&quot;))
    .executesPlayer(PlayerCommandExecutor { player, _ -&gt;
        player.isInvulnerable = true
    })
    .register()
</code></pre>
</div>
<p>As stated above, it is possible to assign a permission using a String instead of using <code>CommandPermission.fromString()</code>:</p>
<div class="multi-pre">
<pre><code class="language-java Java">// Register the /god command with the permission node &quot;command.god&quot;, without creating a CommandPermission
new CommandAPICommand(&quot;god&quot;)
    .withPermission(&quot;command.god&quot;)
    .executesPlayer((player, args) -&gt; {
        player.setInvulnerable(true);
        player.sendMessage(&quot;God mode enabled&quot;);
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">// Register the /god command with the permission node &quot;command.god&quot;, without creating a CommandPermission
CommandAPICommand(&quot;god&quot;)
    .withPermission(&quot;command.god&quot;)
    .executesPlayer(PlayerCommandExecutor { player, _ -&gt;
        player.isInvulnerable = true
    })
    .register()
</code></pre>
</div>
</div>
<hr />
<h2 id="adding-permissions-to-arguments"><a class="header" href="#adding-permissions-to-arguments">Adding permissions to arguments</a></h2>
<p>For further fine-tuning of permission management, the CommandAPI allows you to add permissions to individual arguments. This prevents the user from executing a command <em>with a specific argument</em> if they do not have a specific permission.</p>
<p>This is done by using the <code>withPermission(CommandPermission)</code> method <em>at the end of an argument</em>.</p>
<p>If a player does not have the required permission:</p>
<ul>
<li>The argument hover text which suggests what the command is will not be shown</li>
<li>The player will receive an error if they try to type something in for that argument</li>
<li>Suggestions, such as a list of materials or players, will not be shown</li>
</ul>
<div class="example">
<h3 id="example---kill-command-with-argument-permissions"><a class="header" href="#example---kill-command-with-argument-permissions">Example - /kill command with argument permissions</a></h3>
<p>For example, say we're registering a command <code>/kill</code>:</p>
<pre><code class="language-mccmd">/kill          - Kills yourself
/kill &lt;target&gt; - Kills a target player
</code></pre>
<p>We first declare the command as normal. Nothing fancy is going on here:</p>
<div class="multi-pre">
<pre><code class="language-java Java">// Register /kill command normally. Since no permissions are applied, anyone can run this command
new CommandAPICommand(&quot;kill&quot;)
    .executesPlayer((player, args) -&gt; {
        player.setHealth(0);
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">// Register /kill command normally. Since no permissions are applied, anyone can run this command
CommandAPICommand(&quot;kill&quot;)
    .executesPlayer(PlayerCommandExecutor { player, _ -&gt;
        player.health = 0.0
    })
    .register()
</code></pre>
</div>
<p>Now we declare our command with arguments. We use a <code>PlayerArgument</code> and apply the permission <em>to the argument</em>. After that, we register our command as normal:</p>
<div class="multi-pre">
<pre><code class="language-java Java">// Adds the OP permission to the &quot;target&quot; argument. The sender requires OP to execute /kill &lt;target&gt;
new CommandAPICommand(&quot;kill&quot;)
    .withArguments(new PlayerArgument(&quot;target&quot;).withPermission(CommandPermission.OP))
    .executesPlayer((player, args) -&gt; {
        ((Player) args.get(&quot;target&quot;)).setHealth(0);
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">// Adds the OP permission to the &quot;target&quot; argument. The sender requires OP to execute /kill &lt;target&gt;
CommandAPICommand(&quot;kill&quot;)
    .withArguments(PlayerArgument(&quot;target&quot;).withPermission(CommandPermission.OP))
    .executesPlayer(PlayerCommandExecutor { _, args -&gt;
        (args[&quot;target&quot;] as Player).health = 0.0
    })
    .register()
</code></pre>
</div>
</div>
<hr />
<blockquote>
<p><strong>Developer's Note:</strong></p>
<p>As you can see, there are multiple ways of applying permissions to commands with arguments. In the <code>/god</code> command shown above, the permission was applied to the whole command. In the <code>/kill</code> command shown above, the permission was applied to the argument.</p>
<p>There's not really much difference between the two methods, but I personally would use <em>argument permissions</em> as it has greater control over arguments.</p>
</blockquote>
<hr />
<h2 id="child-based-permissions"><a class="header" href="#child-based-permissions">Child-based permissions</a></h2>
<p>Child-based permissions allow you to group permissions together.
We achieve this by laying out our permission groups in the <code>plugin.yml</code> file which Bukkit registers as valid permissions.
When the CommandAPI checks if our player has a permission, Bukkit considers if they have the child of a permission as well.
This not only keeps permissions easier to manage, it also makes your code cleaner and gives you a nice place to lay out all of your permissions,
detailing what they do and what other permissions inherit them.</p>
<h3 id="example---economy-command-with-argument-permissions"><a class="header" href="#example---economy-command-with-argument-permissions">Example - /economy command with argument permissions</a></h3>
<p>For example, say we're registering a command <code>/economy</code>:</p>
<pre><code class="language-mccmd">/economy                         - shows your own balance                 | economy.self
/economy &lt;target&gt;                - shows you another players balance      | economy.other
/economy give  &lt;target&gt; &lt;amount&gt; - gives the target a set amount of money | economy.admin.give
/economy reset &lt;target&gt; &lt;amount&gt; - resets the targets balance             | economy.admin.reset
</code></pre>
<p>We first declare the command as normal. Nothing fancy is going on here:</p>
<div class="multi-pre">
<pre><code class="language-java Java">// /economy - requires the permission &quot;economy.self&quot; to execute
new CommandAPICommand(&quot;economy&quot;)
    .withPermission(&quot;economy.self&quot;) // The important part of this example
    .executesPlayer((player, args) -&gt; {
        // send the executor their own balance here.
    })
    .register();

// /economy &lt;target&gt; - requires the permission &quot;economy.other&quot; to execute
new CommandAPICommand(&quot;economy&quot;)
    .withPermission(&quot;economy.other&quot;) // The important part of this example
    .withArguments(new PlayerArgument(&quot;target&quot;))
    .executesPlayer((player, args) -&gt; {
        Player target = (Player) args.get(&quot;target&quot;);

        // Send a message to the executor with the target's balance
        player.sendMessage(target.getName() + &quot;'s balance: &quot; + Economy.getBalance(target));
    })
    .register();

// /economy give &lt;target&gt; &lt;amount&gt; - requires the permission &quot;economy.admin.give&quot; to execute
new CommandAPICommand(&quot;economy&quot;)
    .withPermission(&quot;economy.admin.give&quot;) // The important part of this example
    .withArguments(new PlayerArgument(&quot;target&quot;))
    .withArguments(new DoubleArgument(&quot;amount&quot;))
    .executesPlayer((player, args) -&gt; {
        Player target = (Player) args.get(&quot;target&quot;);
        double amount = (Double) args.get(&quot;amount&quot;);

        // Update the target player's balance
        Economy.updateBalance(target, amount);
    })
    .register();

// /economy reset &lt;target&gt; - requires the permission &quot;economy.admin.reset&quot; to execute
new CommandAPICommand(&quot;economy&quot;)
    .withPermission(&quot;economy.admin.reset&quot;) // The important part of this example
    .withArguments(new PlayerArgument(&quot;target&quot;))
    .executesPlayer((player, args) -&gt; {
        Player target = (Player) args.get(&quot;target&quot;);

        // Reset target balance here
        Economy.resetBalance(target);
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">// /economy - requires the permission &quot;economy.self&quot; to exectue
CommandAPICommand(&quot;economy&quot;)
    .withPermission(&quot;economy.self&quot;)
    .executesPlayer(PlayerCommandExecutor { player, _ -&gt;
        // send the executor their own balance here.
    })
    .register()

// /economy &lt;target&gt; - requires the permission &quot;economy.other&quot; to execute
CommandAPICommand(&quot;economy&quot;)
    .withPermission(&quot;economy.other&quot;) // The important part of this example
    .withArguments(PlayerArgument(&quot;target&quot;))
    .executesPlayer(PlayerCommandExecutor { player, args -&gt;
        val target = args[&quot;target&quot;] as Player
        // send the executor the targets balance here.
    })
    .register()

// /economy give &lt;target&gt; &lt;amount&gt; - requires the permission &quot;economy.admin.give&quot; to execute
CommandAPICommand(&quot;economy&quot;)
    .withPermission(&quot;economy.admin.give&quot;) // The important part of this example
    .withArguments(PlayerArgument(&quot;target&quot;))
    .withArguments(DoubleArgument(&quot;amount&quot;))
    .executesPlayer(PlayerCommandExecutor { player, args -&gt;
        val target = args[&quot;target&quot;] as Player
        val amount = args[&quot;amount&quot;] as Double
        // update the targets balance here
    })
    .register()

// /economy reset &lt;target&gt; - requires the permission &quot;economy.admin.reset&quot; to execute
CommandAPICommand(&quot;economy&quot;)
    .withPermission(&quot;economy.admin.reset&quot;) // The important part of this example
    .withArguments(PlayerArgument(&quot;target&quot;))
    .executesPlayer(PlayerCommandExecutor { player, args -&gt;
        val target = args[&quot;target&quot;] as Player
        // reset the targets balance here
    })
    .register()
</code></pre>
</div>
<p>In our <strong>plugin.yml</strong> we can also set up our permissions for example...</p>
<pre><code class="language-yml">permissions:
  economy.*:
    description: Gives the user full access to the economy commands
    children:
      economy.other: true
      economy.admin.*: true

  economy.self:
    description: Allows the user to view their own balance
  economy.other:
    description: Allows the user to another players balance
    children:
      economy.self: true

  economy.admin.*:
    description: Gives the user access to all of the admin commands
    children:
      economy.admin.give: true
      economy.admin.reset: true
  economy.admin.give:
    description: Gives the user access to /economy give &lt;target&gt; &lt;amount&gt;
  economy.admin.reset:
    description: Gives the user access to /economy reset &lt;target&gt;
</code></pre>
<p>This setup of children allows us to give a player less permissions, but have them access more features.
Since <code>economy.*</code> inherits <code>economy.admin.*</code> which inherits <code>economy.admin.give</code>, a player with the permission <code>economy.*</code> will be able to execute <code>/economy give &lt;target&gt; &lt;amount&gt;</code> without them directly having the <code>economy.admin.give</code> permission node.
This also works with <code>economy.other</code>, if a player has <code>economy.other</code> they will <strong>inherit</strong> <code>economy</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="requirements"><a class="header" href="#requirements">Requirements</a></h1>
<p>Requirements is a feature that allows you to put a constraint on commands and arguments. Similar to permissions, a requirement is something that must be fulfilled in order to use a given command or argument.</p>
<p>This section is broken up into four parts:</p>
<ul>
<li>Adding requirements to commands</li>
<li>Adding requirements to arguments</li>
<li>Updating requirements</li>
<li>Multiple requirements</li>
</ul>
<p><strong>Please don't skip the section on updating requirements</strong> - the last section is necessary to get requirements to work as you'd want!</p>
<hr />
<h2 id="adding-requirements-to-commands"><a class="header" href="#adding-requirements-to-commands">Adding requirements to commands</a></h2>
<p>To add a requirement to a command, similar to adding permissions to commands, use the <code>withRequirement</code> method:</p>
<pre><code class="language-java">CommandAPICommand withRequirement(Predicate&lt;CommandSender&gt; sender);
</code></pre>
<p>The <code>withRequirement</code> method requires a predicate that determines if the sender is able to run the command - if the predicate is satisfied, then the command sender will be able to execute that command.</p>
<div class="example">
<h3 id="example---perks-based-on-a-players-level"><a class="header" href="#example---perks-based-on-a-players-level">Example - Perks based on a player's level</a></h3>
<p>Say we have a perks-based command system that depends on a player's level. For example, if a player has over 30 levels of experience, they would then be able to run a command that lets them repair the item in their hand in exchange for 30 levels. As such, we'll use the following command syntax:</p>
<pre><code class="language-mccmd">/repair
</code></pre>
<p>We want to put a requirement on this command that the player needs to have at least 30 levels of experience in order to run the command - if the player has less than 30 levels, the player should not be able to run the command. The easiest way to make the player not able to run the command is to literally tell the user that the command doesn't exist. That's what requirements do in the CommandAPI:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;repair&quot;)
    .withRequirement(sender -&gt; ((Player) sender).getLevel() &gt;= 30)
    .executesPlayer((player, args) -&gt; {
        
        // Repair the item back to full durability
        ItemStack is = player.getInventory().getItemInMainHand();
        ItemMeta itemMeta = is.getItemMeta();
        if (itemMeta instanceof Damageable damageable) {
            damageable.setDamage(0);
            is.setItemMeta(itemMeta);
        }
        
        // Subtract 30 levels
        player.setLevel(player.getLevel() - 30);
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;repair&quot;)
    .withRequirement { (it as Player).level &gt;= 30 }
    .executesPlayer(PlayerCommandExecutor { player, _ -&gt;

        // Repair the item back to full durability
        val item = player.inventory.itemInMainHand
        val itemMeta = item.itemMeta
        if (itemMeta is Damageable) {
            itemMeta.setDamage(0)
            item.setItemMeta(itemMeta)
        }

        // Subtract 30 levels
        player.setLevel(player.level - 30)
    })
    .register()
</code></pre>
</div>
<p>It's important to note that in this example, we case the <code>sender</code> to a <code>player</code> for the requirement method. We know that the sender is definitely a player because we use <code>executesPlayer()</code>, which ensures that this is the case. Now that we've got this, <strong>we need to make sure we update the player's requirements <em>when their exp changes</em></strong>. This is covered in more detail in the section about updating requirements below.</p>
</div>
<hr />
<h2 id="adding-requirements-to-arguments"><a class="header" href="#adding-requirements-to-arguments">Adding requirements to arguments</a></h2>
<p>In a similar way that you can restrict certain arguments by adding permissions to them, you can restrict them by using arbitrary predicates by using the <code>withRequirement</code> method on the arguments themselves.</p>
<div class="example">
<h3 id="example---a-party-creation-and-teleportation-system"><a class="header" href="#example---a-party-creation-and-teleportation-system">Example - A party creation and teleportation system</a></h3>
<p>Let's say that we're working on a plugin that has a system to form groups of players called &quot;parties&quot;. If you are not already in a party, you can create one of your own and if you are in a party, you can teleport to any other member in your party.</p>
<p>For this example, we'll use the following command syntax:</p>
<pre><code class="language-mccmd">/party create &lt;partyName&gt;
/party tp &lt;player&gt;
</code></pre>
<p>To represent our party in code, we'll use a simple <code>Map</code> called <code>partyMembers</code> which maps the player's UUID to the name of their registered party:</p>
<div class="multi-pre">
<pre><code class="language-java Java">Map&lt;UUID, String&gt; partyMembers = new HashMap&lt;&gt;();
</code></pre>
<pre><code class="language-kotlin Kotlin">val partyMembers = mutableMapOf&lt;UUID, String&gt;()
</code></pre>
</div>
<p>To begin with, let's create the <code>/party create &lt;partyName&gt;</code> command. First, we must declare our arguments:</p>
<div class="multi-pre">
<pre><code class="language-java Java">List&lt;Argument&lt;?&gt;&gt; arguments = new ArrayList&lt;&gt;();

// The &quot;create&quot; literal, with a requirement that a player must have a party
arguments.add(new LiteralArgument(&quot;create&quot;)
    .withRequirement(sender -&gt; !partyMembers.containsKey(((Player) sender).getUniqueId()))
);

arguments.add(new StringArgument(&quot;partyName&quot;));
</code></pre>
<pre><code class="language-kotlin Kotlin">var arguments = mutableListOf&lt;Argument&lt;*&gt;&gt;()

// The &quot;create&quot; literal, with a requirement that a player must have a party
arguments.add(LiteralArgument(&quot;create&quot;)
    .withRequirement { !partyMembers.containsKey((it as Player).uniqueId) }
)

arguments.add(StringArgument(&quot;partyName&quot;))
</code></pre>
</div>
<p>In this argument declaration, we put a requirement on the literal <code>create</code>, where the player does not have a party. In other words, if the player does not have a party, they are allowed to run <code>/party create &lt;partyName&gt;</code>. If a player already has a party, then they won't be allowed to run this command.</p>
<p>Now that we've declared our arguments, we can now declare our main command <code>/party create &lt;partyName&gt;</code>. We populate it with the arguments, and we create an entry in our <code>partyMembers</code> with the player's UUID and the name of the party that they created. Since this updates the requirements of the player, we'll have to make sure we update it (which is covered in more detail in the section about updating requirements below) - until then, I'll omit this from the code:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;party&quot;)
    .withArguments(arguments)
    .executesPlayer((player, args) -&gt; {
        
        // Get the name of the party to create
        String partyName = (String) args.get(&quot;partyName&quot;);
        
        partyMembers.put(player.getUniqueId(), partyName);
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;party&quot;)
    .withArguments(*arguments.toTypedArray())
    .executesPlayer(PlayerCommandExecutor { player, args -&gt;

        // Get the name of the party to create
        val partyName = args[&quot;partyName&quot;] as String

        partyMembers[player.uniqueId] = partyName
    })
    .register()
</code></pre>
</div>
<hr />
<p>So now we've added the ability to create a party if we're not already in it. Now we need to implement our <code>party tp &lt;player&gt;</code> command. Again, we must start by declaring our arguments:</p>
<div class="multi-pre">
<pre><code class="language-java Java">arguments = new ArrayList&lt;&gt;();
arguments.add(new LiteralArgument(&quot;tp&quot;)
    .withRequirement(sender -&gt; partyMembers.containsKey(((Player) sender).getUniqueId()))
);

arguments.add(new PlayerArgument(&quot;player&quot;)
    .replaceSafeSuggestions(SafeSuggestions.suggest(info -&gt; {
        
        // Store the list of party members to teleport to
        List&lt;Player&gt; playersToTeleportTo = new ArrayList&lt;&gt;();
        
        String partyName = partyMembers.get(((Player) info.sender()).getUniqueId());
        
        // Find the party members
        for (Entry&lt;UUID, String&gt; entry : partyMembers.entrySet()) {
            
            // Ignore yourself
            if (entry.getKey().equals(((Player) info.sender()).getUniqueId())) {
                continue;
            } else {
                // If the party member is in the same party as you
                if (entry.getValue().equals(partyName)) {
                    Player target = Bukkit.getPlayer(entry.getKey());
                    if (target.isOnline()) {
                        // Add them if they are online
                        playersToTeleportTo.add(target);
                    }
                }
            }
        }
        
        return playersToTeleportTo.toArray(new Player[0]);
    })));
</code></pre>
<pre><code class="language-kotlin Kotlin">arguments = mutableListOf&lt;Argument&lt;*&gt;&gt;()
arguments.add(LiteralArgument(&quot;tp&quot;)
    .withRequirement { partyMembers.containsKey((it as Player).uniqueId) })

arguments.add(PlayerArgument(&quot;player&quot;)
    .replaceSafeSuggestions(SafeSuggestions.suggest { info -&gt;

        // Store the list of party members to teleport to
        val playersToTeleportTo = mutableListOf&lt;Player&gt;()

        val partyName = partyMembers[(info.sender() as Player).uniqueId]

        // Find the party members
        for ((uuid, party) in partyMembers) {

            // Ignore yourself
            if (uuid == (info.sender() as Player).uniqueId) {
                continue
            } else {
                // If the party member is in the same party as you
                if (party == partyName) {
                    val target = Bukkit.getPlayer(uuid)!!
                    if (target.isOnline) {
                        // Add them if they are online
                        playersToTeleportTo.add(target)
                    }
                }
            }
        }

        playersToTeleportTo.toTypedArray()
    }))
</code></pre>
</div>
<p>Notice something here? There's some code repetition for the <code>withRequirement</code> method - this is the same predicate that we used earlier, except we remove the negation. If you are interested, you can view the section <a href="./predicatetips.html">Predicate tips</a> for a method to improve code reuse.</p>
<p>Once the arguments have been declared, we can now implement our party teleportation command:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;party&quot;)
    .withArguments(arguments)
    .executesPlayer((player, args) -&gt; {
        Player target = (Player) args.get(&quot;player&quot;);
        player.teleport(target);
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;party&quot;)
    .withArguments(arguments)
    .executesPlayer(PlayerCommandExecutor { player, args -&gt;
        val target = args[&quot;player&quot;] as Player
        player.teleport(target)
    })
    .register()
</code></pre>
</div>
<hr />
<p>What's important to note in this example is that if you spend the time to set up the arguments properly, it severely decreases the amount of code required to write your command. This makes the commands you declare easier to understand and follow and you don't end up having to put all of these checks in the body of your command executor.</p>
</div>
<hr />
<h2 id="updating-requirements"><a class="header" href="#updating-requirements">Updating requirements</a></h2>
<p>Finally, the part you've all been waiting for - how to update requirements. With the way requirements work, they need to be updated manually. To illustrate why this is the case, I'll explain using <a href="./requirements.html#example---perks-based-on-a-players-level">the example of the /repair command</a>:</p>
<p>When a player joins the game, the server tells the client the list of all commands that the client can run <em>(don't worry, this is completely normal, as declared <a href="https://wiki.vg/Protocol#Declare_Commands">here</a>)</em>. Let's say that the player has joined and has less than 30 levels.</p>
<p>When a player has less than 30 levels, they are unable to execute the <code>/repair</code> command, because the list of commands that the server sent to the client did not contain the <code>/repair</code> command. Eventually, the player will fight some mobs or mine some ores and eventually will reach 30 levels. Despite this, the player's client doesn't actually know that they're now able to use the <code>/repair</code> command until the server tells them. As such, the server needs to somehow update the requirements that a player has so a player knows they can run the command.</p>
<p>The CommandAPI handles this in a very simple method call:</p>
<pre><code class="language-java">CommandAPI.updateRequirements(player);
</code></pre>
<div class="warning">
<p><strong>Developer's Note:</strong></p>
<p>The <code>CommandAPI.updateRequirements(player);</code> method can be used anywhere, <strong>except</strong> for the <code>withRequirement</code> method. Using it inside this method will crash the server. This is by design - just make sure you don't use it within the <code>withRequirement</code> method and everything will be fine!</p>
</div>
<p>To illustrate how to use this, we'll go over the two examples above:</p>
<div class="example">
<h3 id="example---updating-requirements-for-xp-changes"><a class="header" href="#example---updating-requirements-for-xp-changes">Example - Updating requirements for xp changes</a></h3>
<p>In <a href="./requirements.html#example---perks-based-on-a-players-level">the example of requirements with the /repair command</a>, we needed to ensure that the player's requirements update when their experience changes. To do this, we'll simply use a normal event to check this:</p>
<pre><code class="language-java">@EventHandler
public void onExpChange(PlayerExpChangeEvent event) {
    CommandAPI.updateRequirements(event.getPlayer());
}
</code></pre>
<p>And of course, you have to ensure that this event is registered in your <code>onEnable()</code> method:</p>
<pre><code class="language-java">@Override
public void onEnable() {
    getServer().getPluginManager().registerEvents(this, this);
}
</code></pre>
<blockquote>
<p><strong>Developer's Note:</strong></p>
<p>I'm assuming you already know how to register events and don't need me to go into great detail how to do so, take the code above with a pinch of salt - I know how much everyone likes to divide their event handlers and listeners to organise their code.</p>
</blockquote>
</div>
<div class="example">
<h3 id="example---updating-requirements-for-the-party-creation-example"><a class="header" href="#example---updating-requirements-for-the-party-creation-example">Example - Updating requirements for the party creation example</a></h3>
<p>In the <a href="./requirements.html#example---a-party-creation-and-teleportation-system">example for a party creation</a>, we declared two commands:</p>
<pre><code class="language-mccmd">/party create &lt;partyName&gt;
/party tp &lt;player&gt;
</code></pre>
<p>When a player creates a new party, we need to ensure that their requirements are updated <em>when they create the party</em>. As such, we simply add this to our party creation command executor:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;party&quot;)
    .withArguments(arguments)
    .executesPlayer((player, args) -&gt; {
        
        // Get the name of the party to create
        String partyName = (String) args.get(&quot;partyName&quot;);
        
        partyMembers.put(player.getUniqueId(), partyName);
        
        CommandAPI.updateRequirements(player);
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;party&quot;)
    .withArguments(arguments)
    .executesPlayer(PlayerCommandExecutor { player, args -&gt;

        // Get the name of the party to create
        val partyName = args[&quot;partyName&quot;] as String

        partyMembers[player.uniqueId] = partyName

        CommandAPI.updateRequirements(player)
    })
    .register()
</code></pre>
</div>
<p>That's it!</p>
</div>
<hr />
<h2 id="multiple-requirements"><a class="header" href="#multiple-requirements">Multiple requirements</a></h2>
<p>The CommandAPI lets you handle multiple requirements really easily! The <code>withRequirement</code> method can be called multiple times, so you don't have to worry about shoving everything in one expression.</p>
<div class="example">
<h3 id="example---using-multiple-requirements"><a class="header" href="#example---using-multiple-requirements">Example - Using multiple requirements</a></h3>
<p>For example, you can apply multiple requirements for a command by calling the <code>withRequirement</code> method multiple times:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;someCommand&quot;)
    .withRequirement(sender -&gt; ((Player) sender).getLevel() &gt;= 30)
    .withRequirement(sender -&gt; ((Player) sender).getInventory().contains(Material.DIAMOND_PICKAXE))
    .withRequirement(sender -&gt; ((Player) sender).isInvulnerable())
    .executesPlayer((player, args) -&gt; {
        // Code goes here
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;someCommand&quot;)
    .withRequirement { (it as Player).level &gt;= 30 }
    .withRequirement { (it as Player).inventory.contains(Material.DIAMOND_PICKAXE) }
    .withRequirement { (it as Player).isInvulnerable() }
    .executesPlayer(PlayerCommandExecutor { player, args -&gt;
        // Code goes here
    })
    .register()
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="aliases"><a class="header" href="#aliases">Aliases</a></h1>
<p>Aliases for commands can be added by using the <code>withAliases()</code> method when registering a command. Aliases allow you to run the same command with a different 'name' from the original registered command name.</p>
<div class="example">
<h3 id="example---using-aliases-for-getpos"><a class="header" href="#example---using-aliases-for-getpos">Example - Using aliases for /getpos</a></h3>
<p>In this example, we register the command <code>/getpos</code> that returns the command sender's location. We apply the aliases <code>/getposition</code>, <code>/getloc</code>, <code>/getlocation</code> and <code>/whereami</code> as well, using the <code>withAliases()</code> method.</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;getpos&quot;)
    // Declare your aliases
    .withAliases(&quot;getposition&quot;, &quot;getloc&quot;, &quot;getlocation&quot;, &quot;whereami&quot;)
      
    // Declare your implementation
    .executesEntity((entity, args) -&gt; {
        entity.sendMessage(String.format(&quot;You are at %d, %d, %d&quot;, 
            entity.getLocation().getBlockX(), 
            entity.getLocation().getBlockY(), 
            entity.getLocation().getBlockZ())
        );
    })
    .executesCommandBlock((block, args) -&gt; {
        block.sendMessage(String.format(&quot;You are at %d, %d, %d&quot;, 
            block.getBlock().getLocation().getBlockX(), 
            block.getBlock().getLocation().getBlockY(), 
            block.getBlock().getLocation().getBlockZ())
        );
    })
      
    // Register the command
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;getpos&quot;)
    // Declare your aliases
    .withAliases(&quot;getposition&quot;, &quot;getloc&quot;, &quot;getlocation&quot;, &quot;whereami&quot;)

    // Declare your implementation
    .executesEntity(EntityCommandExecutor { entity, _ -&gt;
        val loc = entity.location
        entity.sendMessage(&quot;You are at ${loc.blockX}, ${loc.blockY}, ${loc.blockZ}&quot;)
    })
    .executesCommandBlock(CommandBlockCommandExecutor { block, _ -&gt;
        val loc = block.block.location
        block.sendMessage(&quot;You are at ${loc.blockX}, ${loc.blockY}, ${loc.blockZ}&quot;)
    })

    // Register the command
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;getpos&quot;) {
    // Declare your aliases
    withAliases(&quot;getposition&quot;, &quot;getloc&quot;, &quot;getlocation&quot;, &quot;whereami&quot;)

    // Declare your implementation
    entityExecutor { entity, _ -&gt;
        val loc = entity.location
        entity.sendMessage(&quot;You are at ${loc.blockX}, ${loc.blockY}, ${loc.blockZ}&quot;)
    }
    commandBlockExecutor { block, _ -&gt;
        val loc = block.block.location
        block.sendMessage(&quot;You are at ${loc.blockX}, ${loc.blockY}, ${loc.blockZ}&quot;)
    }
}
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="help"><a class="header" href="#help">Help</a></h1>
<p>Help topics can be added to your command using the <code>withHelp()</code>, <code>withShortDescription()</code>, <code>withFullDescription()</code> or <code>withUsage()</code> methods when registering a command. Help allows users to understand what your command does and provides them with a list of usage forms to aid in writing a command.</p>
<h2 id="parts-of-a-help"><a class="header" href="#parts-of-a-help">Parts of a help</a></h2>
<p>A help topic consists of two mains parts:</p>
<ul>
<li>A short description which is displayed in a help list and displayed at the top of a help topic for that command</li>
<li>A full description which is displayed in the &quot;Description&quot; section of a help topic</li>
</ul>
<p>This can be seen with the following example, for a command <code>/mycmd</code>. This example has the short description <em>&quot;Says hi&quot;</em>, and a full description <em>&quot;Broadcasts hi to everyone on the server&quot;</em>. The short help is shown in the help list, which (in this example) is viewed using <code>/help 5</code>. The full description is shown for the help for the command on its own, which is viewed using <code>/help mycmd</code>:</p>
<p><img src="./images/help.png" alt="help image" /></p>
<h2 id="help-methods-and-semantics"><a class="header" href="#help-methods-and-semantics">Help methods and semantics</a></h2>
<p>The CommandAPI has three methods to register parts of a help. The <code>withShortDescription()</code> sets the short description for the command, the <code>withFullDescription()</code> sets the full description for the command and <code>withHelp()</code> is a simple way to set both the short and full description at the same time. The <code>withHelp()</code> method is the recommended method to use to set the help for a command.</p>
<p>If no short description is provided, the CommandAPI will attempt to use the full description if one is present. Note that this may be truncated automatically, so it is recommended to provide your own short description.</p>
<p>These are the following methods that the CommandAPI provides to set the help topic for a command:</p>
<pre><code class="language-java">CommandAPICommand withShortDescription(String description);
</code></pre>
<p>The <code>withShortDescription</code> method simply sets the short description for the command. In the above screenshot, the short description is &quot;Says hi&quot;.</p>
<pre><code class="language-java">CommandAPICommand withFullDescription(String description);
</code></pre>
<p>The <code>withFullDescription</code> method sets the full description for the command. In the above screenshot, the full description is &quot;Broadcasts hi to everyone on the server&quot;.</p>
<pre><code class="language-java">CommandAPICommand withHelp(String shortDescription, String fullDescription);
</code></pre>
<p>The <code>withHelp</code> method sets both the short description and the full description at the same time.</p>
<div class="example">
<h3 id="example---adding-help-to-a-command"><a class="header" href="#example---adding-help-to-a-command">Example - Adding help to a command</a></h3>
<p>In this simple example, we implement the above screenshot's help topic. We register a command <code>/mycmd</code> and use the <code>withShortDescription</code> and <code>withFullDescription</code> methods to create a help topic:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;mycmd&quot;)
    .withShortDescription(&quot;Says hi&quot;)
    .withFullDescription(&quot;Broadcasts hi to everyone on the server&quot;)
    .executes((sender, args) -&gt; {
        Bukkit.broadcastMessage(&quot;Hi!&quot;);
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;mycmd&quot;)
    .withShortDescription(&quot;Says hi&quot;)
    .withFullDescription(&quot;Broadcasts hi to everyone on the server&quot;)
    .executes(CommandExecutor { _, _ -&gt;
        Bukkit.broadcastMessage(&quot;Hi!&quot;)
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;mycmd&quot;) {
    withShortDescription(&quot;Says hi&quot;)
    withFullDescription(&quot;Broadcasts hi to everyone on the server&quot;)
    anyExecutor { _, _ -&gt;
        Bukkit.broadcastMessage(&quot;Hi!&quot;)
    }
}
</code></pre>
</div>
<p>We could also register this command using the <code>withHelp</code> method instead:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;mycmd&quot;)
    .withHelp(&quot;Says hi&quot;, &quot;Broadcasts hi to everyone on the server&quot;)
    .executes((sender, args) -&gt; {
        Bukkit.broadcastMessage(&quot;Hi!&quot;);
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;mycmd&quot;)
    .withHelp(&quot;Says hi&quot;, &quot;Broadcasts hi to everyone on the server&quot;)
    .executes(CommandExecutor { _, _ -&gt;
        Bukkit.broadcastMessage(&quot;Hi!&quot;)
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;mycmd&quot;) {
    withHelp(&quot;Says hi&quot;, &quot;Broadcasts hi to everyone on the server&quot;)
    anyExecutor { _, _ -&gt;
        Bukkit.broadcastMessage(&quot;Hi!&quot;)
    }
}

</code></pre>
</div>
</div>
<h2 id="advanced-help-topics"><a class="header" href="#advanced-help-topics">Advanced help topics</a></h2>
<p>For more control over help topics, the CommandAPI offers the following method, which allows you to provide your own <code>HelpTopic</code> object:</p>
<pre><code class="language-java">CommandAPICommand withHelp(HelpTopic helpTopic);
</code></pre>
<div class="example">
<h3 id="example---adding-locale-specific-help"><a class="header" href="#example---adding-locale-specific-help">Example - Adding locale-specific help</a></h3>
<p>In this example, we implement locale-specific help so players can see help in their desired language. To do this, we must make use of the Bukkit <code>HelpTopic</code> object which gives us more control over the content of help that is displayed to a player:</p>
<div class="multi-pre">
<pre><code class="language-java Java">public HelpTopic makeHelp(String command) {
    return new HelpTopic() {

        @Override
        public String getShortText() {
            return &quot;Says hi&quot;;
        }

        @Override
        public String getFullText(CommandSender forWho) {
            String helpText = &quot;&quot;;
            if (forWho instanceof Player player) {
                // Make use of the player's locale to make language-specific help!
                Locale playerLocale = player.locale();
                if (playerLocale.getLanguage().equals(&quot;en&quot;)) {
                    helpText = &quot;Broadcasts \&quot;Hi!\&quot; to everyone on the server&quot;;
                } else if (playerLocale.getLanguage().equals(&quot;de&quot;)) {
                    helpText = &quot;Sendet \&quot;Hi!\&quot; an alle auf dem Server&quot;;
                }
            } else {
                helpText = &quot;Broadcasts \&quot;Hi!\&quot; to everyone on the server&quot;;
            }
            return helpText;
        }

        // Allow anyone to see this help topic
        @Override
        public boolean canSee(CommandSender player) {
            return true;
        }
    };
}
</code></pre>
<pre><code class="language-kotlin Kotlin">fun makeHelp(command: String): HelpTopic = object: HelpTopic() {
    override fun getShortText(): String = &quot;Says hi&quot;

    override fun getFullText(forWho: CommandSender): String {
        var helpText = &quot;&quot;
        if (forWho is Player) {
            // Make use of the player's locale to make language-specific help!
            val playerLocale = forWho.locale()
            if (playerLocale.getLanguage() == &quot;en&quot;) {
                helpText = &quot;Broadcasts \&quot;Hi!\&quot; to everyone on the server&quot;
            } else if (playerLocale.getLanguage() == &quot;de&quot;) {
                helpText = &quot;Sendet \&quot;Hi!\&quot; an alle auf dem Server&quot;
            }
        } else {
            helpText = &quot;Broadcasts \&quot;Hi!\&quot; to everyone on the server&quot;
        }
        return helpText
    }

    // Allow anyone to see this help topic
    override fun canSee(player: CommandSender): Boolean = true
}
</code></pre>
</div>
<p>We then add our new <code>HelpTopic</code> to the command using the <code>withHelp</code> method:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;mycmd&quot;)
    .withHelp(makeHelp(&quot;mycmd&quot;))
    .executes((sender, args) -&gt; {
        Bukkit.broadcastMessage(&quot;Hi!&quot;);
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">return CommandAPICommand(&quot;mycmd&quot;)
    .withHelp(makeHelp(&quot;mycmd&quot;))
    .executes(CommandExecutor { _, _ -&gt;
        Bukkit.broadcastMessage(&quot;Hi!&quot;)
    })
    .register()
</code></pre>
</div>
</div>
<h2 id="command-usage"><a class="header" href="#command-usage">Command usage</a></h2>
<p>When registering a command, there also is a command usage generated. The CommandAPI provides a way to customise this usage by providing the <code>withUsage()</code> method:</p>
<pre><code class="language-java">CommandAPICommand withUsage(String... usage)
</code></pre>
<div class="example">
<h3 id="example---providing-a-command-usage"><a class="header" href="#example---providing-a-command-usage">Example - Providing a command usage</a></h3>
<p>In this example, we want to showcase how usage generation displays the usage vs. how a custom usage displays the usage:</p>
<pre><code class="language-mccmd">/command &lt;help&gt; &lt;admin|user|moderator|vip&gt;
/command &lt;reload&gt; &lt;commandsystem|config|server&gt;
</code></pre>
<p>This is how it would get displayed:</p>
<pre><code class="language-yaml">Usage:
- /command &lt;help&gt; &lt;admin&gt;
- /command &lt;help&gt; &lt;user&gt;
- /command &lt;help&gt; &lt;moderator&gt;
- /command &lt;help&gt; &lt;vip&gt;
- /command &lt;reload&gt; &lt;commandsystem&gt;
- /command &lt;reload&gt; &lt;config&gt;
- /command &lt;reload&gt; &lt;server&gt;
</code></pre>
<p>Now, we are implementing the <code>withUsage()</code> method:</p>
<pre><code class="language-java">new CommandAPICommand(&quot;...&quot;)
    .withUsage(
        &quot;/command &lt;help&gt; &lt;section&gt;&quot;,
        &quot;/command &lt;reload&gt; &lt;system&gt;&quot;
    )
</code></pre>
<p>By using <code>withUsage()</code> like that, the CommandAPI will produce this usage:</p>
<pre><code class="language-yaml">Usage:
- /command &lt;help&gt; &lt;section&gt;
- /command &lt;reload&gt; &lt;system&gt;
</code></pre>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subcommands"><a class="header" href="#subcommands">Subcommands</a></h1>
<p>Subcommands is another method for registering commands that makes use of creating multiple different <code>CommandAPICommand</code> instances. Given a <code>CommandAPICommand</code>, we can add a subcommand by using the following method:</p>
<pre><code class="language-java">CommandAPICommand withSubcommand(CommandAPICommand subcommand);
CommandAPICommand withSubcommands(CommandAPICommand... subcommands);
</code></pre>
<p>Using subcommands has no disadvantages to using regular commands with the <code>LiteralArgument</code> or <code>MultiLiteralArgument</code>, and should be slightly more intuitive to implement if you've used other command frameworks before.</p>
<div class="example">
<h3 id="example---permission-system-with-subcommands"><a class="header" href="#example---permission-system-with-subcommands">Example - Permission system with subcommands</a></h3>
<p>Say we wanted to write a permission management system. To do this, we'll use the following command structsyntaxure:</p>
<pre><code class="language-mccmd">/perm group add &lt;permission&gt; &lt;groupName&gt;
/perm group remove &lt;permission&gt; &lt;groupName&gt;
/perm user add &lt;permission&gt; &lt;userName&gt;
/perm user remove &lt;permission&gt; &lt;userName&gt;
</code></pre>
<p>Let's start with the simplest example - the <code>/perm group ...</code> command. We have one command which is the following:</p>
<pre><code class="language-mccmd">add &lt;permission&gt; &lt;groupName&gt;
</code></pre>
<p>We can implement this by creating a <code>CommandAPICommand</code> with the command name <code>add</code>:</p>
<div class="multi-pre">
<pre><code class="language-java Java">CommandAPICommand groupAdd = new CommandAPICommand(&quot;add&quot;)
    .withArguments(new StringArgument(&quot;permission&quot;))
    .withArguments(new StringArgument(&quot;groupName&quot;))
    .executes((sender, args) -&gt; {
        // perm group add code
    });
</code></pre>
<pre><code class="language-kotlin Kotlin">val groupAdd = CommandAPICommand(&quot;add&quot;)
    .withArguments(StringArgument(&quot;permission&quot;))
    .withArguments(StringArgument(&quot;groupName&quot;))
    .executes(CommandExecutor { sender, args -&gt;
        // perm group add code
    })
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">val groupAdd = subcommand(&quot;add&quot;) {
    stringArgument(&quot;permission&quot;)
    stringArgument(&quot;groupName&quot;)
    anyExecutor { sender, args -&gt;
        // perm group add code
    }
}
</code></pre>
</div>
<p>Similarly, we have another part <code>remove &lt;permission&gt; &lt;groupName&gt;</code>. We can declare this similar to our <code>add</code> command. Once we've done that, we can now join everything up together. Here, we create a command <code>group</code> which adds the two other subcommands:</p>
<div class="multi-pre">
<pre><code class="language-java Java">CommandAPICommand groupRemove = new CommandAPICommand(&quot;remove&quot;)
    .withArguments(new StringArgument(&quot;permission&quot;))
    .withArguments(new StringArgument(&quot;groupName&quot;))
    .executes((sender, args) -&gt; {
        // perm group remove code
    });

CommandAPICommand group = new CommandAPICommand(&quot;group&quot;)
    .withSubcommand(groupAdd)
    .withSubcommand(groupRemove);
</code></pre>
<pre><code class="language-kotlin Kotlin">val groupRemove = CommandAPICommand(&quot;remove&quot;)
    .withArguments(StringArgument(&quot;permission&quot;))
    .withArguments(StringArgument(&quot;groupName&quot;))
    .executes(CommandExecutor { sender, args -&gt;
        // perm group remove code
    })

val group = CommandAPICommand(&quot;group&quot;)
    .withSubcommand(groupAdd)
    .withSubcommand(groupRemove)
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">val groupRemove = subcommand(&quot;remove&quot;) {
    stringArgument(&quot;permission&quot;)
    stringArgument(&quot;groupName&quot;)
    anyExecutor { sender, args -&gt;
        // perm group remove code
    }
}

val group = subcommand(&quot;group&quot;) {
    subcommand(groupAdd)
    subcommand(groupRemove)
}
</code></pre>
</div>
<p>Finally, we can link everything up together to the <code>perm</code> command and register the whole thing together:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;perm&quot;)
    .withSubcommand(group)
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;perm&quot;)
    .withSubcommand(group)
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;perm&quot;) {
    subcommand(group)
}
</code></pre>
</div>
<hr />
<p>Another, more intuitive method, is to shove everything in one go without creating lots of variables all over the place:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;perm&quot;)
    .withSubcommand(new CommandAPICommand(&quot;group&quot;)
        .withSubcommand(new CommandAPICommand(&quot;add&quot;)
            .withArguments(new StringArgument(&quot;permission&quot;))
            .withArguments(new StringArgument(&quot;groupName&quot;))
            .executes((sender, args) -&gt; {
                // perm group add code
            })
        )
        .withSubcommand(new CommandAPICommand(&quot;remove&quot;)
            .withArguments(new StringArgument(&quot;permission&quot;))
            .withArguments(new StringArgument(&quot;groupName&quot;))
            .executes((sender, args) -&gt; {
                // perm group remove code
            })
        )
    )
    .withSubcommand(new CommandAPICommand(&quot;user&quot;)
        .withSubcommand(new CommandAPICommand(&quot;add&quot;)
            .withArguments(new StringArgument(&quot;permission&quot;))
            .withArguments(new StringArgument(&quot;userName&quot;))
            .executes((sender, args) -&gt; {
                // perm user add code
            })
        )
        .withSubcommand(new CommandAPICommand(&quot;remove&quot;)
            .withArguments(new StringArgument(&quot;permission&quot;))
            .withArguments(new StringArgument(&quot;userName&quot;))
            .executes((sender, args) -&gt; {
                // perm user remove code
            })
        )
    )
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;perm&quot;)
    .withSubcommand(CommandAPICommand(&quot;group&quot;)
        .withSubcommand(CommandAPICommand(&quot;add&quot;)
            .withArguments(StringArgument(&quot;permission&quot;))
            .withArguments(StringArgument(&quot;groupName&quot;))
            .executes(CommandExecutor { sender, args -&gt;
                // perm group add code
            })
        )
        .withSubcommand(CommandAPICommand(&quot;remove&quot;)
            .withArguments(StringArgument(&quot;permission&quot;))
            .withArguments(StringArgument(&quot;groupName&quot;))
            .executes(CommandExecutor { sender, args -&gt;
                // perm group remove code
            })
        )
    )
    .withSubcommand(CommandAPICommand(&quot;user&quot;)
        .withSubcommand(CommandAPICommand(&quot;add&quot;)
            .withArguments(StringArgument(&quot;permission&quot;))
            .withArguments(StringArgument(&quot;userName&quot;))
            .executes(CommandExecutor { sender, args -&gt;
                // perm user add code
            })
        )
        .withSubcommand(CommandAPICommand(&quot;remove&quot;)
            .withArguments(StringArgument(&quot;permission&quot;))
            .withArguments(StringArgument(&quot;userName&quot;))
            .executes(CommandExecutor { sender, args -&gt;
                // perm user remove code
            })
        )
    )
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;perm&quot;) {
    subcommand(&quot;group&quot;) {
        subcommand(&quot;add&quot;) {
            stringArgument(&quot;permission&quot;)
            stringArgument(&quot;groupName&quot;)
            anyExecutor { sender, args -&gt;
                // perm group add code
            }
        }
        subcommand(&quot;remove&quot;) {
            stringArgument(&quot;permission&quot;)
            stringArgument(&quot;groupName&quot;)
            anyExecutor { sender, args -&gt;
                // perm group remove code
            }
        }
    }
    subcommand(&quot;user&quot;) {
        subcommand(&quot;add&quot;) {
            stringArgument(&quot;permission&quot;)
            stringArgument(&quot;userName&quot;)
            anyExecutor { sender, args -&gt;
                // perm user add code
            }
        }
        subcommand(&quot;remove&quot;) {
            stringArgument(&quot;permission&quot;)
            stringArgument(&quot;userName&quot;)
            anyExecutor { sender, args -&gt;
                // perm user add code
            }
        }
    }
}
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-trees"><a class="header" href="#command-trees">Command trees</a></h1>
<p>So far in this documentation, we've described many different ways to register commands. We've described writing commands by declaring a <code>CommandAPICommand</code> object, using a list of arguments and providing an executor for the command. We've also described another way of registering commands with multiple &quot;paths&quot; using the <code>withSubcommand</code> method to generate a tree-like structure. As of CommandAPI 7.0.0, another method for registering commands, <em>command trees</em>, has been introduced.</p>
<hr />
<h2 id="the-executes-and-then-methods"><a class="header" href="#the-executes-and-then-methods">The <code>executes()</code> and <code>then()</code> methods</a></h2>
<p>The Command Tree represents command structures in a tree-like fashion, in a very similar way that Brigadier's API lets you declare commands. Command tree commands effectively revolve around two methods:</p>
<pre><code class="language-java">public T executes(CommandExecutor executor);

public CommandTree  then(ArgumentTree branch);
public ArgumentTree then(ArgumentTree branch);
</code></pre>
<p>The <code>executes()</code> method is the same <code>executes()</code> method that you have seen previously in this documentation for normal CommandAPI commands. This also includes all of the <code>executes...()</code> methods described in <a href="./normalexecutors.html#restricting-who-can-run-your-command">Normal command executors</a>, but for the sake of simplicity, we'll simply refer to all of these by <code>executes()</code>.</p>
<p>The <code>then()</code> method allows you to create new &quot;branches&quot; in your command &quot;tree&quot; data structure. If you are familiar with <a href="https://github.com/Mojang/brigadier">Brigadier</a>'s <code>then()</code> method for argument nodes, then you should feel right at home. Otherwise, for all intents and purposes <code>then()</code> lets you specify additional paths that a command can take when a user is typing their command.</p>
<p>Because the underlying type hierarchy of command trees is fairly complex (<code>then()</code> having multiple return types and taking in <code>ArgumentTree</code> objects), instead of trying to describe how all of that works, we'll instead describe how to make command trees by using the methods <code>executes()</code> and <code>then()</code> in practice.</p>
<h2 id="declaring-a-command-tree"><a class="header" href="#declaring-a-command-tree">Declaring a command tree</a></h2>
<p>The basic syntax of a command tree is effectively identical to a normal <code>CommandAPICommand</code>, but instead you use the <code>CommandTree</code> object. For example, if we want to create a simple command which sends &quot;Hi!&quot; to a command sender, we declare the name of our command, make use of the <code>executes()</code> method, and then we use the <code>CommandTree</code> constructor instead of the <code>CommandAPICommand</code> constructor:</p>
<pre><code class="language-mccmd">/sayhi
</code></pre>
<pre><code class="language-java">new CommandAPICommand(&quot;sayhi&quot;)
    .executes((sender, args) -&gt; {
        sender.sendMessage(&quot;Hi!&quot;);
    })
    .register();
</code></pre>
<p>$$\downarrow$$</p>
<pre><code class="language-java">new CommandTree(&quot;sayhi&quot;)
    .executes((sender, args) -&gt; {
        sender.sendMessage(&quot;Hi!&quot;);
    })
    .register();
</code></pre>
<h2 id="adding-arguments-to-a-command-tree"><a class="header" href="#adding-arguments-to-a-command-tree">Adding arguments to a command tree</a></h2>
<p>Unlike the <code>CommandAPICommand</code> class, the <code>CommandTree</code> class doesn't let you add arguments using the <code>withArguments()</code> method. Instead, it makes use of the <code>then()</code> method, which allows you to provide an argument to it. This is best described with an example.</p>
<div class="example">
<h3 id="example---declaring-a-command-tree-with-a-single-argument"><a class="header" href="#example---declaring-a-command-tree-with-a-single-argument">Example - Declaring a command tree with a single argument</a></h3>
<p>Say we want to take our <code>/sayhi</code> command from above and also have an argument which lets you specify a target player. In this example, we'll have the following command syntax:</p>
<pre><code class="language-mccmd">/sayhi          - Says &quot;Hi!&quot; to the current sender
/sayhi &lt;target&gt; - Says &quot;Hi!&quot; to a target player
</code></pre>
<p>We can do this by adding a <code>PlayerArgument</code> to our command. As described above, to add this argument, we must use the <code>then()</code> method:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandTree(&quot;sayhi&quot;)
    .executes((sender, args) -&gt; {
        sender.sendMessage(&quot;Hi!&quot;);
    })
    .then(new PlayerArgument(&quot;target&quot;)
        .executes((sender, args) -&gt; {
            Player target = (Player) args.get(&quot;target&quot;);
            target.sendMessage(&quot;Hi&quot;);
        }))
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandTree(&quot;sayhi&quot;)
    .executes(CommandExecutor { sender, _ -&gt;
        sender.sendMessage(&quot;Hi!&quot;)
    })
    .then(PlayerArgument(&quot;target&quot;)
        .executes(CommandExecutor { _, args -&gt;
            val target = args[&quot;target&quot;] as Player
            target.sendMessage(&quot;Hi&quot;)
        }))
    .register()
</code></pre>
</div>
<p>In this example, we have our normal <code>/sayhi</code> command using the <code>executes()</code> method. We then add a new argument (a new &quot;branch&quot; in our &quot;tree&quot;), the <code>PlayerArgument</code>, using the <code>then()</code> method. <strong>We want to make this branch executable, so we also use the <code>executes()</code> method <em>on the argument itself</em></strong>. To register the full command tree (which includes both <code>/sayhi</code> and <code>/sayhi &lt;target&gt;</code>), we call <code>register()</code> on the <code>CommandTree</code> object.</p>
</div>
<hr />
<p>That's effectively all of the basics of command trees! We start by writing a normal command, use <code>executes()</code> to make it executable and use <code>then()</code> to add additional paths to our command. Finally, we finish up with <code>register()</code> to register our command. Below, I've included a few more examples showcasing how to design commands using command trees.</p>
<h2 id="command-tree-examples"><a class="header" href="#command-tree-examples">Command tree examples</a></h2>
<div class="example">
<h3 id="example---sign-editing-plugin"><a class="header" href="#example---sign-editing-plugin">Example - Sign editing plugin</a></h3>
<p>Say we wanted to create a plugin to let a user edit signs. We have a single command tree <code>/signedit</code>, with a number of branching paths <code>set</code>, <code>clear</code>, <code>copy</code> and <code>paste</code> which represent various operations that this command can be performed on a sign:</p>
<pre><code class="language-mccmd">/signedit set &lt;line_number&gt; &lt;text&gt; - Sets the text for a line on a sign
/signedit clear &lt;line_number&gt;      - Clears a sign's text on a specific line
/signedit copy &lt;line_number&gt;       - Copies the current text from a line on a sign
/signedit paste &lt;line_number&gt;      - Pastes the copied text onto a line on a sign
</code></pre>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandTree(&quot;signedit&quot;)
    .then(new LiteralArgument(&quot;set&quot;)
        .then(new IntegerArgument(&quot;line_number&quot;, 1, 4)
            .then(new GreedyStringArgument(&quot;text&quot;)
                .executesPlayer((player, args) -&gt; {
                    // /signedit set &lt;line_number&gt; &lt;text&gt;
                    Sign sign = getTargetSign(player);
                    int lineNumber = (int) args.get(&quot;line_number&quot;);
                    String text = (String) args.get(&quot;text&quot;);
                    sign.setLine(lineNumber - 1, text);
                    sign.update(true);
                 }))))
    .then(new LiteralArgument(&quot;clear&quot;)
        .then(new IntegerArgument(&quot;line_number&quot;, 1, 4)
            .executesPlayer((player, args) -&gt; {
                // /signedit clear &lt;line_number&gt;
                Sign sign = getTargetSign(player);
                int lineNumber = (int) args.get(&quot;line_number&quot;);
                sign.setLine(lineNumber - 1, &quot;&quot;);
                sign.update(true);
            })))
    .then(new LiteralArgument(&quot;copy&quot;)
        .then(new IntegerArgument(&quot;line_number&quot;, 1, 4)
            .executesPlayer((player, args) -&gt; {
                // /signedit copy &lt;line_number&gt;
                Sign sign = getTargetSign(player);
                int lineNumber = (int) args.get(&quot;line_number&quot;);
                player.setMetadata(&quot;copied_sign_text&quot;, new FixedMetadataValue(this, sign.getLine(lineNumber - 1)));
            })))
    .then(new LiteralArgument(&quot;paste&quot;)
        .then(new IntegerArgument(&quot;line_number&quot;, 1, 4)
            .executesPlayer((player, args) -&gt; {
                // /signedit copy &lt;line_number&gt;
                Sign sign = getTargetSign(player);
                int lineNumber = (int) args.get(&quot;line_number&quot;);
                sign.setLine(lineNumber - 1, player.getMetadata(&quot;copied_sign_text&quot;).get(0).asString());
                sign.update(true);
            })))
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandTree(&quot;signedit&quot;)
    .then(LiteralArgument(&quot;set&quot;)
        .then(IntegerArgument(&quot;line_number&quot;, 1, 4)
            .then(GreedyStringArgument(&quot;text&quot;)
                .executesPlayer(PlayerCommandExecutor { player, args -&gt;
                    // /signedit set &lt;line_number&gt; &lt;text&gt;
                    val sign: Sign = getTargetSign(player)
                    val line_number = args[&quot;line_number&quot;] as Int
                    val text = args[&quot;text&quot;] as String
                    sign.setLine(line_number - 1, text)
                    sign.update(true)
                 }))))
    .then(LiteralArgument(&quot;clear&quot;)
        .then(IntegerArgument(&quot;line_number&quot;, 1, 4)
            .executesPlayer(PlayerCommandExecutor { player, args -&gt;
                // /signedit clear &lt;line_number&gt;
                val sign: Sign = getTargetSign(player)
                val line_number = args[&quot;line_number&quot;] as Int
                sign.setLine(line_number - 1, &quot;&quot;)
                sign.update(true)
            })))
    .then(LiteralArgument(&quot;copy&quot;)
        .then(IntegerArgument(&quot;line_number&quot;, 1, 4)
            .executesPlayer(PlayerCommandExecutor { player, args -&gt;
                // /signedit copy &lt;line_number&gt;
                val sign: Sign = getTargetSign(player)
                val line_number = args[&quot;line_number&quot;] as Int
                player.setMetadata(&quot;copied_sign_text&quot;, FixedMetadataValue(this, sign.getLine(line_number - 1)))
            })))
    .then(LiteralArgument(&quot;paste&quot;)
        .then(IntegerArgument(&quot;line_number&quot;, 1, 4)
            .executesPlayer(PlayerCommandExecutor { player, args -&gt;
                // /signedit copy &lt;line_number&gt;
                val sign: Sign = getTargetSign(player)
                val line_number = args[&quot;line_number&quot;] as Int
                sign.setLine(line_number - 1, player.getMetadata(&quot;copied_sign_text&quot;)[0].asString())
                sign.update(true)
            })))
    .register()
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="annotation-based-commands"><a class="header" href="#annotation-based-commands">Annotation-based commands</a></h1>
<p>The CommandAPI also includes a very small lightweight annotation-based command framework. This works very differently compared to previous commands shown in this documentation and <strong>it is less feature-rich than registering commands using the other methods.</strong></p>
<p>In short, the CommandAPI's annotation-based system:</p>
<ul>
<li>Has no runtime overhead compared to using the regular command registration system (unlike other annotation-based frameworks such as <a href="https://github.com/aikar/commands">ACF</a>).</li>
<li>Reduces code bloat (to an extent).</li>
<li>Improves readability since commands are declared declaratively instead of imperatively.</li>
<li>Is not as powerful as the regular command registration system.</li>
</ul>
<blockquote>
<p><strong>Developer's Note:</strong></p>
<p>Currently, the annotation framework is in its infancy, so any suggestions or improvements are heavily appreciated!</p>
</blockquote>
<div class="warning">
<p><strong>Developer's Note:</strong></p>
<p>As of the time of writing, annotation-based commands are <strong>not</strong> compatible with the Kotlin programming language! The CommandAPI does have the <a href="./kotlinintro.html">Kotlin DSL</a> instead, which is leaner, cleaner and provides a much more Kotliny experience!</p>
</div>
<p>Before we go into too much detail, let's take a look at an example of what this annotation framework looks like, and compare this to the existing method.</p>
<hr />
<h2 id="example-a-warp-command"><a class="header" href="#example-a-warp-command">Example: A warp command</a></h2>
<p>Let's say we're writing a plugin with the capability to create warps to places on the server. To do this, we'll make a simple command <code>/warp</code>, defined as follows:</p>
<pre><code class="language-mccmd">/warp - Shows help
/warp &lt;warp&gt; - Teleports a player to &lt;warp&gt;
/warp create &lt;name&gt; - Creates a new warp &lt;name&gt; at the player's location
</code></pre>
<h3 id="warp-command-without-annotations"><a class="header" href="#warp-command-without-annotations">Warp command (without annotations)</a></h3>
<p>Using the regular CommandAPI, this is one way we can create this command. In the code below, we use StringArguments to represent the warp names. To teleport to a warp, we also populate it with suggestions (deferred so it updates), and also use a subcommand to represent <code>/warp create</code>:</p>
<pre><code class="language-java">Map&lt;String, Location&gt; warps = new HashMap&lt;&gt;();

// /warp
new CommandAPICommand(&quot;warp&quot;)
    .executes((sender, args) -&gt; {
        sender.sendMessage(&quot;--- Warp help ---&quot;);
        sender.sendMessage(&quot;/warp - Show this help&quot;);
        sender.sendMessage(&quot;/warp &lt;warp&gt; - Teleport to &lt;warp&gt;&quot;);
        sender.sendMessage(&quot;/warp create &lt;warpname&gt; - Creates a warp at your current location&quot;);
    })
    .register();

// /warp &lt;warp&gt;
new CommandAPICommand(&quot;warp&quot;)
    .withArguments(new StringArgument(&quot;warp&quot;).replaceSuggestions(ArgumentSuggestions.strings(info -&gt; 
        warps.keySet().toArray(new String[0])
    )))
    .executesPlayer((player, args) -&gt; {
        player.teleport(warps.get((String) args.get(0)));
    })
    .register();

// /warp create &lt;warpname&gt;
new CommandAPICommand(&quot;warp&quot;)
    .withSubcommand(
        new CommandAPICommand(&quot;create&quot;)
            .withPermission(&quot;warps.create&quot;)
            .withArguments(new StringArgument(&quot;warpname&quot;))
            .executesPlayer((player, args) -&gt; {
                warps.put((String) args.get(0), player.getLocation());
            })
    )
    .register();
</code></pre>
<p>Seems fairly straightforward, given everything else covered in this documentation. Now let's compare it to using annotations!</p>
<h3 id="warp-command-with-annotations"><a class="header" href="#warp-command-with-annotations">Warp command (with annotations)</a></h3>
<p>I think it's best to show the example and the explain it afterwards:</p>
<pre><code class="language-java">@Command(&quot;warp&quot;)    
public class WarpCommand {
    
    // List of warp names and their locations
    static Map&lt;String, Location&gt; warps = new HashMap&lt;&gt;();
    
    @Default
    public static void warp(CommandSender sender) {
        sender.sendMessage(&quot;--- Warp help ---&quot;);
        sender.sendMessage(&quot;/warp - Show this help&quot;);
        sender.sendMessage(&quot;/warp &lt;warp&gt; - Teleport to &lt;warp&gt;&quot;);
        sender.sendMessage(&quot;/warp create &lt;warpname&gt; - Creates a warp at your current location&quot;);
    }
    
    @Default
    public static void warp(Player player, @AStringArgument String warpName) {
        player.teleport(warps.get(warpName));
    }
    
    @Subcommand(&quot;create&quot;)
    @Permission(&quot;warps.create&quot;)
    public static void createWarp(Player player, @AStringArgument String warpName) {
        warps.put(warpName, player.getLocation());
    }
    
}
</code></pre>
<pre><code class="language-java">CommandAPI.registerCommand(WarpCommand.class);
</code></pre>
<p>As we can see, the code certainly <em>looks</em> very different to the normal registration method. Let's take it apart piece by piece to see what exactly is going on here.</p>
<h4 id="command-declaration"><a class="header" href="#command-declaration">Command declaration</a></h4>
<pre><code class="language-java">@Command(&quot;warp&quot;)    
public class WarpCommand {
</code></pre>
<p>Firstly, we declare our command <code>warp</code>. To do this, we use the <code>@Command</code> annotation and simply state the name of the command in the annotation. This annotation is attached to the class <code>WarpCommand</code>, which indicates that the whole class <code>WarpCommand</code> will be housing our command.</p>
<p>The annotation framework is designed in such a way that an entire command is represented by a single class. This provides a more modular approach to command declaration that allows you to easily contain the methods of a command in one location.</p>
<h4 id="default-command"><a class="header" href="#default-command">Default command</a></h4>
<pre><code class="language-java">@Default
public static void warp(CommandSender sender) {
    sender.sendMessage(&quot;--- Warp help ---&quot;);
    sender.sendMessage(&quot;/warp - Show this help&quot;);
    sender.sendMessage(&quot;/warp &lt;warp&gt; - Teleport to &lt;warp&gt;&quot;);
    sender.sendMessage(&quot;/warp create &lt;warpname&gt; - Creates a warp at your current location&quot;);
}
</code></pre>
<p>Here, declare the main command implementation using the <code>@Default</code> annotation. The <code>@Default</code> annotation informs the CommandAPI that the method it is attached to does not have any subcommands. This is effectively the same as registering a regular command without using <code>.withSubcommand()</code>.</p>
<p>Here, we simply write what happens when no arguments are run (i.e. the user just runs <code>/warp</code> on its own). As such, we don't include any parameters to our method.</p>
<h4 id="default-command-again"><a class="header" href="#default-command-again">Default command (again!)</a></h4>
<pre><code class="language-java">@Default
public static void warp(Player player, @AStringArgument String warpName) {
    player.teleport(warps.get(warpName));
}
</code></pre>
<p>We also have a second <code>@Default</code> annotated method, which handles our <code>/warp &lt;warp&gt;</code> command. Because this isn't a subcommand (the warp to teleport to is not a subcommand, it's an argument), we still using the <code>@Default</code> annotation. In this method, we include an argument with this command by using the <code>@AStringArgument</code> annotation. This argument uses the <code>StringArgument</code> class, and the name of this argument is &quot;warpName&quot;, which is extracted from the name of the variable. Simply put, <strong>the Annotation for an argument is A</strong> followed by the name of the argument. This is synonymous with using the following:</p>
<pre><code class="language-java">new StringArgument(&quot;warp&quot;)
</code></pre>
<p>It's also very important to note the parameters for this method. The first parameter is a <code>Player</code> object, which represents our command sender. The CommandAPI's annotation system uses the fact that the command sender is a <code>Player</code> object and automatically ensures that anyone using the command must be a <code>Player</code>. In other words, non-players (such as the console or command blocks), would be unable to execute this command.</p>
<p>The second argument is a <code>String</code> object, which represents the result of our argument &quot;warp&quot;. The CommandAPI's annotation system can also infer the return type of the argument that is provided to it (in this case, a <code>StringArgument</code> will produce a <code>String</code>) and will automatically cast and provide the result to that parameter.</p>
<h4 id="subcommand"><a class="header" href="#subcommand">Subcommand</a></h4>
<pre><code class="language-java">@Subcommand(&quot;create&quot;)
@Permission(&quot;warps.create&quot;)
public static void createWarp(Player player, @AStringArgument String warpName) {
    warps.put(warpName, player.getLocation());
}
</code></pre>
<p>Lastly, we declare a subcommand to allow us to run <code>/warp create &lt;name&gt;</code>. To do this, we simply use the <code>@Subcommand</code> annotation. In this example, we also apply a permission node that is required to run the command by using the <code>@Permission</code> annotation. The rest is fairly straight forward - we declare an argument, in this case it's another <code>StringArgument</code> , so we use <code>@AStringArgument</code> and then declare everything else in a similar fashion to the default command executor.</p>
<h4 id="registering-the-command-1"><a class="header" href="#registering-the-command-1">Registering the command</a></h4>
<p>Registering the command is fairly simple and is a one liner:</p>
<pre><code class="language-java">CommandAPI.registerCommand(WarpCommand.class);
</code></pre>
<p>This line can be placed in your <code>onEnable()</code> or <code>onLoad()</code> method like you were registering a normal command.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="annotations"><a class="header" href="#annotations">Annotations</a></h1>
<p>This page outlines in detail the list of all annotations that the CommandAPI's annotation-based command system includes.</p>
<hr />
<h2 id="annotations-that-go-on-classes"><a class="header" href="#annotations-that-go-on-classes">Annotations that go on classes</a></h2>
<h3 id="commandcommandname"><a class="header" href="#commandcommandname"><code>@Command</code>(&quot;commandName&quot;)</a></h3>
<p>The <code>@Command</code> annotation is used to declare a command. The parameter is the name of the command that will be registered.</p>
<pre><code class="language-java">@Command(&quot;warp&quot;)    
public class WarpCommand {
</code></pre>
<h3 id="alias"><a class="header" href="#alias"><code>@Alias({...})</code></a></h3>
<p>The <code>@Alias</code> annotation is used to declare a list of aliases for a command. The parameter is a list of aliases which can be used for the command.</p>
<pre><code class="language-java">@Command(&quot;teleport&quot;)    
@Alias({&quot;tp&quot;, &quot;tele&quot;})
public class TeleportCommand {
</code></pre>
<h3 id="permissionpermissionnode"><a class="header" href="#permissionpermissionnode"><code>@Permission(&quot;permissionNode&quot;)</code></a></h3>
<p>The <code>@Permission</code> annotation is used to add a permission node to a command. Users that want to run this command must have this permission. The parameter is the permission node required to run the command.</p>
<pre><code class="language-java">@Command(&quot;teleport&quot;)    
@Permission(&quot;myplugin.tp&quot;)
class TeleportCommand {
</code></pre>
<h3 id="needsop"><a class="header" href="#needsop"><code>@NeedsOp</code></a></h3>
<p>The <code>@NeedsOp</code> annotation is used to indicate that a command needs to have operator privileges to run it. This annotation has no parameters.</p>
<pre><code class="language-java">@Command(&quot;teleport&quot;)    
@NeedsOp
class TeleportCommand {
</code></pre>
<h3 id="helpfull-description"><a class="header" href="#helpfull-description"><code>@Help(&quot;Full description&quot;)</code></a></h3>
<p>The <code>@Help</code> annotation is used to add a help topic to a command. This annotation can take two forms:</p>
<p>A simple form which just uses a string which is used as the full description for a command:</p>
<pre><code class="language-java">@Command(&quot;teleport&quot;)
@Help(&quot;Teleports yourself to another location&quot;)
class TeleportCommand {
</code></pre>
<p>A form with two parameters <code>value</code> and <code>shortDescription</code>, to provide the full description (<code>value</code>) and short description (<code>shortDescription</code>) content for a command:</p>
<pre><code class="language-java">@Command(&quot;teleport&quot;)    
@Help(value = &quot;Teleports yourself to another location&quot;, shortDescription = &quot;TP to a location&quot;)
class TeleportCommand {
</code></pre>
<hr />
<h2 id="annotations-that-go-on-methods"><a class="header" href="#annotations-that-go-on-methods">Annotations that go on methods</a></h2>
<p>To use annotations on methods, <strong>methods must be static</strong>.</p>
<h3 id="default"><a class="header" href="#default"><code>@Default</code></a></h3>
<p>The <code>@Default</code> annotation indicates that the method is <em>not</em> a subcommand. This acts in a similar way to regular Bukkit commands. Commands with the <code>@Default</code> annotation can be used to run the main code when the command named with the <code>@Command</code> annotation is stated, such as the following:</p>
<pre><code class="language-java">@Default
public static void warp(CommandSender sender) {
    sender.sendMessage(&quot;--- Warp help ---&quot;);
    sender.sendMessage(&quot;/warp - Show this help&quot;);
    sender.sendMessage(&quot;/warp &lt;warp&gt; - Teleport to &lt;warp&gt;&quot;);
    sender.sendMessage(&quot;/warp create &lt;warpname&gt; - Creates a warp at your current location&quot;);
}
</code></pre>
<p>The <code>@Default</code> annotation does not mean that the command can't have arguments! Arguments can still be used and declared as shown:</p>
<pre><code class="language-java">@Default
public static void warp(Player player, @AStringArgument String warpName) {
    player.teleport(warps.get(warpName));
}
</code></pre>
<h3 id="subcommand-1"><a class="header" href="#subcommand-1"><code>@Subcommand</code></a></h3>
<p>The <code>@Subcommand</code> simply tells the CommandAPI that the declared method is a subcommand. This acts in a similar way to the regular CommandAPI's <code>.withSubcommand()</code> method. The subcommand annotation can take in a single string which is the name of the subcommand:</p>
<pre><code class="language-java">@Subcommand(&quot;create&quot;)
@Permission(&quot;warps.create&quot;)
public static void createWarp(Player player, @AStringArgument String warpName) {
    warps.put(warpName, player.getLocation());
}
</code></pre>
<p>Or, it can take in a list of strings which represent the <em>aliases</em> that can also be used for the declared subcommand:</p>
<pre><code class="language-java">@Subcommand({&quot;teleport&quot;, &quot;tp&quot;})
public static void teleport(Player player, @APlayerArgument OfflinePlayer target) {
    if(target.isOnline() &amp;&amp; target instanceof Player onlineTarget) {
        player.teleport(onlineTarget);
    }
}
</code></pre>
<h3 id="permission"><a class="header" href="#permission"><code>@Permission</code></a></h3>
<p>The <code>@Permission</code> annotation can also be used on methods to indicate that a permission is required to execute a command.</p>
<pre><code class="language-java">@Subcommand(&quot;create&quot;)
@Permission(&quot;warps.create&quot;)
public static void createWarp(Player player, @AStringArgument String warpName) {
    warps.put(warpName, player.getLocation());
}
</code></pre>
<h3 id="needsop-1"><a class="header" href="#needsop-1"><code>@NeedsOp</code></a></h3>
<p>The <code>@NeedsOp</code> annotation can also be used on methods to indicate that the user must be an operator to run the command.</p>
<hr />
<h2 id="annotations-that-go-on-parameters"><a class="header" href="#annotations-that-go-on-parameters">Annotations that go on parameters</a></h2>
<p>The annotations for arguments are really simple, there's just two things you need to know:</p>
<ul>
<li>
<p>To use an annotation argument, just add the letter <code>A</code> (for 'annotation') at the beginning of it! For example:</p>
<p>\begin{align}
\texttt{StringArgument}&amp;\xrightarrow{A}\texttt{@AStringArgument}\\
\texttt{PlayerArgument}&amp;\xrightarrow{A}\texttt{@APlayerArgument}\\
\texttt{AdvancementArgument}&amp;\xrightarrow{A}\texttt{@AAdvancementArgument}\\
&amp;\hspace{0.75em}\vdots
\end{align}</p>
<p>For example, we use <code>@AStringArgument</code> to indicate that this command takes a <code>StringArgument</code> as its first parameter:</p>
</li>
</ul>
<pre><code class="language-java">@Default
public static void warp(Player player, @AStringArgument String warpName) {
    player.teleport(warps.get(warpName));
}
</code></pre>
<ul>
<li><strong>The name of the argument (referred to as &quot;nodeName&quot; in the normal CommandAPI system) is the name of the variable assigned to the parameter.</strong> In the above code, this means that the name of the argument is <code>warpName</code>.</li>
</ul>
<h3 id="special-argument-annotations"><a class="header" href="#special-argument-annotations">Special argument annotations</a></h3>
<p>Certain argument annotations have extra parameters that can be supplied to provide additional customization:</p>
<h4 id="numerical-arguments-1"><a class="header" href="#numerical-arguments-1">Numerical arguments</a></h4>
<p>The following numerical arguments can take both a <code>min</code> and <code>max</code> value. Both of these are completely optional. This indicates the range of values (inclusive) that is valid for this argument. For example:</p>
<pre><code class="language-java">@Default
public static void command(CommandSender sender, 
    @ADoubleArgument(min = 0.0, max = 10.0) double someDouble,
    @AFloatArgument(min = 5.0f, max = 10.0f) float someFloat,
    @AIntegerArgument(max = 100) int someInt,
    @ALongArgument(min = -10) long someLong
) {
    // Command implementation here
}
</code></pre>
<h4 id="literal-arguments-3"><a class="header" href="#literal-arguments-3">Literal arguments</a></h4>
<p>Both the <code>LiteralArgument</code> and <code>MultiLiteralArgument</code> can be used. When these are used, the name of the variable assigned to the parameter is <em>ignored</em> and not used as the argument's name.</p>
<p>For the <code>@ALiteralArgument</code> annotation, the parameter is the literal to be used for the command. For the <code>@AMultiLiteralArgument</code>, the parameter can be an array of multiple literals to use:</p>
<pre><code class="language-java">@Default
public static void command(CommandSender sender, 
    @ALiteralArgument(&quot;myliteral&quot;) String literal,
    @AMultiLiteralArgument({&quot;literal&quot;, &quot;anotherliteral&quot;}) String multipleLiterals
) {
    // Command implementation here
}
</code></pre>
<h4 id="other-arguments"><a class="header" href="#other-arguments">Other arguments</a></h4>
<p>The <code>LocationArgument</code>, <code>Location2DArgument</code>, <code>EntitySelectorArgument</code> and <code>ScoreHolderArgument</code> can all take an extra parameter in their constructors. As a result, the annotation-equivalent of these arguments also allow you to provide the parameter in the annotation:</p>
<pre><code class="language-java">@Default
public static void command(CommandSender sender, 
    @ALocationArgument(LocationType.BLOCK_POSITION) Location location,
    @ALocation2DArgument(LocationType.PRECISE_POSITION) Location location2d,
    @AEntitySelectorArgument.ManyEntities Collection&lt;Entity&gt; entities,
    @AScoreHolderArgument.Multiple Collection&lt;String&gt; scoreHolders
) {
    // Command implementation here
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="registering-annotation-based-commands"><a class="header" href="#registering-annotation-based-commands">Registering annotation-based commands</a></h1>
<p>Registering annotation-based commands is <em>really</em> simple. To do this, we use the following method, where <code>className</code> is the name of a class with a <code>@Command</code> annotation:</p>
<pre><code class="language-java">CommandAPI.registerCommand(className)
</code></pre>
<div class="example">
<h3 id="example-registering-a-warp-command"><a class="header" href="#example-registering-a-warp-command">Example: Registering a Warp command</a></h3>
<p>Say we have a simple command <code>/warp</code> that is defined as follows:</p>
<pre><code class="language-java">@Command(&quot;warp&quot;)    
public class WarpCommand {
    
    // List of warp names and their locations
    static Map&lt;String, Location&gt; warps = new HashMap&lt;&gt;();
    
    @Default
    public static void warp(CommandSender sender) {
        sender.sendMessage(&quot;--- Warp help ---&quot;);
        sender.sendMessage(&quot;/warp - Show this help&quot;);
        sender.sendMessage(&quot;/warp &lt;warp&gt; - Teleport to &lt;warp&gt;&quot;);
        sender.sendMessage(&quot;/warp create &lt;warpname&gt; - Creates a warp at your current location&quot;);
    }
    
    @Default
    public static void warp(Player player, @AStringArgument String warpName) {
        player.teleport(warps.get(warpName));
    }
    
    @Subcommand(&quot;create&quot;)
    @Permission(&quot;warps.create&quot;)
    public static void createWarp(Player player, @AStringArgument String warpName) {
        warps.put(warpName, player.getLocation());
    }
    
}
</code></pre>
<p>We can register this in our <code>onLoad()</code> method so we can use this command from within Minecraft functions:</p>
<pre><code class="language-java">public class MyPlugin extends JavaPlugin {
    
    @Override
    public void onLoad() {
        CommandAPI.registerCommand(WarpCommand.class);
    }
    
}
</code></pre>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="kotlin-based-commands"><a class="header" href="#kotlin-based-commands">Kotlin-based commands</a></h1>
<p>The CommandAPI also provides an alternative way of making commands when using Kotlin to develop your plugins: A DSL!</p>
<p>This DSL provides many methods to easily add arguments to your command structure. Examples of the DSL can be found <a href="./kotlindsl.html">here</a>.</p>
<hr />
<h2 id="installing-the-dsl"><a class="header" href="#installing-the-dsl">Installing the DSL</a></h2>
<p>To install the DSL, you need to add the <code>commandapi-bukkit-kotlin</code> dependency into your <code>pom.xml</code> or your <code>build.gradle</code>, making sure to specify the server flavor you are developing for:</p>
<h3 id="adding-the-dependency-with-maven"><a class="header" href="#adding-the-dependency-with-maven">Adding the dependency with Maven</a></h3>
<pre><code class="language-xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;dev.jorel&lt;/groupId&gt;
        &lt;artifactId&gt;commandapi-bukkit-kotlin&lt;/artifactId&gt;
        &lt;version&gt;9.6.0&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>Next, you need to add Kotlin to your project. For this, you first need to add the dependency:</p>
<pre><code class="language-xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;
        &lt;artifactId&gt;kotlin-stdlib&lt;/artifactId&gt;
        &lt;version&gt;1.9.0&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>Finally, you need to add the <code>kotlin-maven-plugin</code>:</p>
<pre><code class="language-xml">&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;
            &lt;artifactId&gt;kotlin-maven-plugin&lt;/artifactId&gt;
            &lt;version&gt;1.9.0&lt;/version&gt;
            &lt;executions&gt;
                &lt;execution&gt;
                    &lt;id&gt;compile&lt;/id&gt;
                    &lt;phase&gt;compile&lt;/phase&gt;
                    &lt;goals&gt;
                        &lt;goal&gt;compile&lt;/goal&gt;
                    &lt;/goals&gt;
                &lt;/execution&gt;
                &lt;execution&gt;
                    &lt;id&gt;test-compile&lt;/id&gt;
                    &lt;phase&gt;test-compile&lt;/phase&gt;
                    &lt;goals&gt;
                        &lt;goal&gt;test-compile&lt;/goal&gt;
                    &lt;/goals&gt;
                &lt;/execution&gt;
            &lt;/executions&gt;
            &lt;configuration&gt;
                &lt;jvmTarget&gt;16&lt;/jvmTarget&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>
<h3 id="adding-the-dependency-with-gradle"><a class="header" href="#adding-the-dependency-with-gradle">Adding the dependency with Gradle</a></h3>
<p>First, you need to add the repository:</p>
<div class="multi-pre">
<pre><code class="language-groovy build.gradle">repositories {
    mavenCentral()
}
</code></pre>
<pre><code class="language-kotlin build.gradle.kts">repositories {
    mavenCentral()
}
</code></pre>
</div>
<p>Next, you need to add the dependency:</p>
<div class="multi-pre">
<pre><code class="language-groovy build.gradle">dependencies {
    implementation &quot;dev.jorel:commandapi-bukkit-kotlin:9.6.0&quot;
}
</code></pre>
<pre><code class="language-kotlin build.gradle.kts">dependencies {
    implementation(&quot;dev.jorel:commandapi-bukkit-kotlin:9.6.0&quot;)
}
</code></pre>
</div>
<p>You also need to add Kotlin to your project. For this, you first need to add the Kotlin plugin:</p>
<div class="multi-pre">
<pre><code class="language-groovy build.gradle">plugins {
    id &quot;org.jetbrains.kotlin.jvm&quot; version &quot;1.9.0&quot;
}
</code></pre>
<pre><code class="language-kotlin build.gradle.kts">plugins {
    kotlin(&quot;jvm&quot;) version &quot;1.9.0&quot;
}
</code></pre>
</div>
<p>Next, you need to add the dependency (you should already have added the <code>mavenCentral()</code> repository to your project):</p>
<div class="multi-pre">
<pre><code class="language-groovy build.gradle">dependencies {
    implementation &quot;org.jetbrains.kotlin:kotlin-stdlib&quot;
}
</code></pre>
<pre><code class="language-kotlin build.gradle.kts">dependencies {
    implementation(&quot;org.jetbrains.kotlin:kotlin-stdlib&quot;)
}
</code></pre>
</div>
<p>Then, you need to configure the Java version to build against:</p>
<div class="multi-pre">
<pre><code class="language-groovy build.gradle">kotlin {
    jvmToolchain(16)
}
</code></pre>
<pre><code class="language-kotlin build.gradle.kts">kotlin {
    jvmToolchain(16)
}
</code></pre>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-the-dsl"><a class="header" href="#using-the-dsl">Using the DSL</a></h1>
<h2 id="defining-a-simple-message-command"><a class="header" href="#defining-a-simple-message-command">Defining a simple message command</a></h2>
<p>As a first example and to take a first look at the Kotlin DSL syntax, we will first create a simple command to send messages to a player.</p>
<div class="example">
<h3 id="example---sending-a-message-to-a-player-using-the-kotlin-dsl"><a class="header" href="#example---sending-a-message-to-a-player-using-the-kotlin-dsl">Example - Sending a message to a player using the Kotlin DSL</a></h3>
<p>We want to create a command that lets us send a message to a player. To do this, we want to register a command with the following syntax:</p>
<pre><code class="language-mccmd">/sendmessageto &lt;player&gt; &lt;msg&gt;
</code></pre>
<p>We can then use the following command registration:</p>
<div class="multi-pre">
<pre><code class="language-kotlin CommandTree">commandTree(&quot;sendmessageto&quot;) {
    playerArgument(&quot;player&quot;) { // Defines a new PlayerArgument(&quot;player&quot;)
        greedyStringArgument(&quot;msg&quot;) { // Defines a new GreedyStringArgument(&quot;msg&quot;)
            anyExecutor { _, args -&gt; // Command can be executed by anyone and anything (such as entities, the console, etc.)
                val player: Player = args[&quot;player&quot;] as Player
                val message: String = args[&quot;msg&quot;] as String
                player.sendMessage(message)
            }
        }
    }
}
</code></pre>
<pre><code class="language-kotlin CommandAPICommand">commandAPICommand(&quot;sendmessageto&quot;) {
    playerArgument(&quot;player&quot;) // Defines a new PlayerArgument(&quot;player&quot;)
    greedyStringArgument(&quot;msg&quot;) // Defines a new GreedyStringArgument(&quot;msg&quot;)
    anyExecutor { _, args -&gt; // Command can be executed by anyone and anything (such as entities, the console, etc.)
        val player: Player = args[&quot;player&quot;] as Player
        val message: String = args[&quot;msg&quot;] as String
        player.sendMessage(message)
    }
}
</code></pre>
</div>
<p>Here you can see some interesting things:</p>
<ul>
<li>You do not need to call the <code>.register()</code> method when using the DSL</li>
<li>You do not need to initialise any arguments</li>
</ul>
</div>
<hr />
<h2 id="executors"><a class="header" href="#executors">Executors</a></h2>
<p>The Kotlin DSL also provides executors to execute your command. You've seen the <code>anyExecutor</code> in the example above.</p>
<p>To find out, which DSL executor corresponds to &quot;normal&quot; executors, you can refer to the table below:</p>
<div class="table-wrapper"><table><thead><tr><th>DSL normal executor</th><th>DSL resulting executor</th><th>DSL normal execution info</th><th>DSL resulting execution info</th><th>&quot;normal&quot; Executor</th></tr></thead><tbody>
<tr><td><code>anyExecutor()</code></td><td><code>anyResultingExecutor()</code></td><td><code>anyExecutionInfo()</code></td><td><code>anyResultingExecutionInfo</code></td><td><code>executes()</code></td></tr>
<tr><td><code>playerExecutor()</code></td><td><code>playerResultingExecutor()</code></td><td><code>playerExecutionInfo()</code></td><td><code>playerResultingExecutionInfo()</code></td><td><code>executesPlayer()</code></td></tr>
<tr><td><code>entityExecutor()</code></td><td><code>entityResultingExecutor()</code></td><td><code>entityExecutionInfo()</code></td><td><code>entityResultingExecutionInfo()</code></td><td><code>executesEntity()</code></td></tr>
<tr><td><code>consoleExecutor()</code></td><td><code>consoleResultingExecutor()</code></td><td><code>consoleExecutionInfo()</code></td><td><code>consoleResultingExecutionInfo()</code></td><td><code>executesConsole()</code></td></tr>
<tr><td><code>commandBlockExecutor()</code></td><td><code>commandBlockResultingExecutor()</code></td><td><code>commandBlockExecutionInfo()</code></td><td><code>commandBlockResultingExecutionInfo()</code></td><td><code>executesCommandBlock()</code></td></tr>
<tr><td><code>proxyExecutor()</code></td><td><code>proxyResultingExecutor()</code></td><td><code>proxyExecutionInfo()</code></td><td><code>proxyResultingExecutionInfo()</code></td><td><code>executesProxy()</code></td></tr>
<tr><td><code>nativeExecutor()</code></td><td><code>nativeResultingExecutor()</code></td><td><code>nativeExecutionInfo()</code></td><td><code>nativeResultingExecutionInfo()</code></td><td><code>executesNative()</code></td></tr>
<tr><td><code>remoteConsoleExecutor()</code></td><td><code>remoteConsoleResultingExecutor()</code></td><td><code>remoteConsoleExecutionInfo()</code></td><td><code>remoteConsoleResultingExecutionInfo()</code></td><td><code>executesRemoteConsole()</code></td></tr>
</tbody></table>
</div>
<hr />
<h2 id="arguments-1"><a class="header" href="#arguments-1">Arguments</a></h2>
<p>The DSL implements almost every argument with a method. You've seen the <code>playerArgument()</code> and the <code>greedyStringArgument()</code> method in the example at the top of this page.</p>
<p>The way arguments are implemented is pretty straight forward: It's basically the argument class' name, but as a method. So if you wanted to use a <code>ItemStackArgument</code> in your command, you would use the <code>itemStackArgument()</code> method of the DSL.</p>
<p>One thing to note is that the DSL also features every existing constructor. This means if you want to use an <code>IntegerArgument</code> with a minimum of <code>0</code> and a maximum of <code>10</code>, you normally would implement it like this:</p>
<pre><code class="language-java">new IntegerArgument(&quot;integer&quot;, 0, 10)
</code></pre>
<p>However, when using this DSL it is implemented like this:</p>
<pre><code class="language-kotlin">integerArgument(&quot;integer&quot;, 0, 10)
</code></pre>
<div class="warning">
<p><strong>Developer's Note:</strong></p>
<p>There are a few arguments not having a method which directly corresponds to their respective argument.</p>
<p>These arguments most likely use a builder pattern and because of that require further implementation by the user.</p>
<p>To use these arguments, the DSL also provides the <code>argument()</code> method which takes in any argument as a parameter.</p>
</div>
<hr />
<h2 id="editing-arguments"><a class="header" href="#editing-arguments">Editing arguments</a></h2>
<p>When using the DSL, you might want to modify the behaviour of certain arguments by adding requirements or suggestions to them.</p>
<p>To give you a general idea how you could accomplish that, the <code>sendMessageTo</code> command is adding a broadcast option which should only be executed by server operators.</p>
<div class="multi-pre">
<pre><code class="language-kotlin CommandTree">commandTree(&quot;sendMessageTo&quot;) {
    playerArgument(&quot;player&quot;) {
        greedyStringArgument(&quot;msg&quot;) {
            playerExecutor { _, args -&gt;
                val player: Player = args[&quot;player&quot;] as Player
                val message: String = args[&quot;msg&quot;] as String
                player.sendMessage(message)
            }
        }
    }
    literalArgument(&quot;broadcast&quot;) {
        withRequirement { sender: CommandSender -&gt; sender.isOp } // Applies the requirement to the broadcast literal argument
        /* add more methods here that modify argument behaviour */
        greedyStringArgument(&quot;msg&quot;) {
            playerExecutor { _, args -&gt;
                val message: String = args[&quot;msg&quot;] as String
                Bukkit.broadcastMessage(message)
            }
        }
    }
}
</code></pre>
<pre><code class="language-kotlin CommandAPICommand">commandAPICommand(&quot;sendMessageTo&quot;) {
    playerArgument(&quot;player&quot;)
    greedyStringArgument(&quot;msg&quot;)
    playerExecutor { _, args -&gt;
        val player: Player = args[&quot;player&quot;] as Player
        val message: String = args[&quot;msg&quot;] as String
        player.sendMessage(message)
    }
}

commandAPICommand(&quot;sendMessageTo&quot;) {
    literalArgument(&quot;broadcast&quot;) {
        withRequirement { sender: CommandSender -&gt; sender.isOp } // Applies the requirement to the broadcast literal argument
        /* add more methods here that modify argument behaviour */
    }
    greedyStringArgument(&quot;msg&quot;)
    playerExecutor { _, args -&gt;
        val message: String = args[&quot;msg&quot;] as String
        Bukkit.broadcastMessage(message)
    }
}
</code></pre>
</div>
<p>Notice how you can just add the requirement in a CommandTree by adding it to the argument block where you also define the next arguments and the executor.</p>
<p>However, when modifying the behaviour of an argument in a CommandAPICommand you have to add an extra block where you can implement the additional behaviour.</p>
<h3 id="adding-requirements-to-commands-1"><a class="header" href="#adding-requirements-to-commands-1">Adding requirements to commands</a></h3>
<p>Expanding on the previous example where we added a requirement to a single argument, we now also want to add a requirement to a whole command.</p>
<p>This works similar to how argument behaviour is modified in a CommandTree:</p>
<div class="multi-pre">
<pre><code class="language-kotlin CommandTree">commandTree(&quot;commandRequirement&quot;) {
    withRequirement { sender: CommandSender -&gt; sender.isOp}
    playerExecutor { player, _ -&gt;
        player.sendMessage(&quot;This command can only be executed by players who are server operators.&quot;)
    }
}
</code></pre>
<pre><code class="language-kotlin CommandAPICommand">commandAPICommand(&quot;commandRequirement&quot;) {
    withRequirement { sender: CommandSender -&gt; sender.isOp}
    playerExecutor { player, _ -&gt;
        player.sendMessage(&quot;This command can only be executed by players who are server operators.&quot;)
    }
}
</code></pre>
</div>
<hr />
<h2 id="more-examples"><a class="header" href="#more-examples">More examples</a></h2>
<p>Now, a few more examples are shown to demonstrate the use of this DSL a little more:</p>
<div class="example">
<h3 id="example---implementing-optional-arguments-with-the-kotlin-dsl"><a class="header" href="#example---implementing-optional-arguments-with-the-kotlin-dsl">Example - Implementing optional arguments with the Kotlin DSL</a></h3>
<p>We want to create a <code>/give</code> command with the following syntax:</p>
<pre><code class="language-mccmd">/optionalArgument give &lt;item&gt;
/optionalArgument give &lt;item&gt; &lt;amount&gt;
</code></pre>
<p>To declare an argument as optional you need to set the <code>optional</code> value to <code>true</code>:</p>
<div class="multi-pre">
<pre><code class="language-kotlin CommandTree">commandTree(&quot;optionalArgument&quot;) {
    literalArgument(&quot;give&quot;) {
        itemStackArgument(&quot;item&quot;) {
            integerArgument(&quot;amount&quot;, optional = true) {
                playerExecutor { player, args -&gt;
                    // This command will let you execute:
                    // &quot;/optionalArgument give minecraft:stick&quot;
                    // &quot;/optionalArgument give minecraft:stick 5&quot;
                    val itemStack: ItemStack = args[&quot;item&quot;] as ItemStack
                    val amount: Int = args.getOptional(&quot;amount&quot;).orElse(1) as Int
                    itemStack.amount = amount
                    player.inventory.addItem(itemStack)
                }
            }
        }
    }
}
</code></pre>
<pre><code class="language-kotlin CommandAPICommand">commandAPICommand(&quot;optionalArgument&quot;) {
    literalArgument(&quot;give&quot;)
    itemStackArgument(&quot;item&quot;)
    integerArgument(&quot;amount&quot;, optional = true) // This sets the argument as optional
    playerExecutor { player, args -&gt;
        // This command will let you execute:
        // &quot;/optionalArgument give minecraft:stick&quot;
        // &quot;/optionalArgument give minecraft:stick 5&quot;
        val itemStack: ItemStack = args[&quot;item&quot;] as ItemStack
        val amount: Int = args.getOptional(&quot;amount&quot;).orElse(1) as Int
        itemStack.amount = amount
        player.inventory.addItem(itemStack)
    }
}
</code></pre>
</div>
</div>
<div class="example">
<h3 id="example---replacing-suggestions-using-the-kotlin-dsl"><a class="header" href="#example---replacing-suggestions-using-the-kotlin-dsl">Example - Replacing suggestions using the Kotlin DSL</a></h3>
<p>We want to create a command with the following syntax to demonstrate replacing suggestions using the Kotlin DSL:</p>
<pre><code class="language-mccmd">/replaceSuggestions &lt;strings&gt;
</code></pre>
<p>Replacing suggestions works similar to how you would add a requirement to an argument as shown in <a href="kotlindsl.html#editing-arguments">Editing arguments</a>.</p>
<p>You just have to use the <code>replaceSuggestions</code> method this time:</p>
<div class="multi-pre">
<pre><code class="language-kotlin CommandTree">commandTree(&quot;replaceSuggestions&quot;) {
    stringArgument(&quot;strings&quot;) {
        replaceSuggestions(ArgumentSuggestions.strings(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)) // Replaces the suggestions for the &quot;strings&quot; StringArgument
        playerExecutor { player, args -&gt;
            player.sendMessage(&quot;You chose option ${args[&quot;strings&quot;] as String}!&quot;)
        }
    }
}
</code></pre>
<pre><code class="language-kotlin CommandAPICommand">commandAPICommand(&quot;replaceSuggestions&quot;) {
    stringArgument(&quot;strings&quot;) {
        replaceSuggestions(ArgumentSuggestions.strings(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)) // Replaces the suggestions for the &quot;strings&quot; StringArgument
    }
    playerExecutor { player, args -&gt;
        player.sendMessage(&quot;You chose option ${args[&quot;strings&quot;] as String}!&quot;)
    }
}
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="delegated-properties"><a class="header" href="#delegated-properties">Delegated properties</a></h1>
<p>The CommandAPI offers an additional way to access arguments when using Kotlin: <a href="https://kotlinlang.org/docs/delegated-properties.html">delegated properties</a>. With delegated properties, there are two possible dependencies you can use:</p>
<ol>
<li>
<p><code>commandapi-core-kotlin</code></p>
<p>Support for delegated properties has been added to the <code>commandapi-core-kotlin</code> module. If you want to use delegated properties, you need to add this dependency.</p>
</li>
<li>
<p><code>commandapi-bukkit-kotlin</code></p>
<p>If you are already using the Kotlin DSL to create your commands, you can already use delegated properties. <code>commandapi-core-kotlin</code> is included in <code>commandapi-bukkit-kotlin</code>.</p>
</li>
</ol>
<h3 id="access-arguments-using-delegated-properties"><a class="header" href="#access-arguments-using-delegated-properties">Access arguments using delegated properties</a></h3>
<p>To be able to access arguments by using delegated properties, your variable name needs to match the node name of the argument. This could look like this:</p>
<div class="multi-pre">
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;mycommand&quot;)
    .withArguments(StringArgument(&quot;string&quot;))
    .withArguments(PlayerArgument(&quot;target&quot;))
    .executesPlayer(PlayerCommandExecutor { player, args -&gt;
        val string: String by args
        val target: Player by args
        // Implementation...
    })
    .register()
</code></pre>
<pre><code class="language-kotlin Kotlin_DSL">commandAPICommand(&quot;mycommand&quot;) {
    stringArgument(&quot;string&quot;)
    playerArgument(&quot;target&quot;)
    playerExecutor { player, args -&gt;
        val string: String by args
        val target: Player by args
        // Implementation...
    }
}
</code></pre>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="velocity"><a class="header" href="#velocity">Velocity</a></h1>
<blockquote>
<p><strong>Developer's Note:</strong></p>
<p>The CommandAPI hasn't been released for Velocity yet.
We do, however, offer snapshot builds. This small section on Velocity will outline how to get the snapshot builds and what limitations the CommandAPI currently has on Velocity.</p>
<p>This page focuses on outlining how to set up the CommandAPI for Velocity. It expects that you are already familiar with how to set up a Velocity plugin.</p>
</blockquote>
<h2 id="adding-the-snapshot-repository-with-maven-or-gradle"><a class="header" href="#adding-the-snapshot-repository-with-maven-or-gradle">Adding the snapshot repository with Maven or Gradle</a></h2>
<p>Because we do not have an official release yet, the snapshot builds are not published in the Maven Central repository. Instead you need to add our snapshot repository:</p>
<div class="multi-pre">
<pre><code class="language-xml pom.xml">&lt;repositories&gt;
    &lt;repository&gt;
        &lt;id&gt;oss.sonatype.org-snapshot&lt;/id&gt;
        &lt;url&gt;https://s01.oss.sonatype.org/content/repositories/snapshots&lt;/url&gt;
    &lt;/repository&gt;
&lt;/repositories&gt;
</code></pre>
<pre><code class="language-gradle build.gradle">repositories {
    maven {
        url = &quot;https://s01.oss.sonatype.org/content/repositories/snapshots&quot;
    }
}
</code></pre>
<pre><code class="language-gradle build.gradle.kts">repositories {
    maven {
        url = uri(&quot;https://s01.oss.sonatype.org/content/repositories/snapshots&quot;)
    }
}
</code></pre>
</div>
<h2 id="adding-the-dependency"><a class="header" href="#adding-the-dependency">Adding the dependency</a></h2>
<p>As mentioned, Velocity can only be accessed with snapshot builds. These snapshot build version are following standard semantic versioning and thus have the <code>-SNAPSHOT</code> suffix:</p>
<div class="multi-pre">
<pre><code class="language-xml pom.xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;dev.jorel&lt;/groupId&gt;
        &lt;artifactId&gt;commandapi-velocity-shade&lt;/artifactId&gt;
        &lt;version&gt;9.5.0-SNAPSHOT&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<pre><code class="language-gradle build.gradle">dependencies {
    implementation &quot;dev.jorel:commandapi-velocity-shade:9.5.0-SNAPSHOT&quot;
}
</code></pre>
<pre><code class="language-gradle build.gradle.kts">dependencies {
    implementation(&quot;dev.jorel:commandapi-velocity-shade:9.5.0-SNAPSHOT&quot;)
}
</code></pre>
</div>
<h2 id="setting-up-the-commandapi"><a class="header" href="#setting-up-the-commandapi">Setting up the CommandAPI</a></h2>
<p>The CommandAPI requires two steps: loading and enabling. We will perform these steps in Velocity's loading stages, construction and initialization. These two stages are explained in <a href="https://docs.papermc.io/velocity/dev/api-basics#a-word-of-caution">their documentation</a>.
We will perform the CommandAPI's loading step in the construction phase first:</p>
<div class="multi-pre">
<pre><code class="language-java Java">@Inject
public ExamplePlugin(ProxyServer server, Logger logger) {
    this.server = server;
    this.logger = logger;

    CommandAPI.onLoad(new CommandAPIVelocityConfig(server, this));
}
</code></pre>
</div>
<p>Next, we want to utilize Velocity's <code>ProxyInitializeEvent</code> to perform the CommandAPI's enabling step:</p>
<div class="multi-pre">
<pre><code class="language-java Java">@Subscribe
public void onProxyInitialization(ProxyInitializeEvent event) {
    // Any CommandAPI command registrations...
    CommandAPI.onEnable();
}
</code></pre>
</div>
<h2 id="current-limitations"><a class="header" href="#current-limitations">Current limitations</a></h2>
<p>The CommandAPI currently only offers support for a very limited amount of arguments on Velocity. This is because arguments are primarily implemented on the backend servers.
However, the CommandAPI offers access for the primitive type arguments:</p>
<ul>
<li><a href="./argument_primitives.html#numerical-arguments"><code>IntegerArgument</code></a></li>
<li><a href="./argument_primitives.html#numerical-arguments"><code>LongArgument</code></a></li>
<li><a href="./argument_primitives.html#numerical-arguments"><code>FloatArgument</code></a></li>
<li><a href="./argument_primitives.html#numerical-arguments"><code>DoubleArgument</code></a></li>
<li><a href="./argument_primitives.html#boolean-arguments"><code>BooleanArgument</code></a></li>
<li><a href="./argument_strings.html#string-argument"><code>StringArgument</code></a></li>
<li><a href="./argument_strings.html#text-argument"><code>TextArgument</code></a></li>
<li><a href="./argument_strings.html#greedy-string-argument"><code>GreedyStringArgument</code></a></li>
<li><a href="./argument_literal.html"><code>LiteralArgument</code></a></li>
<li><a href="./argument_multiliteral.html"><code>MultiLiteralArgument</code></a></li>
</ul>
<h2 id="registering-a-simple-command"><a class="header" href="#registering-a-simple-command">Registering a simple command</a></h2>
<p>Command registration works the same way as it does in Bukkit. To visualize this, we want to register a simple command that generates a random number between a chosen minimum and a chosen maximum value:</p>
<div class="example">
<h3 id="example---registering-a-simple-command"><a class="header" href="#example---registering-a-simple-command">Example - Registering a simple command</a></h3>
<p>We want to register the command <code>/randomnumber</code> with the following syntax:</p>
<pre><code class="language-mccmd">/randomnumber &lt;min&gt; &lt;max&gt;
</code></pre>
<p>To accomplish that, we register the command like this:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;randomnumber&quot;)
    .withArguments(new IntegerArgument(&quot;min&quot;))
    .withArguments(new IntegerArgument(&quot;max&quot;))
    .executesPlayer((player, args) -&gt; {
        int min = (int) args.get(&quot;min&quot;);
        int max = (int) args.get(&quot;max&quot;);
        Random random = ThreadLocalRandom.current();
        int randomNumber = random.nextInt(min, max);
        player.sendMessage(Component.text().content(&quot;Your random number is: &quot; + randomNumber));
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;randomnumber&quot;)
    .withArguments(IntegerArgument(&quot;min&quot;))
    .withArguments(IntegerArgument(&quot;max&quot;))
    .executesPlayer(PlayerCommandExecutor { player, args -&gt;
        val min = args[&quot;min&quot;] as Int
        val max = args[&quot;max&quot;] as Int
        val random = ThreadLocalRandom.current()
        val randomNumber = random.nextInt(min, max)
        player.sendMessage(Component.text().content(&quot;Your random number is: $randomNumber&quot;))
    })
    .register()
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-conversion"><a class="header" href="#command-conversion">Command conversion</a></h1>
<blockquote>
<p><strong>Developer's Note:</strong></p>
<p>If you're a server owner, you're probably lost! This section is for developer command conversion. If you're looking for how to convert plugins with the <code>config.yml</code> file, you want <a href="./config.html#command-conversion">2. Configuration for server owners</a>.</p>
</blockquote>
<p>The CommandAPI has the ability to convert plugin commands to vanilla Minecraft commands using its <code>config.yml</code>'s <code>plugins-to-convert</code> option. Nevertheless, the API for command conversion is not hidden and you're free to use it as you see fit!</p>
<hr />
<p>Before you continue, let's clear up a few naming conventions which is used in the following sections!</p>
<ul>
<li><strong>Target plugin</strong> - This refers to a non-CommandAPI plugin which registers normal Bukkit commands. This typically uses the old <code>boolean onCommand(CommandSender ... )</code> method</li>
<li><strong>Your plugin</strong> - This refers to your plugin, the one that uses the CommandAPI and wants to add compatibility to a target plugin</li>
</ul>
<hr />
<h2 id="entire-plugins"><a class="header" href="#entire-plugins">Entire plugins</a></h2>
<p>To register all commands that are declared by a target plugin, the <code>Converter.convert(Plugin)</code> method can be used. This attempts to register all commands declared in a target plugin's <code>plugin.yml</code> file, as well as any aliases or permissions stated in the <code>plugin.yml</code> file.</p>
<div class="example">
<h3 id="example---converting-commands-for-a-target-plugin"><a class="header" href="#example---converting-commands-for-a-target-plugin">Example - Converting commands for a target plugin</a></h3>
<p>Say you have some <code>plugin.yml</code> file for a target plugin that adds some basic functionality to a server. The target plugin in this example is called &quot;TargetPlugin&quot;:</p>
<pre><code class="language-yaml">name: TargetPlugin
main: some.random.package.Main
version: 1.0
commands:
  gmc:
    aliases: gm1
  gms:
  i:
    permission: item.permission
</code></pre>
<p>As you can see, it declares 3 commands: <code>/gmc</code>, <code>/gms</code> and <code>/i</code>. We can now begin writing your plugin that uses the CommandAPI converter. We will call this plugin &quot;YourPlugin&quot;:</p>
<div class="multi-pre">
<pre><code class="language-java Java">public class YourPlugin extends JavaPlugin {
    
    @Override
    public void onEnable() {
        Converter.convert((JavaPlugin) Bukkit.getPluginManager().getPlugin(&quot;TargetPlugin&quot;));
        // Other code goes here...
    }
    
}
</code></pre>
<pre><code class="language-kotlin Kotlin">class YourPlugin : JavaPlugin() {

    override fun onEnable() {
        Converter.convert(Bukkit.getPluginManager().getPlugin(&quot;TargetPlugin&quot;) as JavaPlugin)
        // Other code goes here...
    }

}
</code></pre>
</div>
<p>When this is run, the commands <code>/gmc</code>, <code>/gm1</code>, <code>/gms</code> and <code>/i</code> will all be registered by the CommandAPI.</p>
</div>
<hr />
<h2 id="only-specific-commands"><a class="header" href="#only-specific-commands">Only specific commands</a></h2>
<p>In addition to converting all commands from a target plugin, the CommandAPI allows you to convert single commands at a time using the following methods from the <code>Converter</code> class:</p>
<pre><code class="language-java">public static convert(Plugin plugin, String cmdName);
public static convert(Plugin plugin, String cmdName, List&lt;Argument&gt; arguments);
public static convert(Plugin plugin, String cmdName, Argument... arguments);
</code></pre>
<p>In these commands, the <code>plugin</code> refers to the plugin which has the command you want to convert and <code>cmdName</code> is the name of the command declared in the target plugin's <code>plugin.yml</code> file (just the main command, not the aliases!).</p>
<p>The <code>List&lt;Argument&gt;</code> or <code>Argument...</code> can be used to provide argument checks that lets you apply the command UI to a bukkit command.</p>
<div class="example">
<h3 id="example---converting-essentialsxs-speed-command-1"><a class="header" href="#example---converting-essentialsxs-speed-command-1">Example - Converting EssentialsX's speed command</a></h3>
<p>Say we want to convert EssentialsX's <code>/speed</code> command using the CommandAPI. The <code>plugin.yml</code> entry for the <code>/speed</code> command is the following:</p>
<pre><code class="language-yaml">  speed:
    description: Change your speed limits.
    usage: /&lt;command&gt; [type] &lt;speed&gt; [player]
    aliases: [flyspeed,eflyspeed,fspeed,efspeed,espeed,walkspeed,ewalkspeed,wspeed,ewspeed]
</code></pre>
<p>From this, we can determine that there are the following commands, where &quot;walk&quot; and &quot;fly&quot; are the different types that the command can take:</p>
<pre><code class="language-mccmd">/speed &lt;speed&gt;
/speed &lt;speed&gt; &lt;target&gt;
/speed &lt;walk/fly&gt; &lt;speed&gt;
/speed &lt;walk/fly&gt; &lt;speed&gt; &lt;target&gt;
</code></pre>
<p>With the EssentialsX plugin, the <code>&lt;speed&gt;</code> value can only take numbers between 0 and 10. As such, we'll ensure to apply these limits using the <code>IntegerArgument</code>. In addition, since the speed type can only be &quot;walk&quot; or &quot;fly&quot;, we'll add that to our converter as well using a <code>MultiLiteralArgument</code>:</p>
<div class="multi-pre">
<pre><code class="language-java Java">JavaPlugin essentials = (JavaPlugin) Bukkit.getPluginManager().getPlugin(&quot;Essentials&quot;);

// /speed &lt;speed&gt;
Converter.convert(essentials, &quot;speed&quot;, new IntegerArgument(&quot;speed&quot;, 0, 10));

// /speed &lt;target&gt;
Converter.convert(essentials, &quot;speed&quot;, new PlayerArgument(&quot;target&quot;));

// /speed &lt;walk/fly&gt; &lt;speed&gt;
Converter.convert(essentials, &quot;speed&quot;, 
    new MultiLiteralArgument(&quot;modes&quot;, &quot;walk&quot;, &quot;fly&quot;),
    new IntegerArgument(&quot;speed&quot;, 0, 10)
);

// /speed &lt;walk/fly&gt; &lt;speed&gt; &lt;target&gt;
Converter.convert(essentials, &quot;speed&quot;, 
    new MultiLiteralArgument(&quot;modes&quot;, &quot;walk&quot;, &quot;fly&quot;),
    new IntegerArgument(&quot;speed&quot;, 0, 10), 
    new PlayerArgument(&quot;target&quot;)
);
</code></pre>
<pre><code class="language-kotlin Kotlin">val essentials = Bukkit.getPluginManager().getPlugin(&quot;Essentials&quot;) as JavaPlugin

// /speed &lt;speed&gt;
Converter.convert(essentials, &quot;speed&quot;, IntegerArgument(&quot;speed&quot;, 0, 10))

// /speed &lt;target&gt;
Converter.convert(essentials, &quot;speed&quot;, PlayerArgument(&quot;target&quot;))

// /speed &lt;walk/fly&gt; &lt;speed&gt;
Converter.convert(essentials, &quot;speed&quot;,
    MultiLiteralArgument(&quot;modes&quot;, &quot;walk&quot;, &quot;fly&quot;),
    IntegerArgument(&quot;speed&quot;, 0, 10)
)

// /speed &lt;walk/fly&gt; &lt;speed&gt; &lt;target&gt;
Converter.convert(essentials, &quot;speed&quot;,
    MultiLiteralArgument(&quot;modes&quot;, &quot;walk&quot;, &quot;fly&quot;),
    IntegerArgument(&quot;speed&quot;, 0, 10),
    PlayerArgument(&quot;target&quot;)
)
</code></pre>
</div>
<p><img src="./images/speed.gif" alt="An image showing /execute run for EssentialsX's /speed command" /></p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plugin-reloading"><a class="header" href="#plugin-reloading">Plugin reloading</a></h1>
<p>Formally, the CommandAPI <strong>does not</strong> support plugin reloading. This includes, but is not limited to:</p>
<ul>
<li>The <code>/reload</code> command which reloads all plugins on the server</li>
<li>Plugin reloading plugins, such as <a href="https://dev.bukkit.org/projects/plugman">PlugMan</a></li>
<li>Any form of plugin enabling/disabling process for plugins which register commands via the CommandAPI</li>
</ul>
<p>In general, using the <code>/reload</code> command is <em>not advised</em>. Here's some useful resources from various Bukkit/Spigot/Paper developers:</p>
<ul>
<li>Maddy Miller (WorldEdit creator):
<ul>
<li><a href="https://madelinemiller.dev/blog/problem-with-reload/">Why you should never /reload on Spigot, Bukkit, and Paper</a></li>
</ul>
</li>
<li>Bukkit Forums:
<ul>
<li><a href="https://bukkit.org/threads/is-reload-that-bad.129514/">Is /reload that bad</a></li>
<li><a href="https://bukkit.org/threads/petition-to-remove-the-reload-command.43212/">Petition to remove the /reload command</a></li>
</ul>
</li>
<li>Spigot Forums:
<ul>
<li><a href="https://www.spigotmc.org/threads/whats-with-the-reload-command.344458/">What's with the /reload command?</a></li>
<li><a href="https://www.spigotmc.org/threads/lets-kill-reload-or-make-it-better.35611/">Let's kill /reload, or make it better.</a></li>
</ul>
</li>
</ul>
<p>The CommandAPI is <em>not like normal Bukkit/Spigot/Paper plugins</em>. It directly accesses all of the nitty-gritty Vanilla Minecraft code to convert and expose Minecraft's internal command framework into a Bukkit-API friendly interface for you to use. As the CommandAPI hooks directly into Vanilla Minecraft code, and <code>/reload</code> is a Bukkit feature, using <code>/reload</code> can cause Vanilla Minecraft's internal system to become unstable. If you are having issues with <code>/reload</code>, seriously reconsider shutting your server down correctly and restarting it, instead of running <code>/reload</code>.</p>
<hr />
<p>Despite this, there is one way to get reloading to work using the <code>onDisable()</code> method in your plugin. If you register a command in your <code>onLoad()</code> or <code>onEnable()</code> method, by unregistering the command in your <code>onDisable()</code> method, this allows the CommandAPI to properly register the command again when the server reloads.</p>
<div class="warning">
<p><strong>Developer's Note:</strong></p>
<p>Despite the fact that you can do this, I cannot stress enough that <strong>this is not recommended</strong>, due to the fact that <strong>functions/tags in datapacks do not work with <code>/reload</code>, even if you unregister the command</strong>.</p>
</div>
<div class="example">
<h3 id="example---allowing-a-command-to-work-with-reload"><a class="header" href="#example---allowing-a-command-to-work-with-reload">Example - Allowing a command to work with /reload</a></h3>
<p>In this example, we add support for reloading the server via <code>/reload</code> by unregistering the command in the <code>onDisable()</code> method. Note that force-unregistering is not required for this:</p>
<pre><code class="language-java">public class MyPlugin extends JavaPlugin {

    @Override
    public void onEnable() {
        new CommandAPICommand(&quot;ping&quot;)
            .executes((sender, args) -&gt; {
                sender.sendMessage(&quot;Pong!&quot;);
            })
            .register();
    }

    @Override
    public void onDisable() {
        CommandAPI.unregister(&quot;ping&quot;);
    }

}
</code></pre>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="internal-commandapi"><a class="header" href="#internal-commandapi">Internal CommandAPI</a></h1>
<p>The CommandAPI does a lot of stuff &quot;behind the scenes&quot;. This internal CommandAPI section will go into detail about what the CommandAPI does, how it's implemented and why it has been implemented like that.</p>
<hr />
<h2 id="argument-identifiers"><a class="header" href="#argument-identifiers">Argument identifiers</a></h2>
<p>The CommandAPI's arguments are representations of the different arguments that the Minecraft Command Data protocol handles. These are outlined in the table below:</p>
<div class="table-wrapper"><table><thead><tr><th>Identifier</th><th>CommandAPI argument</th></tr></thead><tbody>
<tr><td><code>brigadier:bool</code></td><td><a href="./argument_primitives.html#boolean-arguments"><code>BooleanArgument</code></a></td></tr>
<tr><td><code>brigadier:double</code></td><td><a href="./argument_primitives.html#numerical-arguments"><code>DoubleArgument</code></a></td></tr>
<tr><td><code>brigadier:float</code></td><td><a href="./argument_primitives.html#numerical-arguments"><code>FloatArgument</code></a></td></tr>
<tr><td><code>brigadier:integer</code></td><td><a href="./argument_primitives.html#numerical-arguments"><code>IntegerArgument</code></a></td></tr>
<tr><td><code>brigadier:long</code></td><td><a href="./argument_primitives.html#numerical-arguments"><code>LongArgument</code></a></td></tr>
<tr><td><code>brigadier:string</code></td><td><a href="./argument_strings.html#string-argument"><code>StringArgument</code></a><br /><a href="./argument_strings.html#text-argument"><code>TextArgument</code></a><br /><a href="./argument_strings.html#greedy-string-argument"><code>GreedyStringArgument</code></a><br /><a href="./argument_custom.html"><code>CustomArgument&lt;T&gt;</code></a></td></tr>
<tr><td><code>minecraft:angle</code></td><td><a href="./argument_angle.html"><code>AngleArgument</code></a></td></tr>
<tr><td><code>minecraft:block_pos</code></td><td><a href="./argument_locations.html#location-3d-space"><code>LocationArgument</code></a><br />(<code>LocationType.BLOCK_POSITION</code>)</td></tr>
<tr><td><code>minecraft:block_predicate</code></td><td><a href="./argument_blockpredicate.html"><code>BlockPredicateArgument</code></a></td></tr>
<tr><td><code>minecraft:block_state</code></td><td><a href="./argument_blockstate.html"><code>BlockStateArgument</code></a></td></tr>
<tr><td><code>minecraft:color</code></td><td><a href="./argument_chats.html#chat-color-argument"><code>ChatColorArgument</code></a></td></tr>
<tr><td><code>minecraft:column_pos</code></td><td><a href="./argument_locations.html#location-2d-space"><code>Location2DArgument</code></a> <br />(<code>LocationType.BLOCK_POSITION</code>)</td></tr>
<tr><td><code>minecraft:component</code></td><td><a href="./argument_chats.html#chat-component-argument"><code>ChatComponentArgument</code></a></td></tr>
<tr><td><code>minecraft:dimension</code></td><td><a href="./argument_world.html"><code>WorldArgument</code></a></td></tr>
<tr><td><code>minecraft:entity</code></td><td><a href="./argument_entities.html#entity-selector-argument"><code>EntitySelectorArgument</code></a></td></tr>
<tr><td><code>minecraft:entity_anchor</code></td><td></td></tr>
<tr><td><code>minecraft:entity_summon</code></td><td><a href="./argument_entities.html#entity-type-argument"><code>EntityTypeArgument</code></a></td></tr>
<tr><td><code>minecraft:float_range</code></td><td><a href="./argument_range.html#the-integerrange--floatrange-class"><code>FloatRangeArgument</code></a></td></tr>
<tr><td><code>minecraft:function</code></td><td><a href="./functionwrapper.html"><code>FunctionArgument</code></a></td></tr>
<tr><td><code>minecraft:game_profile</code></td><td><a href="./argument_entities.html#player-argument"><code>PlayerArgument</code></a></td></tr>
<tr><td><code>minecraft:game_profile</code></td><td><a href="./argument_entities.html#offlineplayer-argument"><code>OfflinePlayerArgument</code></a></td></tr>
<tr><td><code>minecraft:int_range</code></td><td><a href="./argument_range.html#the-integerrange--floatrange-class"><code>IntegerRangeArgument</code></a></td></tr>
<tr><td><code>minecraft:item_enchantment</code></td><td><a href="./argument_enchantment.html"><code>EnchantmentArgument</code></a></td></tr>
<tr><td><code>minecraft:item_predicate</code></td><td><a href="./argument_itemstackpredicate.html"><code>ItemStackPredicateArgument</code></a></td></tr>
<tr><td><code>minecraft:item_slot</code></td><td></td></tr>
<tr><td><code>minecraft:item_stack</code></td><td><a href="./argument_itemstack.html"><code>ItemStackArgument</code></a></td></tr>
<tr><td><code>minecraft:message</code></td><td><a href="./argument_chats.html#chat-argument"><code>ChatArgument</code></a></td></tr>
<tr><td><code>minecraft:mob_effect</code></td><td><a href="./argument_potion.html"><code>PotionEffectArgument</code></a></td></tr>
<tr><td><code>minecraft:nbt</code></td><td></td></tr>
<tr><td><code>minecraft:nbt_compound_tag</code></td><td><a href="./argument_nbt.html"><code>NBTCompoundArgument</code></a></td></tr>
<tr><td><code>minecraft:nbt_path</code></td><td></td></tr>
<tr><td><code>minecraft:nbt_tag</code></td><td></td></tr>
<tr><td><code>minecraft:objective</code></td><td><a href="./argument_objectives.html#objective-argument"><code>ObjectiveArgument</code></a></td></tr>
<tr><td><code>minecraft:objective_criteria</code></td><td><a href="./argument_objectives.html#objective-criteria-argument"><code>ObjectiveCriteriaArgument</code></a></td></tr>
<tr><td><code>minecraft:operation</code></td><td><a href="./argument_mathoperation.html"><code>MathOperationArgument</code></a></td></tr>
<tr><td><code>minecraft:particle</code></td><td><a href="./argument_particles.html"><code>ParticleArgument</code></a></td></tr>
<tr><td><code>minecraft:resource_location</code></td><td><a href="./advancementargument.html"><code>AdvancementArgument</code></a><br /><a href="./argument_biome.html"><code>BiomeArgument</code></a><br /><a href="./argument_custom.html"><code>CustomArgument&lt;T&gt;</code></a><br /><a href="./argument_loottable.html"><code>LootTableArgument</code></a><br /><a href="./argument_namespacedkey.html"><code>NamespacedKeyArgument</code></a><br /><a href="./argument_recipe.html"><code>RecipeArgument</code></a><br /><a href="./argument_sound.html"><code>SoundArgument</code></a></td></tr>
<tr><td><code>minecraft:rotation</code></td><td><a href="./argument_rotation.html"><code>RotationArgument</code></a></td></tr>
<tr><td><code>minecraft:score_holder</code></td><td><a href="./argument_scoreboards.html#score-holder-argument"><code>ScoreHolderArgument</code></a></td></tr>
<tr><td><code>minecraft:scoreboard_slot</code></td><td><a href="./argument_scoreboards.html#scoreboard-slot-argument"><code>ScoreboardSlotArgument</code></a></td></tr>
<tr><td><code>minecraft:swizzle</code></td><td><a href="./argument_axis.html"><code>AxisArgument</code></a></td></tr>
<tr><td><code>minecraft:team</code></td><td><a href="./argument_team.html"><code>TeamArgument</code></a></td></tr>
<tr><td><code>minecraft:time</code></td><td><a href="./argument_time.html"><code>TimeArgument</code></a></td></tr>
<tr><td><code>minecraft:uuid</code></td><td><a href="./argument_uuid.html"><code>UUIDArgument</code></a></td></tr>
<tr><td><code>minecraft:vec2</code></td><td><a href="./argument_locations.html#location-2d-space"><code>Location2DArgument</code></a><br />(<code>LocationType.PRECISE_POSITION</code>)</td></tr>
<tr><td><code>minecraft:vec3</code></td><td><a href="./argument_locations.html#location-3d-space"><code>LocationArgument</code></a><br />(<code>LocationType.PRECISE_POSITION</code>)</td></tr>
</tbody></table>
</div>
<p>There are a few arguments that aren't implemented. Here's why:</p>
<ul>
<li>
<p><code>minecraft:entity_anchor</code> - This argument only has two values: <code>eyes</code> and <code>feet</code>. It's incredibly unnecessary for any other purpose and is easier to implement with a <code>MultiLiteralArgument</code>.</p>
</li>
<li>
<p><code>minecraft:item_slot</code> - Bukkit's implementation of item slot numbers differs very wildly to Minecraft's implementation of item slot numbers. This difference makes it near-impossible to have a suitable middle-ground for item slot numbers that ensures that invalid numbers cannot be passed to the wrong inventory type. An implementation of this would require a rewrite of the current system to maintain proper inventory slot access safety.</p>
</li>
<li>
<p><code>minecraft:nbt</code>, <code>minecraft:nbt_path</code>, <code>minecraft:nbt_tag</code> - You've got the <code>NBTCompoundArgument</code>, that's good enough, right? ¯\_(ツ)_/¯</p>
</li>
</ul>
<hr />
<h2 id="reloading-datapacks"><a class="header" href="#reloading-datapacks">Reloading datapacks</a></h2>
<p>During the initialization of Minecraft 1.16+ servers, the CommandAPI uses a custom datapack reloading sequence as opposed to the normal Vanilla Minecraft datapack reloading method. The CommandAPI's method uses the server's current command dispatcher object as opposed to a new one, which allows datapacks to use commands registered by the CommandAPI. This can be invoked using the following method:</p>
<pre><code class="language-java">CommandAPI.reloadDatapacks();
</code></pre>
<hr />
<h2 id="getting-a-list-of-registered-commands"><a class="header" href="#getting-a-list-of-registered-commands">Getting a list of registered commands</a></h2>
<p>The CommandAPI doesn't store the <code>CommandAPICommand</code> objects during the main running of the server because it simply doesn't need to. Instead, it stores a list of <code>RegisteredCommand</code> objects which are defined as the following, which should be fairly self-explanatory:</p>
<pre><code class="language-java">public record RegisteredCommand {
    String commandName();
    List&lt;String&gt; argsAsStr();
    Optional&lt;String&gt; shortDescription();
    Optional&lt;String&gt; fullDescription();
    Optional&lt;String[]&gt; usageDescription();
    String[] aliases();
    CommandPermission permission();
}
</code></pre>
<p>The <code>argsAsStr()</code> method returns a list of arguments in a string format, of the form <code>argName:SimpleClassName</code>, where <code>argName</code> is the name of the argument (the argument's node name) and <code>SimpleClassName</code> is the name of the argument class that was used to construct it (such as <code>IntegerArgument</code>).</p>
<p>A <code>List&lt;RegisteredCommand&gt;</code> can be acquired using the following method:</p>
<pre><code class="language-java">CommandAPI.getRegisteredCommands();
</code></pre>
<blockquote>
<p>Note that this list does not update when commands are <em>unregistered</em>, only when commands are registered.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brigadier--commandapi"><a class="header" href="#brigadier--commandapi">Brigadier + CommandAPI</a></h1>
<p>So far, we've been using only the CommandAPI to register commands. As a result, this makes the CommandAPI's features limited by whatever the CommandAPI has implemented. To push past these limits, the CommandAPI includes some extra methods to help with invoking brigadier methods. Of course, to use these methods, brigadier is required. The brigadier dependency's installation instructions can be found <a href="https://github.com/Mojang/brigadier#installation">here</a>.</p>
<blockquote>
<p><strong>Developer's Note:</strong></p>
<p>For those that are unaware, <a href="https://github.com/Mojang/brigadier">brigadier</a> is Mojang's command parser and dispatching framework. This is what the CommandAPI wraps around and is the main underlying source of its functionality.</p>
</blockquote>
<p>The CommandAPI has been designed in such a way that you shouldn't have to access NMS in order to make use of the more &quot;advanced&quot; arguments and features - if you find that NMS is required to do something, <a href="https://github.com/JorelAli/CommandAPI/issues/new/choose">please make a new issue</a>!</p>
<hr />
<h2 id="brigadier-support-functions"><a class="header" href="#brigadier-support-functions">Brigadier support functions</a></h2>
<p>The CommandAPI offers the following methods in the <code>dev.jorel.commandapi.Brigadier</code> class:</p>
<pre><code class="language-java">public static CommandDispatcher getCommandDispatcher();
public static RootCommandNode getRootNode();
public static LiteralArgumentBuilder fromLiteralArgument(LiteralArgument literalArgument);
public static RedirectModifier fromPredicate(BiPredicate&lt;CommandSender, Object[]&gt; predicate, List&lt;Argument&gt; args);
public static Command fromCommand(CommandAPICommand command);
public static RequiredArgumentBuilder fromArgument(List&lt;Argument&gt; args, Argument&lt;?&gt; argument);
public static RequiredArgumentBuilder fromArgument(Argument argument);
public static SuggestionProvider toSuggestions(Argument&lt;?&gt; argument, List&lt;Argument&gt; args);
public static Object[] parseArguments(CommandContext cmdCtx, List&lt;Argument&gt; args);
public static Object getBrigadierSourceFromCommandSender(CommandSender sender);
public static CommandSender getBukkitCommandSenderFromContext(CommandContext cmdCtx);
</code></pre>
<p>Briefly, here's what each of these functions do (you can view the JavaDocs for more information):</p>
<div class="table-wrapper"><table><thead><tr><th>Method</th><th>Description</th></tr></thead><tbody>
<tr><td><code>getCommandDispatcher</code></td><td>Returns the Minecraft command dispatcher graph</td></tr>
<tr><td><code>getRootNode</code></td><td>Returns the root node of the command dispatcher.<br>This is equivalent to using<br /><code>getCommandDispatcher().getRoot();</code></td></tr>
<tr><td><code>fromLiteralArgument</code></td><td>Creates a <code>LiteralArgumentBuilder</code> from a <code>LiteralArgument</code></td></tr>
<tr><td><code>fromPredicate</code></td><td>Converts a predicate and some arguments into a <code>RedirectModifier</code>. This can be used for the <code>fork</code> method in brigadier's <code>ArgumentBuilder</code></td></tr>
<tr><td><code>fromCommand</code></td><td>Converts a <code>CommandAPICommand</code> into a brigadier <code>Command</code> object</td></tr>
<tr><td><code>fromArgument</code></td><td>Converts an argument, or a list of arguments, into a <code>RequiredArgumentBuilder</code></td></tr>
<tr><td><code>toSuggestions</code></td><td>Converts an argument's suggestions into brigadier's <code>SuggestionProvider</code>, with a list of previously declared arguments</td></tr>
<tr><td><code>parseArguments</code></td><td>Parses a list of CommandAPI arguments into their respective objects for a provided <code>CommandContext</code></td></tr>
<tr><td><code>getBrigadierSourceFromCommandSender</code></td><td>Converts a Bukkit <code>CommandSender</code> into the NMS command sender source object</td></tr>
<tr><td><code>getBukkitCommandSenderFromContext</code></td><td>Converts a Brigadier <code>CommandContext</code> into a Bukkit <code>CommandSender</code></td></tr>
</tbody></table>
</div>
<hr />
<h2 id="examples-3"><a class="header" href="#examples-3">Examples</a></h2>
<p>I hope these examples help understand how the CommandAPI can help with registering more &quot;powerful&quot; commands with the use of brigadier as well! Please bear with with it - these examples can be long, but I'm certain that they've been explained well and will be useful!</p>
<div class="example">
<h3 id="example---adding-a-predicate-to-the-execute-command"><a class="header" href="#example---adding-a-predicate-to-the-execute-command">Example - Adding a predicate to the 'execute' command</a></h3>
<p>Say we wanted to add a predicate to the <code>/execute</code> command. In this example, we'll create a predicate which handles random chances. To illustrate this, we want to be able to run commands such as:</p>
<pre><code class="language-mccmd">/execute if randomchance 1 4 run say Hello!
</code></pre>
<p>In this scenario, if we ran this command, we would expect &quot;Hello!&quot; to appear in the chat with a \(\frac{1}{4}\) chance. In particular, this is what we're trying to achieve:</p>
<ul>
<li>
<p>We want to create a predicate (true/false value) for the following syntax:</p>
<pre><code class="language-mccmd">randomchance &lt;numerator&gt; &lt;denominator&gt;
</code></pre>
</li>
<li>
<p>We also want this predicate to come <em>after</em> <code>execute if</code>:</p>
<p>\begin{gather}
\texttt{execute}\\
\downarrow\\
\texttt{if}\\
\downarrow\\
\texttt{randomchance &lt;numerator}\texttt{&gt; &lt;denominator}\texttt{&gt;}
\end{gather}</p>
</li>
<li>
<p>After entering our predicate, we want to route back to <code>execute</code> (because the argument after <code>execute</code> is <code>run</code>, which is used in our example command above):</p>
<p>\begin{gather}
\texttt{execute}\\
\downarrow\\
\texttt{if}\\
\downarrow\\
\texttt{randomchance &lt;numerator}\texttt{&gt; &lt;denominator}\texttt{&gt;}\\
\downarrow\\
\texttt{execute}
\end{gather}</p>
</li>
</ul>
<hr />
<h4 id="writing-the-code"><a class="header" href="#writing-the-code">Writing the code</a></h4>
<p>Now that we've established what we want, we can finally begin writing the code! First we want to create a literal <code>randomchance</code>. It's a literal because literal values don't change (similar to say <code>run</code> or <code>if</code> from the <code>/execute</code> command). To create a literal, we'll use the <code>fromLiteralArgument</code> method described above, and then build it using the <code>.build()</code> method:</p>
<div class="multi-pre">
<pre><code class="language-java Java">// Register literal &quot;randomchance&quot;
LiteralCommandNode randomChance = Brigadier.fromLiteralArgument(new LiteralArgument(&quot;randomchance&quot;)).build();
</code></pre>
<pre><code class="language-kotlin Kotlin">// Register literal &quot;randomchance&quot;
val randomChance: LiteralCommandNode&lt;Any&gt; = Brigadier.fromLiteralArgument(LiteralArgument(&quot;randomchance&quot;)).build()
</code></pre>
</div>
<p>With that completed, we can now create our &quot;argument&quot; to this predicate. To do this, we'll use the regular declaration of arguments that we would normally use for commands. In this example, because we're computing \(\frac{numerator}{denominator}\), we want our numerator to be 0 or greater and our denominator to be 1 or greater (we don't want any negative numbers or division by zero!):</p>
<div class="multi-pre">
<pre><code class="language-java Java">// Declare arguments like normal
Argument&lt;Integer&gt; numeratorArgument = new IntegerArgument(&quot;numerator&quot;, 0);
Argument&lt;Integer&gt; denominatorArgument = new IntegerArgument(&quot;denominator&quot;, 1);

List&lt;Argument&gt; arguments = new ArrayList&lt;&gt;();
arguments.add(numeratorArgument);
arguments.add(denominatorArgument);
</code></pre>
<pre><code class="language-kotlin Kotlin">// Declare arguments like normal
val numeratorArgument = IntegerArgument(&quot;numerator&quot;, 0)
val denominatorArgument = IntegerArgument(&quot;denominator&quot;, 1)

val arguments = listOf&lt;Argument&lt;*&gt;&gt;(numeratorArgument, denominatorArgument)
</code></pre>
</div>
<p>Now we're going to get into the very nitty-gritty part - the predicate declaration. First, we'll create some variables <code>numerator</code> and <code>denominator</code> to represent the brigadier instances of these arguments. This can be handled by using the <code>Brigadier.argBuildOf</code> function:</p>
<div class="multi-pre">
<pre><code class="language-java Java">ArgumentBuilder numerator = Brigadier.fromArgument(numeratorArgument);
ArgumentBuilder denominator = Brigadier.fromArgument(denominatorArgument)
</code></pre>
<pre><code class="language-kotlin Kotlin">val numerator = Brigadier.fromArgument(numeratorArgument)
val denominator = Brigadier.fromArgument(denominatorArgument)
</code></pre>
</div>
<p>Now we'll define our predicate. Since this is sort of a &quot;meta-command&quot; (it directly affects the outcome of the <code>run</code> command), we need to use the <code>ArgumentBuilder</code>'s <code>fork</code> method. Remember that after we run this predicate, we want to link back to <code>execute</code> again, so our first argument is the <code>CommandNode</code> for <code>execute</code>, which we can get using <code>Brigadier.getRootNode().getChild(&quot;execute&quot;)</code>. Then, we can simply use <code>Brigadier.fromPredicate</code> to finish our declaration:</p>
<div class="multi-pre">
<pre><code class="language-java Java">ArgumentBuilder denominator = Brigadier.fromArgument(denominatorArgument)
    // Fork redirecting to &quot;execute&quot; and state our predicate
    .fork(Brigadier.getRootNode().getChild(&quot;execute&quot;), Brigadier.fromPredicate((sender, args) -&gt; {
        // Parse arguments like normal
        int num = (int) args[0];
        int denom = (int) args[1];
        
        // Return boolean with a num/denom chance
        return Math.ceil(Math.random() * denom) &lt;= num;
    }, arguments));
</code></pre>
<pre><code class="language-kotlin Kotlin">val denominator = Brigadier.fromArgument(denominatorArgument)
    // Fork redirecting to &quot;execute&quot; and state our predicate
    .fork(Brigadier.getRootNode().getChild(&quot;execute&quot;), Brigadier.fromPredicate( { _: CommandSender, args -&gt;
        // Parse arguments like normal
        val num = (args[0] as Int).toDouble()
        val denom = (args[1] as Int).toDouble()

        // Return boolean with a num/denom chance
        Math.ceil(Math.random() * denom) &lt;= num
    }, arguments))
</code></pre>
</div>
<p>Finally, we can now link everything up. We know that <code>numerator</code> comes first, <strong>then</strong> <code>denominator</code>, so we have to have <code>numerator.then(denominator)</code>. We also know that these arguments are the <strong>children</strong> of the <code>randomChance</code> literal, so we use the following code to state all of this:</p>
<div class="multi-pre">
<pre><code class="language-java Java">// Add &lt;numerator&gt; &lt;denominator&gt; as a child of randomchance
randomChance.addChild(numerator.then(denominator).build());
</code></pre>
<pre><code class="language-kotlin Kotlin">// Add &lt;numerator&gt; &lt;denominator&gt; as a child of randomchance
randomChance.addChild(numerator.then(denominator).build())
</code></pre>
</div>
<p>Finally, we &quot;register&quot; the command. In this case, we're actually just adding the <code>randomChance</code> node under \(\texttt{execute}\rightarrow\texttt{if}\), which we can add using the following code:</p>
<div class="multi-pre">
<pre><code class="language-java Java">// Add (randomchance &lt;numerator&gt; &lt;denominator&gt;) as a child of (execute -&gt; if)
Brigadier.getRootNode().getChild(&quot;execute&quot;).getChild(&quot;if&quot;).addChild(randomChance);
</code></pre>
<pre><code class="language-kotlin Kotlin">// Add (randomchance &lt;numerator&gt; &lt;denominator&gt;) as a child of (execute -&gt; if)
Brigadier.getRootNode().getChild(&quot;execute&quot;).getChild(&quot;if&quot;).addChild(randomChance)
</code></pre>
</div>
<hr />
<h4 id="code-summary"><a class="header" href="#code-summary">Code summary</a></h4>
<p>So, hopefully that wasn't too confusing! If you're still lost, here's the whole code that we wrote:</p>
<div class="multi-pre">
<pre><code class="language-java Java">// Register literal &quot;randomchance&quot;
LiteralCommandNode randomChance = Brigadier.fromLiteralArgument(new LiteralArgument(&quot;randomchance&quot;)).build();

// Declare arguments like normal
Argument&lt;Integer&gt; numeratorArgument = new IntegerArgument(&quot;numerator&quot;, 0);
Argument&lt;Integer&gt; denominatorArgument = new IntegerArgument(&quot;denominator&quot;, 1);

List&lt;Argument&gt; arguments = new ArrayList&lt;&gt;();
arguments.add(numeratorArgument);
arguments.add(denominatorArgument);

// Get brigadier argument objects
ArgumentBuilder numerator = Brigadier.fromArgument(numeratorArgument);
ArgumentBuilder denominator = Brigadier.fromArgument(denominatorArgument)
    // Fork redirecting to &quot;execute&quot; and state our predicate
    .fork(Brigadier.getRootNode().getChild(&quot;execute&quot;), Brigadier.fromPredicate((sender, args) -&gt; {
        // Parse arguments like normal
        int num = (int) args[0];
        int denom = (int) args[1];
        
        // Return boolean with a num/denom chance
        return Math.ceil(Math.random() * denom) &lt;= num;
    }, arguments));

// Add &lt;numerator&gt; &lt;denominator&gt; as a child of randomchance
randomChance.addChild(numerator.then(denominator).build());

// Add (randomchance &lt;numerator&gt; &lt;denominator&gt;) as a child of (execute -&gt; if)
Brigadier.getRootNode().getChild(&quot;execute&quot;).getChild(&quot;if&quot;).addChild(randomChance);
</code></pre>
<pre><code class="language-kotlin Kotlin">// Register literal &quot;randomchance&quot;
val randomChance: LiteralCommandNode&lt;Any&gt; = Brigadier.fromLiteralArgument(LiteralArgument(&quot;randomchance&quot;)).build()

// Declare arguments like normal
val numeratorArgument = IntegerArgument(&quot;numerator&quot;, 0)
val denominatorArgument = IntegerArgument(&quot;denominator&quot;, 1)

val arguments = listOf&lt;Argument&lt;*&gt;&gt;(numeratorArgument, denominatorArgument)

// Get brigadier argument objects
val numerator = Brigadier.fromArgument(numeratorArgument)
val denominator = Brigadier.fromArgument(denominatorArgument)
    // Fork redirecting to &quot;execute&quot; and state our predicate
    .fork(Brigadier.getRootNode().getChild(&quot;execute&quot;), Brigadier.fromPredicate( { _: CommandSender, args -&gt;
        // Parse arguments like normal
        val num = (args[0] as Int).toDouble()
        val denom = (args[1] as Int).toDouble()

        // Return boolean with a num/denom chance
        Math.ceil(Math.random() * denom) &lt;= num
    }, arguments))

// Add &lt;numerator&gt; &lt;denominator&gt; as a child of randomchance
randomChance.addChild(numerator.then(denominator).build())

// Add (randomchance &lt;numerator&gt; &lt;denominator&gt;) as a child of (execute -&gt; if)
Brigadier.getRootNode().getChild(&quot;execute&quot;).getChild(&quot;if&quot;).addChild(randomChance)
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="brigadier-suggestions"><a class="header" href="#brigadier-suggestions">Brigadier Suggestions</a></h1>
<p>As described in <a href="./argumentsuggestions.html#the-argumentsuggestions-interface">The ArgumentSuggestions interface</a>, the <code>ArgumentSuggestions</code> interface has the following default method:</p>
<pre><code class="language-java">@FunctionalInterface
public interface ArgumentSuggestions&lt;CommandSender&gt; {

    /**
     * Create a {@link CompletableFuture} resolving onto a brigadier {@link Suggestions} object.
     * @param info The suggestions info
     * @param builder The Brigadier {@link SuggestionsBuilder} object
     * @return a {@link CompletableFuture} resolving onto a brigadier {@link Suggestions} object.
     *
     * @throws CommandSyntaxException if there is an error making suggestions
     */
    CompletableFuture&lt;Suggestions&gt; suggest(SuggestionInfo&lt;CommandSender&gt; info, SuggestionsBuilder builder)
        throws CommandSyntaxException;

}
</code></pre>
<p>This allows you to use Brigadier's <code>SuggestionsBuilder</code> and <code>Suggestions</code> classes to create more powerful suggestions beyond the basic capabilities of the CommandAPI.</p>
<p>In order to use this, you will need the Brigadier dependency, which you can find under the <a href="https://github.com/Mojang/brigadier#installation">Brigadier installation instructions</a>.</p>
<div class="example">
<h3 id="example---making-an-emoji-broadcasting-message"><a class="header" href="#example---making-an-emoji-broadcasting-message">Example - Making an emoji broadcasting message</a></h3>
<p>Say we want to let users broadcast a message, but also allow them to enter emojis into the message they're typing:</p>
<p><img src="./images/emojimsg.gif" alt="A gif showcasing a command where emojis are suggested when typing a message" /></p>
<p>For this command, we'll use a <code>GreedyStringArgument</code> as if we were making a generic broadcasted message. We create a map of emojis to their descriptions to use as tooltips and then we use Brigadier to display the suggestions at the end of the message where the cursor is.</p>
<div class="multi-pre">
<pre><code class="language-java Java">Map&lt;String, String&gt; emojis = new HashMap&lt;&gt;();
emojis.put(&quot;☻&quot;, &quot;smile&quot;);
emojis.put(&quot;❤&quot;, &quot;heart&quot;);
emojis.put(&quot;🔥&quot;, &quot;fire&quot;);
emojis.put(&quot;★&quot;, &quot;star&quot;);
emojis.put(&quot;☠&quot;, &quot;death&quot;);
emojis.put(&quot;⚠&quot;, &quot;warning&quot;);
emojis.put(&quot;☀&quot;, &quot;sun&quot;);
emojis.put(&quot;☺&quot;, &quot;smile&quot;);
emojis.put(&quot;☹&quot;, &quot;frown&quot;);
emojis.put(&quot;✉&quot;, &quot;mail&quot;);
emojis.put(&quot;☂&quot;, &quot;umbrella&quot;);
emojis.put(&quot;✘&quot;, &quot;cross&quot;);
emojis.put(&quot;♪&quot;, &quot;music note (eighth)&quot;);
emojis.put(&quot;♬&quot;, &quot;music note (beamed sixteenth)&quot;);
emojis.put(&quot;♩&quot;, &quot;music note (quarter)&quot;);
emojis.put(&quot;♫&quot;, &quot;music note (beamed eighth)&quot;);
emojis.put(&quot;☄&quot;, &quot;comet&quot;);
emojis.put(&quot;✦&quot;, &quot;star&quot;);
emojis.put(&quot;🗡&quot;, &quot;sword&quot;);
emojis.put(&quot;🪓&quot;, &quot;axe&quot;);
emojis.put(&quot;🔱&quot;, &quot;trident&quot;);
emojis.put(&quot;🎣&quot;, &quot;fishing rod&quot;);
emojis.put(&quot;🏹&quot;, &quot;bow&quot;);
emojis.put(&quot;⛏&quot;, &quot;pickaxe&quot;);
emojis.put(&quot;🍖&quot;, &quot;food&quot;);

Argument&lt;String&gt; messageArgument = new GreedyStringArgument(&quot;message&quot;)
    .replaceSuggestions((info, builder) -&gt; {
        // Only display suggestions at the very end character
        builder = builder.createOffset(builder.getStart() + info.currentArg().length());

        // Suggest all the emojis!
        for (Entry&lt;String, String&gt; str : emojis.entrySet()) {
            builder.suggest(str.getKey(), new LiteralMessage(str.getValue()));
        }

        return builder.buildFuture();
    });

new CommandAPICommand(&quot;emoji&quot;)
    .withArguments(messageArgument)
    .executes((sender, args) -&gt; {
        Bukkit.broadcastMessage((String) args.get(&quot;message&quot;));
    })
    .register();
</code></pre>
<pre><code class="language-kotlin Kotlin">val emojis = mapOf(
    &quot;☻&quot; to &quot;smile&quot;,
    &quot;❤&quot; to &quot;heart&quot;,
    &quot;🔥&quot; to &quot;fire&quot;,
    &quot;★&quot; to &quot;star&quot;,
    &quot;☠&quot; to &quot;death&quot;,
    &quot;⚠&quot; to &quot;warning&quot;,
    &quot;☀&quot; to &quot;sun&quot;,
    &quot;☺&quot; to &quot;smile&quot;,
    &quot;☹&quot; to &quot;frown&quot;,
    &quot;✉&quot; to &quot;mail&quot;,
    &quot;☂&quot; to &quot;umbrella&quot;,
    &quot;✘&quot; to &quot;cross&quot;,
    &quot;♪&quot; to &quot;music note (eighth)&quot;,
    &quot;♬&quot; to &quot;music note (beamed sixteenth)&quot;,
    &quot;♩&quot; to &quot;music note (quarter)&quot;,
    &quot;♫&quot; to &quot;music note (beamed eighth)&quot;,
    &quot;☄&quot; to &quot;comet&quot;,
    &quot;✦&quot; to &quot;star&quot;,
    &quot;🗡&quot; to &quot;sword&quot;,
    &quot;🪓&quot; to &quot;axe&quot;,
    &quot;🔱&quot; to &quot;trident&quot;,
    &quot;🎣&quot; to &quot;fishing rod&quot;,
    &quot;🏹&quot; to &quot;bow&quot;,
    &quot;⛏&quot; to &quot;pickaxe&quot;,
    &quot;🍖&quot; to &quot;food&quot;
)

val messageArgument = GreedyStringArgument(&quot;message&quot;)
    .replaceSuggestions { info, builder -&gt;
        // Only display suggestions at the very end character
        val newBuilder = builder.createOffset(builder.start + info.currentArg().length)

        // Suggest all the emojis!
        emojis.forEach { (emoji, description) -&gt;
            newBuilder.suggest(emoji, LiteralMessage(description))
        }

        newBuilder.buildFuture()
    }

CommandAPICommand(&quot;emoji&quot;)
    .withArguments(messageArgument)
    .executes(CommandExecutor { _, args -&gt;
        Bukkit.broadcastMessage(args[&quot;message&quot;] as String)
    })
    .register()
</code></pre>
</div>
<p>In this example, we simply create the <code>GreedyStringArgument</code> and use <code>replaceSuggestions()</code> to specify our suggestion rules. We create an offset using the current builder to make suggestions start at the last character (the current builder start <code>builder.getStart()</code> and the current length of what the user has already typed <code>info.currentArg().length()</code>). Finally, we build the suggestions with <code>builder.buildFuture()</code> and then register our command as normal.</p>
</div>
<div class="example">
<h3 id="example---using-a-minecraft-command-as-an-argument"><a class="header" href="#example---using-a-minecraft-command-as-an-argument">Example - Using a Minecraft command as an argument</a></h3>
<blockquote>
<p><strong>Developer's Note:</strong></p>
<p>This example has been superseded by the <a href="./argument_command.html">Command argument</a>. This example is still present as it gives an example of much more complicated brigadier suggestions which may be useful for readers!</p>
</blockquote>
<p>Courtesy of <a href="https://github.com/469512345">469512345</a>, the following example shows how using Brigadier's suggestions and parser can be combined with the CommandAPI to create an argument which suggests valid Minecraft commands. This could be used for example as a <code>sudo</code> command, to run a command as another player.</p>
<p><img src="./images/commandargument.gif" alt="A gif showcasing a command suggestion for the /give command" /></p>
<p>For this command, we'll use a <code>GreedyStringArgument</code> because that allows users to enter any combination of characters (which therefore, allows users to enter any command). First, we start by defining the suggestions that we'll use for the <code>GreedyStringArgument</code>. We'll use the <code>ArgumentSuggestions</code> functional interface described above:</p>
<div class="multi-pre">
<pre><code class="language-java Java">ArgumentSuggestions&lt;CommandSender&gt; commandSuggestions = (info, builder) -&gt; {
    // The current argument, which is a full command
    String arg = info.currentArg();

    // Identify the position of the current argument
    int start;
    if (arg.contains(&quot; &quot;)) {
        // Current argument contains spaces - it starts after the last space and after the start of this argument.
        start = builder.getStart() + arg.lastIndexOf(' ') + 1;
    } else {
        // Input starts at the start of this argument
        start = builder.getStart();
    }
    
    // Parse command using brigadier
    ParseResults&lt;?&gt; parseResults = Brigadier.getCommandDispatcher()
        .parse(info.currentArg(), Brigadier.getBrigadierSourceFromCommandSender(info.sender()));
    
    // Intercept any parsing errors indicating an invalid command
    if(!parseResults.getExceptions().isEmpty()) {
        CommandSyntaxException exception = parseResults.getExceptions().values().iterator().next();
        // Raise the error, with the cursor offset to line up with the argument
        throw new CommandSyntaxException(exception.getType(), exception.getRawMessage(), exception.getInput(), exception.getCursor() + start);
    }

    return Brigadier
        .getCommandDispatcher()
        .getCompletionSuggestions(parseResults)
        .thenApply(suggestionsObject -&gt; {
            // Brigadier's suggestions
            Suggestions suggestions = (Suggestions) suggestionsObject;

            return new Suggestions(
                // Offset the index range of the suggestions by the start of the current argument
                new StringRange(start, start + suggestions.getRange().getLength()),
                // Copy the suggestions
                suggestions.getList()
            );
        });
};
</code></pre>
<pre><code class="language-kotlin Kotlin">val commandSuggestions: ArgumentSuggestions&lt;CommandSender&gt; = ArgumentSuggestions { info, builder -&gt;
    // The current argument, which is a full command
    val arg: String = info.currentArg()

    // Identify the position of the current argument
    var start = if (arg.contains(&quot; &quot;)) {
        // Current argument contains spaces - it starts after the last space and after the start of this argument.
        builder.start + arg.lastIndexOf(' ') + 1
    } else {
        // Input starts at the start of this argument
        builder.start
    }

    // Parse command using brigadier
    val parseResults: ParseResults&lt;*&gt; = Brigadier.getCommandDispatcher()
        .parse(info.currentArg(), Brigadier.getBrigadierSourceFromCommandSender(info.sender))

    // Intercept any parsing errors indicating an invalid command
    for ((_, exception) in parseResults.exceptions) {
        // Raise the error, with the cursor offset to line up with the argument
        throw CommandSyntaxException(exception.type, exception.rawMessage, exception.input, exception.cursor + start)
    }

    val completableFutureSuggestions: CompletableFuture&lt;Suggestions&gt; =
        Brigadier.getCommandDispatcher().getCompletionSuggestions(parseResults) as CompletableFuture&lt;Suggestions&gt;

    completableFutureSuggestions.thenApply { suggestions: Suggestions -&gt;
        Suggestions(
            // Offset the index range of the suggestions by the start of the current argument
            StringRange(start, start + suggestions.range.length),
            // Copy the suggestions
            suggestions.list
        )
    }
}
</code></pre>
</div>
<p>There's a lot to unpack there, but it's generally split up into 4 key sections:</p>
<ul>
<li>
<p><strong>Finding the start of the argument</strong>. We find the start of the argument so we know where the beginning of our command suggestion is. This is done easily using <code>builder.getStart()</code>, but we also have to take into account any spaces if our command argument contains spaces.</p>
</li>
<li>
<p><strong>Parsing the command argument</strong>. We make use of Brigadier's <code>parse()</code> method to parse the argument and generate some <code>ParseResults</code>.</p>
</li>
<li>
<p><strong>Reporting parsing errors</strong>. This is actually an optional step, but in general it's good practice to handle exceptions stored in <code>ParseResults</code>. While <a href="https://github.com/Mojang/brigadier/blob/master/src/main/java/com/mojang/brigadier/CommandDispatcher.java#L599">Brigadier doesn't actually handle suggestion exceptions</a>, this has been included in this example to showcase exception handling.</p>
</li>
<li>
<p><strong>Generating suggestions from parse results</strong>. We use our parse results with Brigadier's <code>getCompletionSuggestions()</code> method to generate some suggestions based on the parse results and the suggestion string range.</p>
</li>
</ul>
<p>Now that we've declared our arguments suggestions, we can then create our simple command with the following syntax:</p>
<pre><code class="language-mccmd">/commandargument &lt;command&gt;
</code></pre>
<p>We use the command suggestions declared above by using the <code>replaceSuggestions</code> method in our <code>GreedyStringArgument</code>, and write a simple executor which runs the command that the user provided:</p>
<div class="multi-pre">
<pre><code class="language-java Java">new CommandAPICommand(&quot;commandargument&quot;)
    .withArguments(new GreedyStringArgument(&quot;command&quot;).replaceSuggestions(commandSuggestions))
    .executes((sender, args) -&gt; {
        // Run the command using Bukkit.dispatchCommand()
        Bukkit.dispatchCommand(sender, (String) args.get(&quot;command&quot;));
    }).register();
</code></pre>
<pre><code class="language-kotlin Kotlin">CommandAPICommand(&quot;commandargument&quot;)
    .withArguments(GreedyStringArgument(&quot;command&quot;).replaceSuggestions(commandSuggestions))
    .executes(CommandExecutor { sender, args -&gt;
        // Run the command using Bukkit.dispatchCommand()
        Bukkit.dispatchCommand(sender, args[&quot;command&quot;] as String)
    })
    .register()
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="predicate-tips"><a class="header" href="#predicate-tips">Predicate tips</a></h1>
<p>In our <a href="./requirements.html#example---a-party-creation-and-teleportation-system">example for creating a party system</a>, we ended up having lots of code repetition. In our party creation command, we had the following code:</p>
<div class="multi-pre">
<pre><code class="language-java Java">List&lt;Argument&lt;?&gt;&gt; arguments = new ArrayList&lt;&gt;();

// The &quot;create&quot; literal, with a requirement that a player must have a party
arguments.add(new LiteralArgument(&quot;create&quot;)
    .withRequirement(sender -&gt; !partyMembers.containsKey(((Player) sender).getUniqueId()))
);

arguments.add(new StringArgument(&quot;partyName&quot;));
</code></pre>
<pre><code class="language-kotlin Kotlin">var arguments = mutableListOf&lt;Argument&lt;*&gt;&gt;()

// The &quot;create&quot; literal, with a requirement that a player must have a party
arguments.add(LiteralArgument(&quot;create&quot;)
    .withRequirement { !partyMembers.containsKey((it as Player).uniqueId) }
)

arguments.add(StringArgument(&quot;partyName&quot;))
</code></pre>
</div>
<p>And for our party teleportation command, we had the following code:</p>
<div class="multi-pre">
<pre><code class="language-java Java">arguments = new ArrayList&lt;&gt;();
arguments.add(new LiteralArgument(&quot;tp&quot;)
    .withRequirement(sender -&gt; partyMembers.containsKey(((Player) sender).getUniqueId()))
);
</code></pre>
<pre><code class="language-kotlin Kotlin">arguments = mutableListOf&lt;Argument&lt;*&gt;&gt;()
arguments.add(LiteralArgument(&quot;tp&quot;)
    .withRequirement { partyMembers.containsKey((it as Player).uniqueId) })
</code></pre>
</div>
<p>We can simplify this code by declaring the predicate:</p>
<div class="multi-pre">
<pre><code class="language-java Java">Predicate&lt;CommandSender&gt; testIfPlayerHasParty = sender -&gt; {
    return partyMembers.containsKey(((Player) sender).getUniqueId());
};
</code></pre>
<pre><code class="language-kotlin Kotlin">val testIfPlayerHasParty = Predicate { sender: CommandSender -&gt;
    partyMembers.containsKey((sender as Player).uniqueId)
}
</code></pre>
</div>
<p>Now, we can use the predicate <code>testIfPlayerHasParty</code> in our code for creating a party. Since we want to apply the &quot;not&quot; (<code>!</code>) operator to this predicate, we can use <code>.negate()</code> to invert the result of our predicate:</p>
<div class="multi-pre">
<pre><code class="language-java Java">List&lt;Argument&lt;?&gt;&gt; args = new ArrayList&lt;&gt;();
args.add(new LiteralArgument(&quot;create&quot;).withRequirement(testIfPlayerHasParty.negate()));
args.add(new StringArgument(&quot;partyName&quot;));
</code></pre>
<pre><code class="language-kotlin Kotlin">var args = listOf&lt;Argument&lt;*&gt;&gt;(
    LiteralArgument(&quot;create&quot;).withRequirement(testIfPlayerHasParty.negate()),
    StringArgument(&quot;partyName&quot;)
)
</code></pre>
</div>
<p>And we can use it again for our code for teleporting to party members:</p>
<div class="multi-pre">
<pre><code class="language-java Java">args = new ArrayList&lt;&gt;();
args.add(new LiteralArgument(&quot;tp&quot;).withRequirement(testIfPlayerHasParty));
</code></pre>
<pre><code class="language-kotlin Kotlin">args = listOf&lt;Argument&lt;*&gt;&gt;(LiteralArgument(&quot;tp&quot;).withRequirement(testIfPlayerHasParty))
</code></pre>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h1>
<blockquote>
<p><strong>Dev note:</strong></p>
<p>Coming soon! In this section, I'll outline how to get started with building and contributing to the CommandAPI.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h1>
<p>The CommandAPI is a relatively large project (especially from the standpoint of one guy, because the CommandAPI was written by just one guy in their spare time!) and trying to figure out what everything does is a nightmare without some guidance. I've always felt that other community project structures aren't well documented and contributing to them can be daunting. Here's the CommandAPI's project structure for you!</p>
<hr />
<h2 id="commandapi-submodule-folders"><a class="header" href="#commandapi-submodule-folders">CommandAPI submodule folders</a></h2>
<p>This is where all of the code is for the CommandAPI. The CommandAPI is a Maven project with multiple modules which each serve a different purpose:</p>
<ul>
<li>
<p><code>commandapi-preprocessor</code> - The CommandAPI uses a bit of reflection to perform things which could not normally be done (for example, allowing custom commands in datapacks). Reflection is inherently unsafe and can lead to runtime errors if specific fields or methods are not present. The CommandAPI preprocessor project is a source annotation processor that checks all declared reflection calls and looks up at compile-time whether those calls are possible - if not, it prevents the CommandAPI from building. In short, it's a compile-time reflection checker.</p>
</li>
<li>
<p><code>commandapi-x.x.x</code> - The CommandAPI needs to access various NMS methods in order to operate. These are implemented for the specific version given by <code>x.x.x</code>. For example, to support Minecraft <code>1.16.5</code>, the project is <code>commandapi-1.16.5</code>. The <code>NMS</code> class implementation is done in these version-specific files.</p>
</li>
<li>
<p><code>commandapi-core</code> - The main brains of the CommandAPI. This includes both the code that makes the CommandAPI run, as well as the API which developers can use.</p>
</li>
<li>
<p><code>commandapi-vh</code> - The CommandAPI version handler. This is a super tiny project which simply links up all of the NMS version-specific files into the CommandAPI. This is only used for the actual running of the CommandAPI (e.g. the CommandAPI plugin or shading the CommandAPI). This ensures proper compile-time safety of NMS implementations.</p>
</li>
<li>
<p><code>commandapi-plugin</code> - It's the CommandAPI plugin! This is the project which is used for releases to both GitHub and Spigot. It's the CommandAPI all in one neat package, with a few extra features such as config-based command conversion for server owners (or other non-developers)</p>
</li>
<li>
<p><code>commandapi-shade</code> - It's the CommandAPI, but in shade-able format. It has none of the features of the CommandAPI plugin variant and can be shaded into your own plugins. Effectively, it's <code>commandapi-core</code> + <code>commandapi-vh</code> with all of the <code>commandapi-x.x.x</code> NMS implementations included.</p>
</li>
<li>
<p><code>commandapi-annotations</code> - The CommandAPI annotations project is a small compile-time annotation processer that writes CommandAPI code for you. Using a compile-time annotation processor makes the server run so much faster than using a runtime-annotation processor, because annotation processing requires reflection to inspect class metadata.</p>
</li>
</ul>
<h2 id="docs-folder"><a class="header" href="#docs-folder"><code>docs</code> folder</a></h2>
<p>This is where all of the lovely documentation, JavaDocs and the CommandAPI homepage is stored. Everything in this folder is automatically hosted on GitHub using GitHub Pages - this is the live stuff. Key things in this folder:</p>
<ul>
<li>
<p><code>javadocs</code> - It's the JavaDocs! This is built using Doxygen with the configuration in the root of this project (See the <code>Doxyfile</code>). I also serve a custom version of Mojang's Brigadier library which was written by <a href="https://github.com/I-Al-Istannen/brigadier">I-Al-Istannen</a> because this person spent a lot of time and effort producing JavaDocs for Brigadier when Mojang didn't bother. This person deserves a lot of respect - their work is amazing!</p>
</li>
<li>
<p><code>index.html</code> - It's the CommandAPI's homepage! It's not anything especially amazing - it's a very very simple static webpage with links - that's all that it needs to be. Every update, this file needs to be edited manually to update all of the links.</p>
</li>
</ul>
<h2 id="docssrc-folder"><a class="header" href="#docssrc-folder"><code>docssrc</code> folder</a></h2>
<p>This is the brains behind the documentation. It's a collection of Markdown files which form the CommandAPI documentation and is built using <a href="https://github.com/rust-lang/mdBook">mdBook</a>. For the CommandAPI in particular, it is actually built using my own custom fork of mdBook (<a href="https://github.com/JorelAli/mdBook/tree/fa5">here, in the fa5 branch</a>) which incorporates <a href="https://github.com/rust-lang/mdBook/pull/1225">this pull request</a> which adds support for FontAwesome 5.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="upgrading-guide"><a class="header" href="#upgrading-guide">Upgrading guide</a></h1>
<h2 id="from-920-to-930"><a class="header" href="#from-920-to-930">From 9.2.0 to 9.3.0</a></h2>
<p>The <code>BukkitTooltip.generateAdvenureComponents</code> methods have now been deprecated in favour of the correctly named <code>BukkitTooltip.generateAdventureComponents</code> methods:</p>
<div class="multi-pre">
<pre><code class="language-java 9.2.0">BukkitTooltip.generateAdvenureComponents()
</code></pre>
</div>
<p>$$\downarrow$$</p>
<div class="multi-pre">
<pre><code class="language-java 9.3.0">BukkitTooltip.generateAdventureComponents()
</code></pre>
</div>
<hr />
<h2 id="from-903-to-910"><a class="header" href="#from-903-to-910">From 9.0.3 to 9.1.0</a></h2>
<h3 id="multiliteralargument-changes"><a class="header" href="#multiliteralargument-changes">MultiLiteralArgument changes</a></h3>
<p>All <code>MultiLiteralArgument</code> constructors have been deprecated in 9.1.0! Instead the new <code>MultiLiteralArgument</code> constructor should be used:</p>
<div class="multi-pre">
<pre><code class="language-java 9.0.3">withArguments(new MultiLiteralArgument(&quot;gamemodes&quot;, List.of(&quot;survival&quot;, &quot;creative&quot;, &quot;adventure&quot;, &quot;spectator&quot;)))
</code></pre>
</div>
<p>$$\downarrow$$</p>
<div class="multi-pre">
<pre><code class="language-java 9.1.0">withArguments(new MultiLiteralArgument(&quot;gamemodes&quot;, &quot;survival&quot;, &quot;creative&quot;, &quot;adventure&quot;, &quot;spectator&quot;))
</code></pre>
</div>
<h3 id="commandarguments-changes"><a class="header" href="#commandarguments-changes">CommandArguments changes</a></h3>
<p>For 9.1.0 all deprecated methods are no longer deprecated. To learn about all the methods now available, refer to the <a href="./commandarguments.html">CommandArguments</a> page.</p>
<hr />
<h2 id="from-901-to-902"><a class="header" href="#from-901-to-902">From 9.0.1 to 9.0.2</a></h2>
<h3 id="multiliteralargument-and-literalargument-changes"><a class="header" href="#multiliteralargument-and-literalargument-changes">MultiLiteralArgument and LiteralArgument changes</a></h3>
<p>In previous versions, the ability has been introduced to access arguments by their node names. However, while this was possible for every other argument, it wasn't possible for <code>MultiLiteralArgument</code>s. This was now changed because the values from the <code>MultiLiteralArgument</code> are included in the <a href="./commandarguments.html"><code>CommandArguments</code></a> of a command.</p>
<p>Therefore, the current constructor has been deprecated and the new one should be used:</p>
<div class="multi-pre">
<pre><code class="language-java 9.0.1">withArguments(new MultiLiteralArgument(&quot;survival&quot;, &quot;creative&quot;, &quot;adventure&quot;, &quot;spectator&quot;))
</code></pre>
</div>
<p>$$\downarrow$$</p>
<div class="multi-pre">
<pre><code class="language-java 9.0.2">withArguments(new MultiLiteralArgument(&quot;gamemodes&quot;, List.of(&quot;survival&quot;, &quot;creative&quot;, &quot;adventure&quot;, &quot;spectator&quot;)))
</code></pre>
</div>
<p>Because it is possible to list <code>LiteralArgument</code>s in the <a href="./commandarguments.html"><code>CommandArguments</code></a> of a command, there was also an additional constructor add to the <code>LiteralArgument</code> class. The other one is not deprecated.</p>
<p>Now, the <code>LiteralArgument</code> class contains two possible constructors:</p>
<pre><code class="language-java">public LiteralArgument(String literal) // Recommended if the literal is not listed
public LiteralArgument(String nodeName, String literal)
</code></pre>
<hr />
<h2 id="from-900-to-901"><a class="header" href="#from-900-to-901">From 9.0.0 to 9.0.1</a></h2>
<h3 id="customargumentexception-changes"><a class="header" href="#customargumentexception-changes">CustomArgumentException changes</a></h3>
<p>For 9.0.1, the <code>CustomArgumentException</code> constructors have been deprecated and should no longer be used. Instead, use the <code>CustomArgumentException</code> static factory methods:</p>
<div class="multi-pre">
<pre><code class="language-java 9.0.0">throw new CustomArgumentException(new MessageBuilder(...));
throw new CustomArgumentException(&quot;Error message&quot;);
</code></pre>
</div>
<p>$$\downarrow$$</p>
<div class="multi-pre">
<pre><code class="language-java 9.0.1">throw CustomArgumentException.fromMessageBuilder(new MessageBuilder(...));
throw CustomArgumentException.fromString(&quot;Error message&quot;);
</code></pre>
</div>
<h3 id="commandarguments-changes-1"><a class="header" href="#commandarguments-changes-1">CommandArguments changes</a></h3>
<p>For 9.0.1 the various <code>CommandArguments#getOrDefault()</code> and <code>CommandArguments#getOrDefaultUnchecked()</code> have been deprecated and should no longer be used. Instead, use the <code>CommandArguments#getOptional()</code> and <code>CommandArguments#getOptionalUnchecked()</code> methods:</p>
<div class="multi-pre">
<pre><code class="language-java 9.0.0_(Not_using_unchecked)">new CommandAPICommand(&quot;mycommand&quot;)
    .withOptionalArguments(new StringArgument(&quot;string&quot;))
    .executes((sender, args) -&gt; {
        String string = (String) args.getOrDefault(&quot;string&quot;, &quot;Default Value&quot;);
    })
    .register();
</code></pre>
<pre><code class="language-java 9.0.0_(Using_unchecked)">new CommandAPICommand(&quot;mycommand&quot;)
    .withOptionalArguments(new StringArgument(&quot;string&quot;))
    .executes((sender, args) -&gt; {
        String string = args.getOrDefaultUnchecked(&quot;string&quot;, &quot;Default Value&quot;);
    })
    .register();
</code></pre>
</div>
<p>$$\downarrow$$</p>
<div class="multi-pre">
<pre><code class="language-java 9.0.1_(Not_using_unchecked)">new CommandAPICommand(&quot;mycommand&quot;)
    .withOptionalArguments(new StringArgument(&quot;string&quot;))
    .executes((sender, args) -&gt; {
        String string = (String) args.getOptional(&quot;string&quot;).orElse(&quot;Default Value&quot;);
    })
    .register();
</code></pre>
<pre><code class="language-java 9.0.1_(Using_unchecked)">new CommandAPICommand(&quot;mycommand&quot;)
    .withOptionalArguments(new StringArgument(&quot;string&quot;))
    .executes((sender, args) -&gt; {
        String string = args.getOptionalUnchecked(&quot;string&quot;).orElse(&quot;Default Value&quot;);
    })
    .register();
</code></pre>
</div>
<hr />
<h2 id="from-88x-to-900"><a class="header" href="#from-88x-to-900">From 8.8.x to 9.0.0</a></h2>
<p>CommandAPI 9.0.0 is arguably the biggest change in the CommandAPI's project structure and usage. This update was designed to allow the CommandAPI to be generalized for other platforms (e.g. Velocity, Fabric, Sponge), and as a result <strong>this update is incompatible with previous versions of the CommandAPI</strong>.</p>
<p>All deprecated methods from 8.8.x have been removed in this update. Please ensure that you use the relevant replacement methods (these are described in the JavaDocs for the various deprecated methods) before upgrading to 9.0.0.</p>
<hr />
<h3 id="project-dependencies"><a class="header" href="#project-dependencies">Project dependencies</a></h3>
<p>For Bukkit/Spigot/Paper plugins, the <code>commandapi-core</code> and <code>commandapi-shade</code> modules should no longer be used. Instead, use the new <code>commandapi-bukkit-core</code> and <code>commandapi-bukkit-shade</code> modules:</p>
<div class="linked-multi-pre">
<pre><code class="language-xml Maven">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;dev.jorel&lt;/groupId&gt;
        &lt;artifactId&gt;commandapi-core&lt;/artifactId&gt;
        &lt;version&gt;9.0.0&lt;/version&gt;
        &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<pre><code class="language-xml Maven_(shaded)">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;dev.jorel&lt;/groupId&gt;
        &lt;artifactId&gt;commandapi-shade&lt;/artifactId&gt;
        &lt;version&gt;9.0.0&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<pre><code class="language-gradle Gradle">dependencies {
    compileOnly &quot;dev.jorel:commandapi-core:9.0.0&quot;
}
</code></pre>
<pre><code class="language-kotlin Kotlin_Gradle">dependencies {
    compileOnly(&quot;dev.jorel:commandapi-core:9.0.0&quot;)
}
</code></pre>
<pre><code class="language-gradle Gradle_(shaded)">dependencies {
    implementation &quot;dev.jorel:commandapi-shade:9.0.0&quot;
}
</code></pre>
<pre><code class="language-kotlin Kotlin_Gradle_(shaded)">dependencies {
    implementation(&quot;dev.jorel:commandapi-shade:9.0.0&quot;)
}
</code></pre>
<p>$$\downarrow$$</p>
<pre><code class="language-xml Maven">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;dev.jorel&lt;/groupId&gt;
        &lt;artifactId&gt;commandapi-bukkit-core&lt;/artifactId&gt;
        &lt;version&gt;9.0.0&lt;/version&gt;
        &lt;scope&gt;provided&lt;/scope&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<pre><code class="language-xml Maven_(shaded)">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;dev.jorel&lt;/groupId&gt;
        &lt;artifactId&gt;commandapi-bukkit-shade&lt;/artifactId&gt;
        &lt;version&gt;9.0.0&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<pre><code class="language-gradle Gradle">dependencies {
    compileOnly &quot;dev.jorel:commandapi-bukkit-core:9.0.0&quot;
}
</code></pre>
<pre><code class="language-kotlin Kotlin_Gradle">dependencies {
    compileOnly(&quot;dev.jorel:commandapi-bukkit-core:9.0.0&quot;)
}
</code></pre>
<pre><code class="language-gradle Gradle_(shaded)">dependencies {
    implementation &quot;dev.jorel:commandapi-bukkit-shade:9.0.0&quot;
}
</code></pre>
<pre><code class="language-kotlin Kotlin_Gradle_(shaded)">dependencies {
    implementation(&quot;dev.jorel:commandapi-bukkit-shade:9.0.0&quot;)
}
</code></pre>
</div>
<p>Additionally, when using the Kotlin DSL for Bukkit, instead of using <code>commandapi-kotlin</code>, use <code>commandapi-bukkit-kotlin</code>:</p>
<div class="linked-multi-pre">
<pre><code class="language-xml Maven">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;dev.jorel&lt;/groupId&gt;
        &lt;artifactId&gt;commandapi-kotlin&lt;/artifactId&gt;
        &lt;version&gt;9.0.0&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<pre><code class="language-gradle Gradle">dependencies {
    implementation &quot;dev.jorel:commandapi-kotlin:9.0.0&quot;
}
</code></pre>
<pre><code class="language-kotlin Kotlin_Gradle">dependencies {
    implementation(&quot;dev.jorel:commandapi-kotlin:9.0.0&quot;)
}
</code></pre>
<p>$$\downarrow$$</p>
<pre><code class="language-xml Maven">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;dev.jorel&lt;/groupId&gt;
        &lt;artifactId&gt;commandapi-bukkit-kotlin&lt;/artifactId&gt;
        &lt;version&gt;9.0.0&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<pre><code class="language-gradle Gradle">dependencies {
    implementation &quot;dev.jorel:commandapi-bukkit-kotlin:9.0.0&quot;
}
</code></pre>
<pre><code class="language-kotlin Kotlin_Gradle">dependencies {
    implementation(&quot;dev.jorel:commandapi-bukkit-kotlin:9.0.0&quot;)
}
</code></pre>
</div>
<hr />
<h3 id="loading-and-enabling-the-commandapi-when-shading"><a class="header" href="#loading-and-enabling-the-commandapi-when-shading">Loading and enabling the CommandAPI when shading</a></h3>
<p>The <code>CommandAPI.onLoad()</code> method has changed in this update. Instead of using the <code>CommandAPIConfig</code> object, use the <code>CommandAPIBukkitConfig</code> and pass in the current plugin reference (<code>this</code>).</p>
<p>and <code>CommandAPI.onEnable()</code> method has also changed, and now no longer requires the plugin reference (<code>this</code>), as it is now included in <code>CommandAPI.onLoad()</code> instead.:</p>
<div class="multi-pre">
<pre><code class="language-java 8.8.x">public void onLoad() {
    CommandAPI.onLoad(new CommandAPIConfig());
}

public void onEnable() {
    CommandAPI.onEnable(this);
}
</code></pre>
</div>
<p>$$\downarrow$$</p>
<div class="multi-pre">
<pre><code class="language-java 9.0.0">public void onLoad() {
    CommandAPI.onLoad(new CommandAPIBukkitConfig(this));
}

public void onEnable() {
    CommandAPI.onEnable();
}
</code></pre>
</div>
<hr />
<h3 id="accessing-arguments"><a class="header" href="#accessing-arguments">Accessing arguments</a></h3>
<p>Arguments for commands are no longer an <code>Object[]</code> and have now been replaced with a more powerful <code>CommandArguments</code> object. This object now lets you access arguments in a number of ways:</p>
<h4 id="using-the-argsgetint-method"><a class="header" href="#using-the-argsgetint-method">Using the <code>args.get(int)</code> method</a></h4>
<p>If you're in a rush and just want to upgrade quickly, call the <code>.get(int)</code> method instead of accessing the arguments using the array access notation:</p>
<div class="multi-pre">
<pre><code class="language-java 8.8.x">new CommandAPICommand(&quot;cmd&quot;)
    .withArguments(new StringArgument(&quot;mystring&quot;))
    .withArguments(new PotionEffectArgument(&quot;mypotion&quot;))
    .withArguments(new LocationArgument(&quot;mylocation&quot;))
    .executes((sender, args) -&gt; {
        String stringArg = (String) args[0];
        PotionEffectType potionArg = (PotionEffectType) args[1];
        Location locationArg = (Location) args[2];
    })
    .register();
</code></pre>
</div>
<p>$$\downarrow$$</p>
<div class="multi-pre">
<pre><code class="language-java 9.0.0">new CommandAPICommand(&quot;cmd&quot;)
    .withArguments(new StringArgument(&quot;mystring&quot;))
    .withArguments(new PotionEffectArgument(&quot;mypotion&quot;))
    .withArguments(new LocationArgument(&quot;mylocation&quot;))
    .executes((sender, args) -&gt; {
        String stringArg = (String) args.get(0);
        PotionEffectType potionArg = (PotionEffectType) args.get(1);
        Location locationArg = (Location) args.get(2);
    })
    .register();
</code></pre>
</div>
<h4 id="using-the-argsgetstring-method-recommended"><a class="header" href="#using-the-argsgetstring-method-recommended">Using the <code>args.get(String)</code> method <em>(recommended)</em></a></h4>
<p>The CommandAPI introduces a new <code>args.get(String)</code> method to access arguments using the argument node name. This method also makes your code much more compatible with optional arguments:</p>
<div class="multi-pre">
<pre><code class="language-java 8.8.x">new CommandAPICommand(&quot;cmd&quot;)
    .withArguments(new StringArgument(&quot;mystring&quot;))
    .withArguments(new PotionEffectArgument(&quot;mypotion&quot;))
    .withArguments(new LocationArgument(&quot;mylocation&quot;))
    .executes((sender, args) -&gt; {
        String stringArg = (String) args[0];
        PotionEffectType potionArg = (PotionEffectType) args[1];
        Location locationArg = (Location) args[2];
    })
    .register();
</code></pre>
</div>
<p>$$\downarrow$$</p>
<div class="multi-pre">
<pre><code class="language-java 9.0.0">new CommandAPICommand(&quot;cmd&quot;)
    .withArguments(new StringArgument(&quot;mystring&quot;))
    .withArguments(new PotionEffectArgument(&quot;mypotion&quot;))
    .withArguments(new LocationArgument(&quot;mylocation&quot;))
    .executes((sender, args) -&gt; {
        String stringArg = (String) args.get(&quot;mystring&quot;);
        PotionEffectType potionArg = (PotionEffectType) args.get(&quot;mypotion&quot;);
        Location locationArg = (Location) args.get(&quot;mylocation&quot;);
    })
    .register();
</code></pre>
</div>
<hr />
<h3 id="commandapi-helper-methods"><a class="header" href="#commandapi-helper-methods"><code>CommandAPI</code> helper methods</a></h3>
<p>The <code>CommandAPI.failWithBaseComponents(message)</code> and <code>CommandAPI.failWithAdventureComponent(message)</code> methods have now been moved from <code>CommandAPI</code> to <code>CommandAPIBukkit</code>, because these methods are Bukkit/Spigot/Paper specific and don't exist for other platforms (e.g. Velocity, Fabric, Sponge):</p>
<div class="multi-pre">
<pre><code class="language-java 8.8.x">CommandAPI.failWithBaseComponents(...);
CommandAPI.failWithAdventureComponent(...);
</code></pre>
</div>
<p>$$\downarrow$$</p>
<div class="multi-pre">
<pre><code class="language-java 9.0.0">CommandAPIBukkit.failWithBaseComponents(...);
CommandAPIBukkit.failWithAdventureComponent(...);
</code></pre>
</div>
<hr />
<h3 id="removal-of-the-environmentargument"><a class="header" href="#removal-of-the-environmentargument">Removal of the <code>EnvironmentArgument</code></a></h3>
<p>The <code>EnvironmentArgument</code> has been removed in this update, as it was implemented incorrectly and is not fit for purpose. Instead, the CommandAPI has the more accurate <code>WorldArgument</code>.</p>
<hr />
<h3 id="changes-to-the-teamargument"><a class="header" href="#changes-to-the-teamargument">Changes to the <code>TeamArgument</code></a></h3>
<p>The <code>TeamArgument</code> has been updated to no longer use a <code>String</code> as its return type. Instead, you can now just use a <code>Team</code> object directly:</p>
<div class="multi-pre">
<pre><code class="language-java 8.8.x">new CommandAPICommand(&quot;team&quot;)
    .withArguments(new TeamArgument(&quot;team&quot;))
    .executes((sender, args) -&gt; {
        String teamName = (String) args.get(&quot;team&quot;);
        Team team = Bukkit.getScoreboardManager().getMainScoreboard().getTeam(teamName);
    })
    .register();
</code></pre>
</div>
<p>$$\downarrow$$</p>
<div class="multi-pre">
<pre><code class="language-java 9.0.0">new CommandAPICommand(&quot;team&quot;)
    .withArguments(new TeamArgument(&quot;team&quot;))
    .executes((sender, args) -&gt; {
        Team team = (Team) args.get(&quot;team&quot;);
    })
    .register();
</code></pre>
</div>
<hr />
<h3 id="changes-to-the-objectiveargument"><a class="header" href="#changes-to-the-objectiveargument">Changes to the <code>ObjectiveArgument</code></a></h3>
<p>The <code>ObjectiveArgument</code> has been updated to no longer use a <code>String</code> as its return type. Instead, you can now just use an <code>Objective</code> object directly:</p>
<div class="multi-pre">
<pre><code class="language-java 8.8.x">new CommandAPICommand(&quot;objective&quot;)
    .withArguments(new ObjectiveArgument(&quot;objective&quot;))
    .executes((sender, args) -&gt; {
        String objectiveName = (String) args.get(&quot;objective&quot;);
        Objective objective = Bukkit.getScoreboardManager().getMainScoreboard().getObjective(objectiveName);
    })
    .register();
</code></pre>
</div>
<p>$$\downarrow$$</p>
<div class="multi-pre">
<pre><code class="language-java 9.0.0">new CommandAPICommand(&quot;objective&quot;)
    .withArguments(new ObjectiveArgument(&quot;objective&quot;))
    .executes((sender, args) -&gt; {
        Objective objective = (Objective) args.get(&quot;objective&quot;);
    })
    .register();
</code></pre>
</div>
<hr />
<h3 id="changes-to-the-listargumentbuilder"><a class="header" href="#changes-to-the-listargumentbuilder">Changes to the <code>ListArgumentBuilder</code></a></h3>
<p>The <code>ListArgumentBuilder</code> no longer has <code>withList(Function&lt;CommandSender, Collection&lt;T&gt;&gt; list)</code> and instead uses <code>SuggestionInfo</code> to have <code>withList(Function&lt;SuggestionInfo&lt;CommandSender&gt;, Collection&lt;T&gt;&gt; list)</code>.</p>
<p>This now allows you to access more information when generating a list dynamically instead of just the command sender. To access the original command sender, you can use the <code>sender()</code> method from <code>SuggestionInfo</code>:</p>
<div class="multi-pre">
<pre><code class="language-java 8.8.x">ListArgument&lt;?&gt; arg = new ListArgumentBuilder&lt;&gt;(&quot;values&quot;, &quot;, &quot;)
    .withList(sender -&gt; List.of(&quot;cat&quot;, &quot;wolf&quot;, &quot;axolotl&quot;, sender.getName()))
    .withStringMapper()
    .buildGreedy();
</code></pre>
</div>
<p>$$\downarrow$$</p>
<div class="multi-pre">
<pre><code class="language-java 9.0.0">ListArgument&lt;?&gt; arg = new ListArgumentBuilder&lt;&gt;(&quot;values&quot;, &quot;, &quot;)
    .withList(info -&gt; List.of(&quot;cat&quot;, &quot;wolf&quot;, &quot;axolotl&quot;, info.sender().getName()))
    .withStringMapper()
    .buildGreedy();
</code></pre>
</div>
<hr />
<h3 id="changes-to-the-rotation-wrapper"><a class="header" href="#changes-to-the-rotation-wrapper">Changes to the <code>Rotation</code> wrapper</a></h3>
<p>The <code>Rotation</code> class now uses a constructor which has the <strong>yaw first, and the pitch second</strong>, instead of the pitch first and the yaw second.</p>
<div class="multi-pre">
<pre><code class="language-java 8.8.x">new Rotation(20, 80); // Yaw = 80, Pitch = 20
</code></pre>
</div>
<p>$$\downarrow$$</p>
<div class="multi-pre">
<pre><code class="language-java 9.0.0">new Rotation(20, 80); // Yaw = 20, Pitch = 80
</code></pre>
</div>
<hr />
<h3 id="changes-to-the-scoreboardslot-wrapper"><a class="header" href="#changes-to-the-scoreboardslot-wrapper">Changes to the <code>ScoreboardSlot</code> wrapper</a></h3>
<p>The <code>ScoreboardSlot</code> wrapper is now an enum that has direct support for sidebar team colors, via the <code>SIDEBAR_TEAM_###</code> enum values, for example <code>SIDEBAR_TEAM_RED</code>;</p>
<div class="multi-pre">
<pre><code class="language-java 8.8.x">ScoreboardSlot slot = // Some ScoreboardSlot
DisplaySlot displaySlot = slot.getDisplaySlot(); // Returns PLAYER_LIST, SIDEBAR or BELOW_NAME

// Extract the color if necessary
if (slot.hasTeamColor()) {
    ChatColor color = slot.getTeamColor();
}
</code></pre>
</div>
<p>$$\downarrow$$</p>
<div class="multi-pre">
<pre><code class="language-java 9.0.0">ScoreboardSlot slot = // Some ScoreboardSlot
DisplaySlot displaySlot = slot.getDisplaySlot(); // Returns PLAYER_LIST, BELOW_NAME or SIDEBAR_TEAM_###
</code></pre>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="upgrading-guide-1"><a class="header" href="#upgrading-guide-1">Upgrading guide</a></h1>
<h2 id="from-860-to-870"><a class="header" href="#from-860-to-870">From 8.6.0 to 8.7.0</a></h2>
<h3 id="sound-arguments-1"><a class="header" href="#sound-arguments-1">Sound arguments</a></h3>
<p>This update introduces a backwards-incompatible change to the <code>SoundArgument</code> which was introduced in 8.6.0. SoundArguments no longer need a generic type parameter:</p>
<div class="multi-pre">
<pre><code class="language-java 8.6.0">new SoundArgument&lt;Sound&gt;(&quot;sound&quot;)
</code></pre>
</div>
<p>$$\downarrow$$</p>
<div class="multi-pre">
<pre><code class="language-java 8.7.0">new SoundArgument(&quot;sound&quot;)
</code></pre>
</div>
<p><code>NamespacedKey</code> SoundArguments no longer need a <code>SoundType</code> parameter, instead the <code>NamespacedKey</code> constructor should be used:</p>
<div class="multi-pre">
<pre><code class="language-java 8.6.0">new SoundArgument&lt;NamespacedKey&gt;(&quot;sound&quot;, SoundType.NAMESPACED_KEY)
</code></pre>
</div>
<p>$$\downarrow$$</p>
<div class="multi-pre">
<pre><code class="language-java 8.7.0">new SoundArgument.NamespacedKey(&quot;sound&quot;)
</code></pre>
</div>
<h3 id="entity-selector-arguments"><a class="header" href="#entity-selector-arguments">Entity selector arguments</a></h3>
<p>Entity selector arguments no longer need a generic type parameter or a <code>EntitySelector</code> parameter. Instead, the corresponding constructor should be used instead:</p>
<div class="multi-pre">
<pre><code class="language-java 8.6.0">new EntitySelectorArgument&lt;Player&gt;(&quot;target&quot;, EntitySelector.ONE_PLAYER)
new EntitySelectorArgument&lt;Collection&lt;Player&gt;&gt;(&quot;target&quot;, EntitySelector.MANY_PLAYERS)

new EntitySelectorArgument&lt;Entity&gt;(&quot;target&quot;, EntitySelector.ONE_ENTITY)
new EntitySelectorArgument&lt;Collection&lt;Entity&gt;&gt;(&quot;target&quot;, EntitySelector.MANY_ENTITIES)
</code></pre>
</div>
<p>$$\downarrow$$</p>
<div class="multi-pre">
<pre><code class="language-java 8.7.0">new EntitySelectorArgument.OnePlayer(&quot;target&quot;)
new EntitySelectorArgument.ManyPlayers(&quot;target&quot;)

new EntitySelectorArgument.OneEntity(&quot;target&quot;)
new EntitySelectorArgument.ManyEntities(&quot;target&quot;)
</code></pre>
</div>
<h3 id="scoreholder-arguments"><a class="header" href="#scoreholder-arguments">Scoreholder arguments</a></h3>
<p>The <code>ScoreHolderArgument</code> no longer needs a generic type parameter or a <code>ScoreHolderType</code> parameter. Instead, the corresponding constructor should be used instead:</p>
<div class="multi-pre">
<pre><code class="language-java 8.6.0">new ScoreHolderArgument&lt;String&gt;(nodeName, ScoreHolderType.SINGLE);
new ScoreHolderArgument&lt;Collection&lt;String&gt;&gt;(nodeName, ScoreHolderType.MULTIPLE);
</code></pre>
</div>
<p>$$\downarrow$$</p>
<div class="multi-pre">
<pre><code class="language-java 8.7.0">new ScoreHolderArgument.Single(nodeName);
new ScoreHolderArgument.Multiple(nodeName);
</code></pre>
</div>
<hr />
<h2 id="from-851-to-860"><a class="header" href="#from-851-to-860">From 8.5.1 to 8.6.0</a></h2>
<h3 id="sound-arguments-2"><a class="header" href="#sound-arguments-2">Sound arguments</a></h3>
<p>In 8.6.0, the <code>SoundArgument</code> now supports returning a <code>Sound</code> or <code>NamespacedKey</code> object. More information on how to use this can be found in the <a href="./argument_sound.html">Sound arguments</a> page. <code>SoundArgument</code> objects now require a generic type parameter to specify what the return type will be (either <code>Sound</code> or <code>NamespacedKey</code>). For the default behaviour, use <code>Sound</code> as the generic type parameter:</p>
<pre><code class="language-java">new SoundArgument(&quot;sound&quot;)
</code></pre>
<p>$$\downarrow$$</p>
<pre><code class="language-java">new SoundArgument&lt;Sound&gt;(&quot;sound&quot;)
</code></pre>
<h3 id="tooltips"><a class="header" href="#tooltips">Tooltips</a></h3>
<p>In 8.6.0, tooltips have been reworked to provide support for Spigot's <code>BaseComponent[]</code>s, and Adventure's <code>Component</code>s. As a result, the default method <code>StringTooltip.of()</code> and <code>Tooltip.of()</code> have been deprecated in favour of the better named <code>StringTooltip.ofString()</code> and <code>Tooltip.ofString()</code> methods:</p>
<pre><code class="language-java">StringTooltip.of(&quot;wave&quot;, &quot;Waves at a player&quot;)

Tooltip.of(player.getWorld().getSpawnLocation(), &quot;World spawn&quot;)
</code></pre>
<p>$$\downarrow$$</p>
<pre><code class="language-java">StringTooltip.ofString(&quot;wave&quot;, &quot;Waves at a player&quot;)

Tooltip.ofString(player.getWorld().getSpawnLocation(), &quot;World spawn&quot;)
</code></pre>
<p>Additionally, the <code>IStringTooltip</code> interface's <code>getTooltip</code> method was changed to return a Brigadier <code>Message</code> object instead of a <code>String</code>. To use the <code>IStringTooltip</code> directly, you now have to add Brigadier to your project's dependencies (info on how to do that can be found <a href="https://github.com/Mojang/brigadier#installation">here</a>).</p>
<p>You can use the <code>Tooltip.messageFromString(String)</code> to easily upgrade to the new <code>Message</code> return type:</p>
<pre><code class="language-java">@Override
public String getTooltip() {
    return this.itemstack.getItemMeta().getLore().get(0);
}
</code></pre>
<p>$$\downarrow$$</p>
<pre><code class="language-java">@Override
public Message getTooltip() {
    return Tooltip.messageFromString(this.itemstack.getItemMeta().getLore().get(0));
}
</code></pre>
<h3 id="command-failures"><a class="header" href="#command-failures">Command failures</a></h3>
<p>To support Spigot's <code>BaseComponent[]</code>s and Adventure's <code>Component</code>s, the <code>CommandAPI.fail()</code> method has now been deprecated in favour of the better named <code>CommandAPI.failWithString()</code> method:</p>
<pre><code class="language-java">throw CommandAPI.fail(&quot;Error message&quot;);
</code></pre>
<p>$$\downarrow$$</p>
<pre><code class="language-java">throw CommandAPI.failWithString(&quot;Error message&quot;);
</code></pre>
<h3 id="list-arguments-1"><a class="header" href="#list-arguments-1">List arguments</a></h3>
<p>List arguments can now be implemented using an underlying text argument, instead of requiring it to be a greedy string. This allows you to use multiple lists in a command, in any position. As such, the <code>ListArgumentBuilder.build()</code> method has been deprecated and replaced with <code>ListArgumentBuilder.buildGreedy()</code> instead:</p>
<pre><code class="language-java">new ListArgumentBuilder&lt;Material&gt;(&quot;materials&quot;)
    .withList(List.of(Material.values()))
    .withMapper(material -&gt; material.name().toLowerCase())
    .build();
</code></pre>
<p>$$\downarrow$$</p>
<pre><code class="language-java">new ListArgumentBuilder&lt;Material&gt;(&quot;materials&quot;)
    .withList(List.of(Material.values()))
    .withMapper(material -&gt; material.name().toLowerCase())
    .buildGreedy();
</code></pre>
<hr />
<h2 id="from-850-to-851"><a class="header" href="#from-850-to-851">From 8.5.0 to 8.5.1</a></h2>
<h3 id="brigadier-arguments"><a class="header" href="#brigadier-arguments">Brigadier arguments</a></h3>
<p>In 8.5.1, the methods <code>Brigadier.fromArgument</code> and <code>Brigadier.toSuggestions</code> were changed to use <code>Argument</code> based parameters instead of <code>String</code> based parameters. Instead of providing the node name, you now have to provide the whole argument:</p>
<pre><code class="language-java">Argument&lt;?&gt; myArgument = new StringArgument(&quot;myargument&quot;);
List&lt;Argument&lt;?&gt;&gt; argumentList = List.of(myArgument);

Brigadier.fromArgument(argumentList, &quot;myargument&quot;);
Brigadier.toSuggestions(&quot;myargument&quot;, argumentList);
</code></pre>
<p>$$\downarrow$$</p>
<pre><code class="language-java">Argument&lt;?&gt; myArgument = new StringArgument(&quot;myargument&quot;);
List&lt;Argument&lt;?&gt;&gt; argumentList = List.of(myArgument);

Brigadier.fromArgument(argumentList, myArgument);
Brigadier.toSuggestions(myArgument, argumentList);
</code></pre>
<hr />
<h2 id="from-831-to-840"><a class="header" href="#from-831-to-840">From 8.3.1 to 8.4.0</a></h2>
<h3 id="getting-a-list-of-registered-commands-1"><a class="header" href="#getting-a-list-of-registered-commands-1">Getting a list of registered commands</a></h3>
<p>In 8.2.1, the CommandAPI exposed <code>CommandAPIHandler.getInstance().registeredCommands</code> to get a list of registered commands. This has now been changed and properly implemented as a getter method which can be accessed from <code>CommandAPI</code>:</p>
<pre><code class="language-java">CommandAPIHandler.getInstance().registeredCommands
</code></pre>
<p>$$\downarrow$$</p>
<pre><code class="language-java">CommandAPI.getRegisteredCommands()
</code></pre>
<h3 id="entity-selector-arguments-1"><a class="header" href="#entity-selector-arguments-1">Entity selector arguments</a></h3>
<p>The import for <code>EntitySelector</code> for the <code>EntitySelectorArgument</code> has moved to improve CommandAPI shading support with jar minimization:</p>
<pre><code class="language-java">dev.jorel.commandapi.arguments.EntitySelectorArgument.EntitySelector
</code></pre>
<p>$$\downarrow$$</p>
<pre><code class="language-java">dev.jorel.commandapi.arguments.EntitySelector
</code></pre>
<h3 id="custom-arguments-1"><a class="header" href="#custom-arguments-1">Custom arguments</a></h3>
<p>Custom arguments are no longer restricted to a string-based argument or a keyed-based argument and can now be implemented over any existing argument &quot;base&quot;. This argument is now parameterized over two types: the first type being the return type of this custom argument and the second type being the return type of the &quot;base&quot; argument. Custom arguments should now use the new constructor that accepts an argument - more information on how to do that can be found on the <a href="./argument_custom.html">Custom arguments page</a>. It's recommended to review your implementation of custom arguments and upgrade them if you feel that you need a more powerful argument parser (for example, you might want to use a greedy string argument as the base argument instead of a string argument).</p>
<p>Custom arguments that are <em>not</em> keyed can be drop-in replaced with a <code>StringArgument</code>:</p>
<pre><code class="language-java">new CustomArgument&lt;T&gt;(&quot;nodename&quot;, inputInfo -&gt; {
    // Code here
    return T;
});
</code></pre>
<p>$$\downarrow$$</p>
<pre><code class="language-java">new CustomArgument&lt;T, String&gt;(new StringArgument(&quot;nodename&quot;), inputInfo -&gt; {
    // Code here
    return T;
});
</code></pre>
<p>Keyed custom arguments can be drop-in replaced with a <code>NamespacedKeyArgument</code>:</p>
<pre><code class="language-java">new CustomArgument&lt;T&gt;(&quot;nodename&quot;, inputInfo -&gt; {
    // Code here
    return T;
}, true);
</code></pre>
<p>$$\downarrow$$</p>
<pre><code class="language-java">new CustomArgument&lt;T, NamespacedKey&gt;(new NamespacedKeyArgument(&quot;nodename&quot;), inputInfo -&gt; {
    // Code here
    return T;
});
</code></pre>
<h3 id="nbt-arguments-1"><a class="header" href="#nbt-arguments-1">NBT arguments</a></h3>
<p>NBT arguments now have a different implementation if you're using the plugin version of the CommandAPI or shading the CommandAPI.</p>
<p>NBTCompoundArguments are now parameterized over their implemented NBTCompound implementation. For the NBT API, this means:</p>
<pre><code class="language-java">new NBTCompoundArgument(&quot;nbt&quot;);
</code></pre>
<p>$$\downarrow$$</p>
<pre><code class="language-java">new NBTCompoundArgument&lt;NBTContainer&gt;(&quot;nbt&quot;);
</code></pre>
<h4 id="if-youre-using-the-plugin-version-of-the-commandapi"><a class="header" href="#if-youre-using-the-plugin-version-of-the-commandapi">If you're using the plugin version of the CommandAPI</a></h4>
<p>You no longer have to include the NBT API separately, the CommandAPI comes with the NBT API built-in:</p>
<pre><code class="language-java">de.tr7zw.nbtapi.NBTContainer
</code></pre>
<p>$$\downarrow$$</p>
<pre><code class="language-java">dev.jorel.commandapi.nbtapi.NBTContainer
</code></pre>
<h4 id="if-youre-shading-the-commandapi"><a class="header" href="#if-youre-shading-the-commandapi">If you're shading the CommandAPI</a></h4>
<p>You now need to shade the NBT API into your plugin (as well as the CommandAPI). So the CommandAPI knows how to use the underlying implementation of the NBT API, you have to configure it using the <code>CommandAPIConfig.initializeNBTAPI()</code> method in <code>CommandAPI.onLoad()</code>. More information on how to do that can be found on the <a href="./argument_nbt.html#shading-usage-setup">NBT arguments page, under Shading usage setup</a>.</p>
<hr />
<h2 id="from-800-or-earlier-to-810"><a class="header" href="#from-800-or-earlier-to-810">From 8.0.0 or earlier to 8.1.0</a></h2>
<p>Arguments are now parameterized over a generic type. This does very little in terms of the running of the CommandAPI, but does ensure type safety with its internals. Instances of the <code>Argument</code> type now have to be parameterized. In general, this basically means:</p>
<pre><code class="language-java">Argument myArgument = new GreedyStringArgument(&quot;arg&quot;);
</code></pre>
<p>$$\downarrow$$</p>
<pre><code class="language-java">Argument&lt;?&gt; myArgument = new GreedyStringArgument(&quot;arg&quot;);
</code></pre>
<p>Arguments that have multiple return types also need to be parameterized over their return type. This includes:</p>
<ul>
<li><code>CustomArgument</code></li>
<li><code>EntitySelectorArgument</code></li>
<li><code>ScoreholderArgument</code></li>
</ul>
<p>For example:</p>
<pre><code class="language-java">new EntitySelectorArgument(&quot;target&quot;, EntitySelector.ONE_PLAYER);
</code></pre>
<p>$$\downarrow$$</p>
<pre><code class="language-java">new EntitySelectorArgument&lt;Player&gt;(&quot;target&quot;, EntitySelector.ONE_PLAYER);
</code></pre>
<hr />
<h2 id="from-version-700-to-800"><a class="header" href="#from-version-700-to-800">From version 7.0.0 to 8.0.0</a></h2>
<h3 id="particle-arguments-1"><a class="header" href="#particle-arguments-1">Particle arguments</a></h3>
<p>Particle arguments no longer return Bukkit's <code>org.bukkit.Particle</code> enum, but now return a wrapper <code>dev.jorel.commandapi.wrappers.ParticleData</code> instead. More information about this wrapper class and how to use it can be found on the <a href="./argument_particles.html">particle arguments page</a>. To update, change any <code>Particle</code> casts into a <code>ParticleData</code> cast instead:</p>
<pre><code class="language-java">new CommandAPICommand(&quot;mycommand&quot;)
    .withArgument(new ParticleArgument(&quot;particle&quot;))
    .executes((sender, args) -&gt; {
        Particle particle = (Particle) args[0];
        // Do stuff with particle
    })
    .register();
</code></pre>
<p>$$\downarrow$$</p>
<pre><code class="language-java">new CommandAPICommand(&quot;mycommand&quot;)
    .withArgument(new ParticleArgument(&quot;particle&quot;))
    .executes((sender, args) -&gt; {
        ParticleData particleData = (ParticleData) args[0];

        Particle particle = particleData.particle();
        Object data = particleData.data();

        // Do stuff with particle and data
    })
    .register();
</code></pre>
<hr />
<h2 id="from-version-652-to-700"><a class="header" href="#from-version-652-to-700">From version 6.5.2 to 7.0.0</a></h2>
<h3 id="maven-repository"><a class="header" href="#maven-repository">Maven repository</a></h3>
<p>The Maven repository used to serve the CommandAPI has changed from JitPack.io to Maven Central. For Maven projects, you no longer require wan explicit <code>&lt;repository&gt;</code> entry for the CommandAPI. for Gradle projects, you need to ensure <code>mavenCentral()</code> in present in your <code>repositories</code> section.</p>
<p><strong>The group ID has changed from <code>dev.jorel.CommandAPI</code> to <code>dev.jorel</code></strong></p>
<p>More information about setting up your development environment can be found in <a href="./setup_dev.html">Setting up your development environment</a>.</p>
<h3 id="commandapi-command-failures"><a class="header" href="#commandapi-command-failures">CommandAPI command failures</a></h3>
<p>The <code>CommandAPI.fail()</code> no longer automatically throws the exception that it creates, and instead now requires you to manually throw the exception yourself. This improves upon invalid states in command executors and allows invalid states to be identified more easily at compile time. To update, simply add the <code>throw</code> keyword before you call <code>CommandAPI.fail()</code>:</p>
<pre><code class="language-java">new CommandAPICommand(&quot;mycommand&quot;)
    .executes((sender, args) -&gt; {
        if(!sender.hasPermission(&quot;some.permission&quot;)) {
            CommandAPI.fail(&quot;You don't have permission to run /mycommand!&quot;);
            return;
        }
        sender.sendMessage(&quot;Hello!&quot;);
    })
</code></pre>
<p>$$\downarrow$$</p>
<pre><code class="language-java">new CommandAPICommand(&quot;mycommand&quot;)
    .executes((sender, args) -&gt; {
        if(!sender.hasPermission(&quot;some.permission&quot;)) {
            throw CommandAPI.fail(&quot;You don't have permission to run /mycommand!&quot;);
        }
        sender.sendMessage(&quot;Hello!&quot;);
    })
</code></pre>
<h3 id="suggestions"><a class="header" href="#suggestions">Suggestions</a></h3>
<p>Suggestions have been overhauled and no longer take in a <code>Function&lt;SuggestionsInfo, String[]&gt;</code> anymore. Instead, they now take in a <code>ArgumentSuggestions</code> object which represents argument suggestions (and whether they are executed asynchronously or have tooltips).</p>
<h4 id="normal-string-suggestions"><a class="header" href="#normal-string-suggestions">Normal (string) suggestions</a></h4>
<p>These normal suggestions methods have been replaced with an <code>ArgumentSuggestions</code> parameter instead of a function:</p>
<pre><code class="language-java">Argument replaceSuggestions(Function&lt;SuggestionInfo, String[]&gt; suggestions);
Argument includeSuggestions(Function&lt;SuggestionInfo, String[]&gt; suggestions);
</code></pre>
<p>$$\downarrow$$</p>
<pre><code class="language-java">Argument replaceSuggestions(ArgumentSuggestions suggestions);
Argument includeSuggestions(ArgumentSuggestions suggestions);
</code></pre>
<p>The same functionality can be reproduced by wrapping your existing functions in <code>ArgumentSuggestions.strings</code>:</p>
<pre><code class="language-java">List&lt;Argument&gt; arguments = new ArrayList&lt;&gt;();
arguments.add(new StringArgument(&quot;world&quot;).replaceSuggestions(info -&gt; 
    new String[] {&quot;northland&quot;, &quot;eastland&quot;, &quot;southland&quot;, &quot;westland&quot; }
));
</code></pre>
<p>$$\downarrow$$</p>
<pre><code class="language-java">List&lt;Argument&gt; arguments = new ArrayList&lt;&gt;();
arguments.add(new StringArgument(&quot;world&quot;).replaceSuggestions(ArgumentSuggestions.strings(info -&gt; 
    new String[] {&quot;northland&quot;, &quot;eastland&quot;, &quot;southland&quot;, &quot;westland&quot; }
)));
</code></pre>
<h4 id="normal-strings-with-tooltips-suggestions"><a class="header" href="#normal-strings-with-tooltips-suggestions">Normal (strings with tooltips) suggestions</a></h4>
<p>The <code>...T()</code> methods have been replaced with the normal methods above, and can use the <code>ArgumentSuggestions.stringsWithTooltips</code> method:</p>
<pre><code class="language-java">Argument replaceSuggestionsT(Function&lt;SuggestionInfo, IStringTooltip[]&gt; suggestions);
Argument includeSuggestionsT(Function&lt;SuggestionInfo, IStringTooltip[]&gt; suggestions);
</code></pre>
<p>$$\downarrow$$</p>
<pre><code class="language-java">Argument replaceSuggestions(ArgumentSuggestions suggestions);
Argument includeSuggestions(ArgumentSuggestions suggestions);
</code></pre>
<p>For example:</p>
<pre><code class="language-java">List&lt;Argument&gt; arguments = new ArrayList&lt;&gt;();
arguments.add(new StringArgument(&quot;emote&quot;)
    .replaceSuggestionsT( info -&gt; new IStringTooltip[] {
            StringTooltip.of(&quot;wave&quot;, &quot;Waves at a player&quot;),
            StringTooltip.of(&quot;hug&quot;, &quot;Gives a player a hug&quot;),
            StringTooltip.of(&quot;glare&quot;, &quot;Gives a player the death glare&quot;)
        }
    )
);
</code></pre>
<p>$$\downarrow$$</p>
<pre><code class="language-java">List&lt;Argument&gt; arguments = new ArrayList&lt;&gt;();
arguments.add(new StringArgument(&quot;emote&quot;)
    .replaceSuggestions(ArgumentSuggestions.stringsWithTooltips(info -&gt; new IStringTooltip[] {
            StringTooltip.of(&quot;wave&quot;, &quot;Waves at a player&quot;),
            StringTooltip.of(&quot;hug&quot;, &quot;Gives a player a hug&quot;),
            StringTooltip.of(&quot;glare&quot;, &quot;Gives a player the death glare&quot;)
        }
    ))
);
</code></pre>
<h4 id="safe-suggestions"><a class="header" href="#safe-suggestions">Safe suggestions</a></h4>
<p>Similar to above with normal suggestions, safe suggestions have been replaced with <code>replaceSafeSuggestions</code> and <code>includeSafeSuggestions</code> respectively:</p>
<pre><code class="language-java">Argument replaceWithSafeSuggestions(Function&lt;SuggestionInfo, S[]&gt; suggestions);
Argument includeWithSafeSuggestions(Function&lt;SuggestionInfo, S[]&gt; suggestions);
</code></pre>
<p>$$\downarrow$$</p>
<pre><code class="language-java">Argument replaceSafeSuggestions(SafeSuggestions&lt;T&gt; suggestions);
Argument includeSafeSuggestions(SafeSuggestions&lt;T&gt; suggestions);
</code></pre>
<p>These can be used with the <code>SafeSuggestions.suggest</code> and <code>SafeSuggestions.tooltips</code> methods to wrap existing functions. For example:</p>
<pre><code class="language-java">List&lt;Argument&gt; arguments = new ArrayList&lt;&gt;();
arguments.add(new RecipeArgument(&quot;recipe&quot;).replaceWithSafeSuggestions(info -&gt; 
    new Recipe[] { emeraldSwordRecipe, /* Other recipes here */ }
));
</code></pre>
<p>$$\downarrow$$</p>
<pre><code class="language-java">List&lt;Argument&gt; arguments = new ArrayList&lt;&gt;();
arguments.add(new RecipeArgument(&quot;recipe&quot;).replaceSafeSuggestions(SafeSuggestions.suggest(info -&gt; 
    new Recipe[] { emeraldSwordRecipe, /* Other recipes here */ }
)));
</code></pre>
<hr />
<h2 id="from-version-620-or-earlier-to-630"><a class="header" href="#from-version-620-or-earlier-to-630">From version 6.2.0 or earlier to 6.3.0</a></h2>
<p>Please refer to an older version of the documentation. This has been omitted to save space and reduce confusion in this upgrading section.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<p>Here's a list of questions that have come up time and time again which all have the same answer.</p>
<hr />
<h2 id="how-do-i-use-insert-feature-here-in-the-commandapi"><a class="header" href="#how-do-i-use-insert-feature-here-in-the-commandapi">How do I use (insert feature here) in the CommandAPI?</a></h2>
<p>The CommandAPI's documentation is the place to search for anything! In the top left corner of this documentation, you can find this <i class="fas fa-search"></i> icon. You can pretty much search for anything - it'll find it!</p>
<hr />
<h2 id="does-the-commandapi-support-reloading-via-reload"><a class="header" href="#does-the-commandapi-support-reloading-via-reload">Does the CommandAPI support reloading via <code>/reload</code>?</a></h2>
<p>Formally, no. If you are encountering issues with <code>/reload</code>, consider not using <code>/reload</code>. More information about reloading can be found in <a href="./reloading.html">Plugin reloading</a>.</p>
<hr />
<h2 id="does-the-commandapi-support-optional-arguments"><a class="header" href="#does-the-commandapi-support-optional-arguments">Does the CommandAPI support optional arguments?</a></h2>
<p>As of 9.0.0, yes! Please view information on optional arguments in <a href="./optional_arguments.html">Optional arguments</a>.</p>
<hr />
<h2 id="does-the-commandapi-support-suggestions-in-the-annotation-system"><a class="header" href="#does-the-commandapi-support-suggestions-in-the-annotation-system">Does the CommandAPI support suggestions in the annotation system?</a></h2>
<p>Not yet. The CommandAPI's annotation system was actually originally a little test on writing a compile-time annotation system which actually worked out much better than I had intended. I plan to rewrite the CommandAPI's annotation system to make it much more powerful (and support suggestions!). This is stated in the <a href="https://github.com/JorelAli/CommandAPI#future-project-plans--timeline">project roadmap</a></p>
<hr />
<h2 id="can-you-add-tooltips-to-literalmultiliteral-arguments"><a class="header" href="#can-you-add-tooltips-to-literalmultiliteral-arguments">Can you add tooltips to literal/multiliteral arguments?</a></h2>
<p>No. This is a Brigadier limitation.</p>
<blockquote>
<p><strong>Technical reason that this is a limitation of Brigadier</strong></p>
<p>Brigadier's code has two classes for arguments, <a href="https://github.com/Mojang/brigadier/blob/master/src/main/java/com/mojang/brigadier/tree/LiteralCommandNode.java"><code>LiteralCommandNode</code></a> and <a href="https://github.com/Mojang/brigadier/blob/master/src/main/java/com/mojang/brigadier/tree/ArgumentCommandNode.java"><code>ArgumentCommandNode</code></a>. The <code>ArgumentCommandNode</code> class contains a field <code>customSuggestions</code> of type <code>SuggestionProvider&lt;S&gt;</code> which is used to handle suggestions - this field is not present inside <code>LiteralCommandNode</code>, meaning that LiteralArguments cannot provide suggestions to users.</p>
<p>We need suggestions to provide tooltips. This is because <a href="https://github.com/Mojang/brigadier/blob/master/src/main/java/com/mojang/brigadier/suggestion/SuggestionProvider.java#L13"><code>SuggestionProvider</code> provides us with an instance of <code>SuggestionsBuilder</code></a>, <a href="https://github.com/Mojang/brigadier/blob/cf754c4ef654160dca946889c11941634c5db3d5/src/main/java/com/mojang/brigadier/suggestion/SuggestionsBuilder.java#L20"><code>SuggestionsBuilder</code> contains a <code>List&lt;Suggestion&gt;</code></a> and the <a href="https://github.com/Mojang/brigadier/blob/cf754c4ef654160dca946889c11941634c5db3d5/src/main/java/com/mojang/brigadier/suggestion/Suggestion.java#L14"><code>Suggestion</code> class contains <code>Message</code></a>. This <code>Message</code> class is what is needed to display a tooltip to users.</p>
</blockquote>
<hr />
<h2 id="can-i-change-the-message-that-is-sent-to-the-user-when-they-dont-have-permission-to-run-a-command"><a class="header" href="#can-i-change-the-message-that-is-sent-to-the-user-when-they-dont-have-permission-to-run-a-command">Can I change the message that is sent to the user when they don't have permission to run a command?</a></h2>
<p>No. That message is handled client-side and isn't controlled by the CommandAPI. An alternative solution is to perform permission checking <em>inside</em> the command and return a custom message if it's not satisfied:</p>
<pre><code class="language-java">new CommandAPICommand(&quot;mycommand&quot;)
    .withPermission(&quot;some.permission&quot;)
    .executes((sender, args) -&gt; {
        sender.sendMessage(&quot;Hello!&quot;);
    })
    .register();
</code></pre>
<p>$$\downarrow$$</p>
<pre><code class="language-java">new CommandAPICommand(&quot;mycommand&quot;)
    .executes((sender, args) -&gt; {
        if(!sender.hasPermission(&quot;some.permission&quot;)) {
            throw CommandAPI.failWithString(&quot;You don't have permission to run /mycommand!&quot;);
        }
        sender.sendMessage(&quot;Hello!&quot;);
    })
    .register();
</code></pre>
<hr />
<h2 id="can-i-change-the-message-that-is-sent-to-the-user-when-an-argument-isnt-valid"><a class="header" href="#can-i-change-the-message-that-is-sent-to-the-user-when-an-argument-isnt-valid">Can I change the message that is sent to the user when an argument isn't valid?</a></h2>
<p>No. That message is handled client-side and isn't controlled by the CommandAPI.</p>
<h2 id="my-suggestions-on-my-arguments-are-empty-or-dont-update-how-do-i-make-dynamic-suggestions"><a class="header" href="#my-suggestions-on-my-arguments-are-empty-or-dont-update-how-do-i-make-dynamic-suggestions">My suggestions on my arguments are empty or don't update. How do I make dynamic suggestions?</a></h2>
<p>Arguments with suggestions provided using <code>ArgumentSuggestions.strings(String...)</code> are calculated <em>when the command is registered</em>. In order to have argument suggestions calculated <em>when the command is being typed</em>, you need to use the lambda-variant of the <code>ArgumentSuggestions.strings(Function&lt;SuggestionInfo, String[]&gt; suggestions)</code> method instead. More information about the different methods can be found <a href="./argumentsuggestions.html#the-argumentsuggestions-interface">here</a>.</p>
<p>The easiest way to do this is to add <code>info -&gt;</code> at the start of your array:</p>
<pre><code class="language-java">ArgumentSuggestions.strings(SomeClass.someArray);
</code></pre>
<p>$$\downarrow$$</p>
<pre><code class="language-java">ArgumentSuggestions.strings(info -&gt; SomeClass.someArray);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="incompatible-version-information"><a class="header" href="#incompatible-version-information">Incompatible version information</a></h1>
<p>There are a few arguments that are incompatible with various versions of Minecraft. This page outlines the full list of incompatibilities that the CommandAPI has with what versions of Minecraft.</p>
<hr />
<h2 id="argument-changes-with-respect-to-minecraft-version"><a class="header" href="#argument-changes-with-respect-to-minecraft-version">Argument changes with respect to Minecraft version</a></h2>
<h3 id="chatarguments-chat-preview"><a class="header" href="#chatarguments-chat-preview">ChatArgument's chat preview</a></h3>
<p>Incompatible with Minecraft versions <strong>less than 1.19 and greater than 1.19.2</strong> <em>(Works on 1.19, 1.19.1 and 1.19.2)</em></p>
<h3 id="functionargument"><a class="header" href="#functionargument">FunctionArgument</a></h3>
<p>Running functions generated via the <code>FunctionArgument</code> on Minecraft version <strong>1.20.3</strong> and <strong>1.20.4</strong> will always return a value of 1, regardless of whether the command succeeds, fails, or returns a result. (Works normally on 1.20.2 and below). Trying to retrieve the list of commands in a function on Minecraft version <strong>1.20.3</strong> and <strong>1.20.4</strong> will always return an empty array.</p>
<hr />
<h2 id="commandapi-behavior-with-respect-to-minecraft-version"><a class="header" href="#commandapi-behavior-with-respect-to-minecraft-version">CommandAPI behavior with respect to Minecraft version</a></h2>
<h3 id="minecraft-version-116-and-beyond"><a class="header" href="#minecraft-version-116-and-beyond">Minecraft version 1.16 and beyond</a></h3>
<p>In Minecraft version <strong>1.16</strong>, the way datapacks were loaded changed in such a way that the CommandAPI had to put in additional countermeasures to provide full support to it. To illustrate this, this was the previous loading sequence for Bukkit servers in Minecraft 1.15:</p>
<p>\(\texttt{Server loads}\rightarrow\texttt{Plugins load}\rightarrow\texttt{Datapacks load}\rightarrow\texttt{Server finishes loading}\)</p>
<p>Instead however, Minecraft 1.16 changed the loading sequence to the following:</p>
<p>\(\texttt{Server loads}\rightarrow\texttt{Datapacks load}\rightarrow\texttt{Plugins load}\rightarrow\texttt{Server finishes loading}\)</p>
<p>Because the CommandAPI used to register vanilla Minecraft commands <em>before</em> datapacks (and thus, custom Minecraft functions), it was possible to register custom commands that can be used in functions. With this new loading sequence change in Minecraft 1.16, this meant that datapacks load first before the CommandAPI does, so custom commands are not registered and functions with custom commands would fail to load.</p>
<p>To resolve this, the CommandAPI reloads datapacks <em>and recipes</em> at the end:</p>
<p>\begin{align}
&amp;\quad\texttt{Server loads} \\
\rightarrow&amp;\quad\texttt{Datapacks load} \\
\rightarrow&amp;\quad\texttt{Plugins load} \\
\rightarrow&amp;\quad\texttt{Server finishes loading} \\
\rightarrow&amp;\quad\texttt{Datapacks are reloaded} &amp;&amp; \texttt{(by the CommandAPI)} \\
\rightarrow&amp;\quad\texttt{Recipes are reloaded} &amp;&amp; \texttt{(by the CommandAPI)}
\end{align}</p>
<p>By doing this, this means:</p>
<ul>
<li>Custom functions from datapacks are loaded twice</li>
<li>Recipes are reloaded twice, <em>including</em> recipes defined by other plugins</li>
</ul>
<p>Although this sounds pretty bad (since reloading these things twice can be time consuming, thus contributing to the server start-up time), it is the only way to make custom functions work in Minecraft 1.16 and beyond.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h1>
<p>This section summarizes the list of things that <em>could</em> go wrong with the CommandAPI and how to mitigate these circumstances.</p>
<hr />
<h2 id="argument-suggestions-are-empty-or-arent-updating"><a class="header" href="#argument-suggestions-are-empty-or-arent-updating">Argument suggestions are empty or aren't updating</a></h2>
<p>If you've registered a command with an argument and replaced/included additional suggestions, but the suggestions:</p>
<ul>
<li>Are empty (e.g. a list of worlds returns no suggestions)</li>
<li>Don't update automatically (e.g. a list of players doesn't update when new players join the game)</li>
</ul>
<p>This is most likely caused by using a constant array instead of using a lambda to dynamically update argument suggestions when the player requests them:</p>
<pre><code class="language-java">new StringArgument(&quot;players&quot;)
    .replaceSuggestions(ArgumentSuggestions.strings( 
        Bukkit.getOnlinePlayers().stream().map(Player::getName).toArray(String[]::new)
    ));
</code></pre>
<p>$$\downarrow$$</p>
<pre><code class="language-java">new StringArgument(&quot;players&quot;)
    .replaceSuggestions(ArgumentSuggestions.strings( 
        info -&gt; Bukkit.getOnlinePlayers().stream().map(Player::getName).toArray(String[]::new)
    ));
</code></pre>
<hr />
<h2 id="permissions-dont-work-shading-the-commandapi"><a class="header" href="#permissions-dont-work-shading-the-commandapi">Permissions don't work (shading the CommandAPI)</a></h2>
<p>If you're shading the CommandAPI and any of the following occur:</p>
<ul>
<li>Players with no permissions cannot run CommandAPI commands</li>
<li><code>.withPermission(CommandPermission.NONE)</code> doesn't work, even if a player has no permissions</li>
</ul>
<p>You've probably not initialized the CommandAPI correctly. To assign permissions to a command, you have to add <code>CommandAPI.onEnable()</code> to your plugin's <code>onEnable()</code> method.</p>
<hr />
<h2 id="ive-registered-my-command-but-nothing-happens"><a class="header" href="#ive-registered-my-command-but-nothing-happens">I've registered my command but nothing happens</a></h2>
<p>If you've registered a command, the command should be present in the console if verbose logging is enabled. If this does not appear in the console, check that you've:</p>
<ul>
<li>Used <code>.register()</code> at the end of your command declaration</li>
<li>Added <code>CommandAPI.onLoad()</code> and <code>CommandAPI.onEnable()</code> to your <code>onLoad()</code> and <code>onEnable()</code> methods if you're shading the CommandAPI</li>
<li>Not added the commands to your <code>plugin.yml</code> file if you're not shading the CommandAPI</li>
</ul>
<hr />
<h2 id="the-commandapi-doesnt-load-something-about-unsupportedclassversionerror-and-class-file-version-600"><a class="header" href="#the-commandapi-doesnt-load-something-about-unsupportedclassversionerror-and-class-file-version-600">The CommandAPI doesn't load, something about <code>UnsupportedClassVersionError</code> and &quot;class file version 60.0&quot;</a></h2>
<p>If you're getting an error which looks something like this (key thing to look for is <code>class file version 60.0</code>), then you're running an old and unsupported version of Java:</p>
<pre><code class="language-log">[06.09 16:48:26] [Server] [Server thread/ERROR]: Could not load 'plugins/CommandAPI.jar' in folder 'plugins'
org.bukkit.plugin.InvalidPluginExceptionjava.lang.UnsupportedClassVersionError: dev/jorel/commandapi/CommandAPIMain has been compiled by a more recent version of the Java Runtime (class file version 60.0), this version of the Java Runtime only recognizes class file versions up to 52.0
    at org.bukkit.plugin.java.JavaPluginLoader.loadPlugin(JavaPluginLoader.java:149) ~[spigot-1.16.5.jar:3096-Spigot-9fb885e-296df56]
    at org.bukkit.plugin.SimplePluginManager.loadPlugin(SimplePluginManager.java:394) ~[spigot-1.16.5.jar:3096-Spigot-9fb885e-296df56]
    at org.bukkit.plugin.SimplePluginManager.loadPlugins(SimplePluginManager.java:301) ~[spigot-1.16.5.jar:3096-Spigot-9fb885e-296df56]
    at org.bukkit.craftbukkit.v1_16_R3.CraftServer.loadPlugins(CraftServer.java:381) ~[spigot-1.16.5.jar:3096-Spigot-9fb885e-296df56]
    at net.minecraft.server.v1_16_R3.DedicatedServer.init(DedicatedServer.java:224) ~[spigot-1.16.5.jar:3096-Spigot-9fb885e-296df56]
    at net.minecraft.server.v1_16_R3.MinecraftServer.w(MinecraftServer.java:928) ~[spigot-1.16.5.jar:3096-Spigot-9fb885e-296df56]
    at net.minecraft.server.v1_16_R3.MinecraftServer.lambda$0(MinecraftServer.java:273) ~[spigot-1.16.5.jar:3096-Spigot-9fb885e-296df56]
    at java.lang.Thread.run(Thread.java:748) [?:1.8.0_271]
Caused byjava.lang.UnsupportedClassVersionError: dev/jorel/commandapi/CommandAPIMain has been compiled by a more recent version of the Java Runtime (class file version 60.0), this version of the Java Runtime only recognizes class file versions up to 52.0
    at java.lang.ClassLoader.defineClass1(Native Method) ~[?:1.8.0_271]
    at java.lang.ClassLoader.defineClass(ClassLoader.java:756) ~[?:1.8.0_271]
    at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142) ~[?:1.8.0_271]
    at org.bukkit.plugin.java.PluginClassLoader.findClass(PluginClassLoader.java:186) ~[spigot-1.16.5.jar:3096-Spigot-9fb885e-296df56]
    at java.lang.ClassLoader.loadClass(ClassLoader.java:418) ~[?:1.8.0_271]
    at org.bukkit.plugin.java.PluginClassLoader.loadClass0(PluginClassLoader.java:104) ~[spigot-1.16.5.jar:3096-Spigot-9fb885e-296df56]
    at org.bukkit.plugin.java.PluginClassLoader.loadClass(PluginClassLoader.java:99) ~[spigot-1.16.5.jar:3096-Spigot-9fb885e-296df56]
    at java.lang.ClassLoader.loadClass(ClassLoader.java:351) ~[?:1.8.0_271]
    at java.lang.Class.forName0(Native Method) ~[?:1.8.0_271]
    at java.lang.Class.forName(Class.java:348) ~[?:1.8.0_271]
    at org.bukkit.plugin.java.PluginClassLoader.&lt;init&gt;(PluginClassLoader.java:67) ~[spigot-1.16.5.jar:3096-Spigot-9fb885e-296df56]
    at org.bukkit.plugin.java.JavaPluginLoader.loadPlugin(JavaPluginLoader.java:145) ~[spigot-1.16.5.jar:3096-Spigot-9fb885e-296df56]
    ... more
</code></pre>
<p>As of CommandAPI 6.0.0 onwards, the CommandAPI is written in Java 16, so old versions such as Java 8 will not run the CommandAPI. Consider upgrading to Java 16.</p>
<p>For context, a list of Java versions and their class file version:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: right">Java version</th><th style="text-align: left">Class file version</th><th></th><th style="text-align: right">Java version</th><th style="text-align: left">Class file version</th></tr></thead><tbody>
<tr><td style="text-align: right"><strong>Java 17</strong></td><td style="text-align: left">61.0</td><td></td><td style="text-align: right"><strong>Java 12</strong></td><td style="text-align: left">56.0</td></tr>
<tr><td style="text-align: right"><strong>Java 16</strong></td><td style="text-align: left">60.0</td><td></td><td style="text-align: right"><strong>Java 11</strong></td><td style="text-align: left">55.0</td></tr>
<tr><td style="text-align: right"><strong>Java 15</strong></td><td style="text-align: left">59.0</td><td></td><td style="text-align: right"><strong>Java 10</strong></td><td style="text-align: left">54.0</td></tr>
<tr><td style="text-align: right"><strong>Java 14</strong></td><td style="text-align: left">58.0</td><td></td><td style="text-align: right"><strong>Java 9</strong></td><td style="text-align: left">53.0</td></tr>
<tr><td style="text-align: right"><strong>Java 13</strong></td><td style="text-align: left">57.0</td><td></td><td style="text-align: right"><strong>Java 8</strong></td><td style="text-align: left">52.0</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="server-errors-when-loading-datapacks-in-116"><a class="header" href="#server-errors-when-loading-datapacks-in-116">Server errors when loading datapacks in 1.16+</a></h2>
<p>If you get an error at the very start of the server's startup sequence along the lines of:</p>
<pre><code class="language-log">[15:57:29] [Worker-Main-5/ERROR]: Failed to load function mycustomnamespace:test
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: Whilst parsing command on line 2: Unknown or incomplete command, see below for error at position 0: &lt;--[HERE]
    at java.util.concurrent.CompletableFuture.encodeThrowable(Unknown Source) ~[?:1.8.0_261]
    at java.util.concurrent.CompletableFuture.completeThrowable(Unknown Source) [?:1.8.0_261]
    at java.util.concurrent.CompletableFuture$AsyncSupply.run(Unknown Source) [?:1.8.0_261]
    at java.util.concurrent.CompletableFuture$AsyncSupply.exec(Unknown Source) [?:1.8.0_261]
    at java.util.concurrent.ForkJoinTask.doExec(Unknown Source) [?:1.8.0_261]
    at java.util.concurrent.ForkJoinPool$WorkQueue.runTask(Unknown Source) [?:1.8.0_261]
    at java.util.concurrent.ForkJoinPool.runWorker(Unknown Source) [?:1.8.0_261]
    at java.util.concurrent.ForkJoinWorkerThread.run(Unknown Source) [?:1.8.0_261]
Caused by: java.lang.IllegalArgumentException: Whilst parsing command on line 2: Unknown or incomplete command, see below for error at position 0: &lt;--[HERE]
    at net.minecraft.server.v1_16_R1.CustomFunction.a(SourceFile:62) ~[spigot-1.16.1.jar:git-Spigot-758abbe-8dc1da1]
    at net.minecraft.server.v1_16_R1.CustomFunctionManager.a(SourceFile:84) ~[spigot-1.16.1.jar:git-Spigot-758abbe-8dc1da1]
    ... 6 more
</code></pre>
<p>You can safely ignore it - the CommandAPI fixes this later. This is described in more detail <a href="./functions.html#functions-in-116">here</a>.</p>
<hr />
<h2 id="running-reload-doesnt-work"><a class="header" href="#running-reload-doesnt-work">Running <code>/reload</code> doesn't work</a></h2>
<p>See <a href="./reloading.html">Plugin reloading</a></p>
<hr />
<h2 id="players-cannot-connecttimeout-when-joining"><a class="header" href="#players-cannot-connecttimeout-when-joining">Players cannot connect/timeout when joining</a></h2>
<p>If players cannot connect, this could be due to the size of the command data packet. To see the resultant packet being sent to players when they log in, enable the <code>create-dispatcher-json: true</code> setting and view the file size of the resultant file. If the file size is abnormally large <em>(Over 2MB is considered very large)</em>, consider reducing the number of <code>LiteralArguments</code> which your plugin uses.</p>
<hr />
<h2 id="my-issue-isnt-on-here-what-do-i-do"><a class="header" href="#my-issue-isnt-on-here-what-do-i-do">My issue isn't on here, what do I do?</a></h2>
<p>If you've found a bug that isn't solved here, submit a bug report on <a href="https://github.com/JorelAli/CommandAPI/issues/new/choose">the CommandAPI's issues page</a> and I'll try my best to resolve the issue!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="afterword"><a class="header" href="#afterword">Afterword</a></h1>
<div style="text-align: center;">
<h2 id="a-message-from-the-commandapis-author"><a class="header" href="#a-message-from-the-commandapis-author">A message from the CommandAPI's author</a></h2>
</div>
<p>Congratulations on making it to the end of the documentation! It's really long, but I did my best to make it the best (Bukkit/Spigot plugin) documentation in existence.</p>
<hr />
<h3 id="intro"><a class="header" href="#intro">Intro</a></h3>
<p>My name is Jorel, commonly known by my Minecraft username <em>Skepter</em>. I started the CommandAPI in the summer holidays between my first and second year at university. On the 19th August, 2018 I made my first commit to the CommandAPI project - just a month and a day after Minecraft 1.13 was released.</p>
<p>At the time, I just decided to call it &quot;The 1.13 Command API&quot; - it wasn't the catchiest name out there, but it sort of said what I wanted it to - it's a Command API for Minecraft 1.13, which was the update when the big overhaul to the command system was introduced.</p>
<p>It all started as a simple idea that can be summarized in 3 bullet points:</p>
<ul>
<li>Create an API to use the new command UI that was introduced in Minecraft 1.13</li>
<li>Make it so the developers don't have to understand/use Mojang's brigadier</li>
<li>Make it similar to Bukkit's existing API</li>
</ul>
<hr />
<h3 id="starting-out"><a class="header" href="#starting-out">Starting out</a></h3>
<p>After the release of version 1.2, two days after the initial release, I received my first GitHub issue. This was quite a shock to me - version 1.2 only had 11 total downloads so it seemed odd that someone managed to stumble upon it despite the fact that I did nothing to promote the CommandAPI. Little did I know that that one issue was the main motivation to keep this API alive after its initial release.</p>
<p>I would never have possible imagined in my wildest dreams that 2 years later, I would still be in contact with them and know that if I had not chosen to create this API, their server would not have survived beyond Minecraft 1.13, let alone Minecraft 1.15, two major Minecraft versions later.</p>
<hr />
<h3 id="reflection-on-the-project-and-personal-gains"><a class="header" href="#reflection-on-the-project-and-personal-gains">Reflection on the project and personal gains</a></h3>
<p>This project has been insane. Absolutely, utterly insane. At over 1000 commits and over 1,000,000 additions (that includes things such as lines of code, lines of generated HTML documentation etc.), I can say without a doubt that this is indeed my biggest project ever.</p>
<p>Not only have I managed to deal with hundreds of GitHub issues, I've also had the opportunity to try all sorts of technologies that I could have only dreamt of using, such as:</p>
<ul>
<li>Using GitHub Actions for cloud-based build checking and project status notifications</li>
<li>Using CodeFactor.io to automatically identify issues with my code</li>
<li>Publishing the CommandAPI to MavenCentral</li>
<li>Improving my understanding of Gradle to write Gradle instructions for the documentation</li>
<li>Learning Kotlin to add Kotlin examples to the CommandAPI's documentation</li>
<li>Learning TypeScript for an upcoming web-based CommandAPI command visualizer</li>
</ul>
<hr />
<h3 id="acknowledgements-early-development"><a class="header" href="#acknowledgements-early-development">Acknowledgements (early development)</a></h3>
<p>Anyway, I digress. I'd like to give credit to all of the people that have opened issues on the CommandAPI GitHub, for without these people, the CommandAPI would have only remained a shadow of what it is now. I'd like to give credit to <a href="https://github.com/JorelAli/CommandAPI/stargazers">the people that have starred</a> the CommandAPI on its GitHub page, and all of the members of the <a href="https://discord.com/invite/G4SzSxZ">CommandAPI Discord server</a>.</p>
<p>I would like to personally give thanks to the following people - these are people that have made a significant contribution to the project in terms of ideas or support early in the CommandAPI's development:</p>
<ul>
<li><strong><a href="https://github.com/Combustible">Combustible</a></strong>, who kickstarted the project by creating the CommandAPI's first issue. From this issue, this allowed the CommandAPI to have interoperability with Minecraft commands and functions which is by far the CommandAPI's most admirable feature. Additionally, Combustible helped raise awareness of the CommandAPI via the Spigot forums and Spigot issue tracker.</li>
<li><strong><a href="https://github.com/Draycia">Draycia</a></strong>, who suggested implementing lazy evaluation for argument suggestions. This has been extended to provide the CommandAPI's context-aware system for argument suggestions based on previously filled arguments.</li>
<li><strong><a href="https://github.com/HielkeMinecraft">HielkeMinecraft</a></strong>, who made three outstanding contributions to the CommandAPI. They created the suggestion of setting the result and success values of commands which improves the interoperability between commands registered with the CommandAPI and vanilla Minecraft commands. They also influenced the implementation of the requirements system to have more powerful command constraints and helped start the CommandAPI Discord server.</li>
<li><strong><a href="https://github.com/Minenash">Minenash</a></strong>, who was the driving force for the CommandAPI's 3.0 release, which added a plethora of new arguments to the CommandAPI. Minenash's research, code prototypes, documentation examples, bug testing and code review was a tremendous help to make the 3.0 release such a feature-rich version.</li>
<li><strong><a href="https://github.com/Michael-Ziluck">Michael-Ziluck</a></strong>, who created an amazing pull request that helped greatly improve the performance of the CommandAPI as well as structure the entire CommandAPI project into a multi-module Maven project which significantly improved the maintainability of the CommandAPI for the future.</li>
<li><strong><a href="https://github.com/portlek">portlek</a></strong>, who helped migrate the CommandAPI's repository to <a href="https://jitpack.io/#dev.jorel/CommandAPI">jitpack.io</a>. They helped debug some technical errors with remote building and tested that the repository was working throughout the process.</li>
<li><strong><a href="https://github.com/469512345">469512345</a></strong>, who redesigned and implemented the suggestions feature for arguments, bringing powerful asynchronous arguments and highly-extensible suggestions to the CommandAPI.  They also implemented the CommandTree feature to bring yet another way for developers to create commands with the CommandAPI.</li>
</ul>
<p>I'd also like to give a special mention to the following people that have helped find bugs or have supported the project in some way early in the CommandAPI's development: aianlinb, Baka-Mitai, Checkium, Comeza, DerpNerb, DogeBogey, endrdragon, EnragedRabisu, i509VCB, KieranGateley, lifespan, Loapu, Marvmallow, MatrixTunnel, Ricky12Awesome, SHsuperCM, SpaceCheetah, The_Gavster, Tinkot, vladfrangu, zedwick.</p>
<hr />
<h3 id="acknowledgements-commandapi-discord-server"><a class="header" href="#acknowledgements-commandapi-discord-server">Acknowledgements (CommandAPI Discord server)</a></h3>
<p>I'm well aware there are lots of users that have made significant contributions to the CommandAPI that aren't listed above! Over the past four years, hundreds of users have created GitHub issues, joined the CommandAPI Discord server and submitted pull requests to contribute to the CommandAPI.</p>
<p>I'd like to personally give thanks to my <em>✨Special Contributors</em> in the CommandAPI Discord server - these are users that have made an exceptionally significant contribution to the CommandAPI project in general, from helping new users get started with the CommandAPI, to contributing to the CommandAPI repository directly, to bringing a liveliness to the CommandAPI Discord server as a whole:</p>
<ul>
<li><strong><a href="https://github.com/willkroboth">willkroboth</a></strong>, the first <em>✨Special Contributor</em>, recognized for their above-and-beyond contribution to helping new CommandAPI Discord members.</li>
<li><strong><a href="https://github.com/DerEchtePilz">DerEchtePilz</a></strong>, recognized for their significant contribution of creating a Kotlin DSL for the CommandAPI (with the help of Sparky from the CommandAPI Discord server).</li>
<li><strong><a href="https://github.com/XHawk87">Hawk</a></strong>, recognized for becoming the lead developer of the CommandAPI annotation system.</li>
</ul>
<p>The CommandAPI would not be where it is currently without the community that has been established over the years in the CommandAPI Discord server. As such, I'd like to give a special thanks to some of the most active CommandAPI Discord server members that make the community feel lively:</p>
<ul>
<li>! AkaGiant !</li>
<li>Brought To You By</li>
<li>MineNash</li>
<li>TheGates</li>
<li>Strokkur24</li>
</ul>
<hr />
<h3 id="acknowledgements-donators"><a class="header" href="#acknowledgements-donators">Acknowledgements (Donators)</a></h3>
<p>I didn't really want to add a way for CommandAPI users to be able to contribute financially via donations because the CommandAPI is free for all and the cost of maintaining the CommandAPI is effectively negligible. That said, I'd like to give special thanks to those that have donated to the CommandAPI.</p>
<hr />
<h3 id="final-comments"><a class="header" href="#final-comments">Final comments</a></h3>
<p>I never really expected more than 5 or so people to use this API, so it was truly a pleasure to see everyone's responses, issues and suggestions that has made the CommandAPI what it is today.</p>
<p>Thank you so much for using the CommandAPI!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="sidebar.js"></script>
        <script type="text/javascript" src="mccmd.js"></script>
        <script type="text/javascript" src="kotlin-dsl.js"></script>
        <script type="text/javascript" src="jszip.min.js"></script>
        <script type="text/javascript" src="yaml.min.js"></script>
        <script type="text/javascript" src="pluginyml.js"></script>

        <script type="text/javascript">
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </body>
</html>
